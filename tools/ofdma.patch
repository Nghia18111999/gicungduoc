diff --git a/ns-3.26/src/internet/model/ipv4-l3-protocol.cc b/ns-3.26/src/internet/model/ipv4-l3-protocol.cc
index 43a198a..880e475 100644
--- a/ns-3.26/src/internet/model/ipv4-l3-protocol.cc
+++ b/ns-3.26/src/internet/model/ipv4-l3-protocol.cc
@@ -1,6 +1,7 @@
 // -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*-
 //
 // Copyright (c) 2006 Georgia Tech Research Corporation
+// Copyright (c) 2017 Cisco and/or its affiliates
 //
 // This program is free software; you can redistribute it and/or modify
 // it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,17 @@
 //
 // Author: George F. Riley<riley@ece.gatech.edu>
 //
+// Modified in 2017 by                  
+//          Balamurugan Ramachandran,
+//          Ramachandra Murthy,
+//          Bibek Sahu,
+//          Mukesh Taneja
+//
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
+ */
 
 #include "ns3/packet.h"
 #include "ns3/log.h"
@@ -66,7 +78,7 @@ Ipv4L3Protocol::GetTypeId (void)
     .AddAttribute ("FragmentExpirationTimeout",
                    "When this timeout expires, the fragments "
                    "will be cleared from the buffer.",
-                   TimeValue (Seconds (30)),
+                   TimeValue (MilliSeconds (500)),
                    MakeTimeAccessor (&Ipv4L3Protocol::m_fragmentExpirationTimeout),
                    MakeTimeChecker ())
     .AddTraceSource ("Tx",
diff --git a/ns-3.26/src/network/model/packet.cc b/ns-3.26/src/network/model/packet.cc
index 51ed315..3121788 100644
--- a/ns-3.26/src/network/model/packet.cc
+++ b/ns-3.26/src/network/model/packet.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,8 +16,21 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
+
 #include "packet.h"
 #include "ns3/assert.h"
 #include "ns3/log.h"
@@ -138,7 +152,8 @@ Packet::Packet ()
      * global UID
      */
     m_metadata (static_cast<uint64_t> (Simulator::GetSystemId ()) << 32 | m_globalUid, 0),
-    m_nixVector (0)
+    m_nixVector (0),
+    m_padSize (0)
 {
   m_globalUid++;
 }
@@ -147,7 +162,8 @@ Packet::Packet (const Packet &o)
   : m_buffer (o.m_buffer),
     m_byteTagList (o.m_byteTagList),
     m_packetTagList (o.m_packetTagList),
-    m_metadata (o.m_metadata)
+    m_metadata (o.m_metadata),
+    m_padSize (o.m_padSize)
 {
   o.m_nixVector ? m_nixVector = o.m_nixVector->Copy ()
     : m_nixVector = 0;
@@ -166,6 +182,7 @@ Packet::operator = (const Packet &o)
   m_metadata = o.m_metadata;
   o.m_nixVector ? m_nixVector = o.m_nixVector->Copy () 
     : m_nixVector = 0;
+  m_padSize = o.m_padSize;
   return *this;
 }
 
@@ -180,7 +197,8 @@ Packet::Packet (uint32_t size)
      * global UID
      */
     m_metadata (static_cast<uint64_t> (Simulator::GetSystemId ()) << 32 | m_globalUid, size),
-    m_nixVector (0)
+    m_nixVector (0),
+    m_padSize (0)
 {
   m_globalUid++;
 }
@@ -189,7 +207,8 @@ Packet::Packet (uint8_t const *buffer, uint32_t size, bool magic)
     m_byteTagList (),
     m_packetTagList (),
     m_metadata (0,0),
-    m_nixVector (0)
+    m_nixVector (0),
+    m_padSize (0)
 {
   NS_ASSERT (magic);
   Deserialize (buffer, size);
@@ -206,7 +225,8 @@ Packet::Packet (uint8_t const*buffer, uint32_t size)
      * global UID
      */
     m_metadata (static_cast<uint64_t> (Simulator::GetSystemId ()) << 32 | m_globalUid, size),
-    m_nixVector (0)
+    m_nixVector (0),
+    m_padSize (0)
 {
   m_globalUid++;
   m_buffer.AddAtStart (size);
@@ -220,7 +240,8 @@ Packet::Packet (const Buffer &buffer,  const ByteTagList &byteTagList,
     m_byteTagList (byteTagList),
     m_packetTagList (packetTagList),
     m_metadata (metadata),
-    m_nixVector (0)
+    m_nixVector (0),
+    m_padSize (0)
 {
 }
 
@@ -328,6 +349,16 @@ Packet::AddPaddingAtEnd (uint32_t size)
   m_byteTagList.AddAtEnd (GetSize ());
   m_buffer.AddAtEnd (size);
   m_metadata.AddPaddingAtEnd (size);
+  m_padSize = size;
+}
+void
+Packet::RemovePaddingAtEnd (void)
+{
+  NS_LOG_FUNCTION (this);
+  if (m_padSize > 0)
+    {
+      RemoveAtEnd (m_padSize);
+    }
 }
 void 
 Packet::RemoveAtEnd (uint32_t size)
diff --git a/ns-3.26/src/network/model/packet.h b/ns-3.26/src/network/model/packet.h
index ae871c9..d4024f5 100644
--- a/ns-3.26/src/network/model/packet.h
+++ b/ns-3.26/src/network/model/packet.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,7 +17,20 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
+
 #ifndef PACKET_H
 #define PACKET_H
 
@@ -298,6 +312,12 @@ public:
    * \returns the size in bytes of the packet
    */
   inline uint32_t GetSize (void) const;
+  /**
+   * \brief Returns the the size in bytes of the Padded bytes in the packet
+   *
+   * \returns the size in bytes of the packet Pad
+   */
+  inline uint32_t GetPadSize (void) const;
   /**
    * \brief Add header to this packet.
    *
@@ -372,6 +392,12 @@ public:
    * \param size number of padding bytes to add.
    */
   void AddPaddingAtEnd (uint32_t size);
+  /**
+   * \brief Add a zero-filled padding to the packet.
+   *
+   * \param size number of padding bytes to add.
+   */
+  void RemovePaddingAtEnd (void);
   /** 
    * \brief Remove size bytes from the end of the current packet.
    *
@@ -728,6 +754,7 @@ private:
   Ptr<NixVector> m_nixVector; //!< the packet's Nix vector
 
   static uint32_t m_globalUid; //!< Global counter of packets Uid
+  uint32_t        m_padSize;
 };
 
 /**
@@ -794,6 +821,11 @@ Packet::GetSize (void) const
   return m_buffer.GetSize ();
 }
 
+uint32_t
+Packet::GetPadSize (void) const
+{
+  return m_padSize;
+}
 } // namespace ns3
 
 #endif /* PACKET_H */
diff --git a/ns-3.26/src/propagation/model/propagation-loss-model.cc b/ns-3.26/src/propagation/model/propagation-loss-model.cc
index 4799eba..ce8ae59 100644
--- a/ns-3.26/src/propagation/model/propagation-loss-model.cc
+++ b/ns-3.26/src/propagation/model/propagation-loss-model.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as 
@@ -19,6 +20,18 @@
  * Contributions: Timo Bingmann <timo.bingmann@student.kit.edu>
  * Contributions: Tom Hewer <tomhewer@mac.com> for Two Ray Ground Model
  *                Pavel Boyko <boyko@iitp.ru> for matrix
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "propagation-loss-model.h"
@@ -69,6 +82,25 @@ PropagationLossModel::GetNext ()
   return m_next;
 }
 
+double 
+PropagationLossModel::DoCalcRxPower (double txPowerDbm,
+                                Ptr<MobilityModel> a,
+                                Ptr<MobilityModel> b,
+                                int BitMap, int ChannelNumber)
+{
+return 0.0;
+}
+
+double
+PropagationLossModel::CalcRxPower (double txPowerDbm,
+                                   Ptr<MobilityModel> a,
+                                   Ptr<MobilityModel> b,
+                                   int BitMap, int ChannelNumber)
+{
+  double self = DoCalcRxPower (txPowerDbm, a, b, BitMap, ChannelNumber);
+  return self;
+}
+
 double
 PropagationLossModel::CalcRxPower (double txPowerDbm,
                                    Ptr<MobilityModel> a,
diff --git a/ns-3.26/src/propagation/model/propagation-loss-model.h b/ns-3.26/src/propagation/model/propagation-loss-model.h
index bc8f383..4a153f5 100644
--- a/ns-3.26/src/propagation/model/propagation-loss-model.h
+++ b/ns-3.26/src/propagation/model/propagation-loss-model.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as 
@@ -20,6 +21,18 @@
  * Contributions: Gary Pei <guangyu.pei@boeing.com> for fixed RSS
  * Contributions: Tom Hewer <tomhewer@mac.com> for two ray ground model
  *                Pavel Boyko <boyko@iitp.ru> for matrix
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef PROPAGATION_LOSS_MODEL_H
@@ -93,6 +106,11 @@ public:
                       Ptr<MobilityModel> a,
                       Ptr<MobilityModel> b) const;
 
+  double CalcRxPower (double txPowerDbm,
+                      Ptr<MobilityModel> a,
+                      Ptr<MobilityModel> b,
+                      int BitMap, int ChannelNumber) ;
+
   /**
    * If this loss model uses objects of type RandomVariableStream,
    * set the stream numbers to the integers starting with the offset
@@ -134,6 +152,11 @@ private:
                                 Ptr<MobilityModel> a,
                                 Ptr<MobilityModel> b) const = 0;
 
+  virtual double DoCalcRxPower (double txPowerDbm,
+                                Ptr<MobilityModel> a,
+                                Ptr<MobilityModel> b,
+                                int BitMap, int ChannelNumber) ;
+
   /**
    * Subclasses must implement this; those not using random variables
    * can return zero
diff --git a/ns-3.26/src/propagation/wscript b/ns-3.26/src/propagation/wscript
index c8652be..1e5d470 100644
--- a/ns-3.26/src/propagation/wscript
+++ b/ns-3.26/src/propagation/wscript
@@ -13,6 +13,8 @@ def build(bld):
         'model/itu-r-1411-los-propagation-loss-model.cc',
         'model/itu-r-1411-nlos-over-rooftop-propagation-loss-model.cc',
         'model/kun-2600-mhz-propagation-loss-model.cc',
+        'model/enterprise-11ax-propagation-loss-model.cc',
+        'model/he-bitmap.cc',
         ]
 
     module_test = bld.create_ns3_module_test_library('propagation')
@@ -38,6 +40,8 @@ def build(bld):
         'model/itu-r-1411-los-propagation-loss-model.h',
         'model/itu-r-1411-nlos-over-rooftop-propagation-loss-model.h',
         'model/kun-2600-mhz-propagation-loss-model.h',
+        'model/enterprise-11ax-propagation-loss-model.h',
+        'model/he-bitmap.h',
         ]
 
     if (bld.env['ENABLE_EXAMPLES']):
diff --git a/ns-3.26/src/wifi/bindings/modulegen__gcc_ILP32.py b/ns-3.26/src/wifi/bindings/modulegen__gcc_ILP32.py
index f710b49..617fe37 100644
--- a/ns-3.26/src/wifi/bindings/modulegen__gcc_ILP32.py
+++ b/ns-3.26/src/wifi/bindings/modulegen__gcc_ILP32.py
@@ -9798,10 +9798,10 @@ def register_Ns3WifiPhyStateHelper_methods(root_module, cls):
     cls.add_method('SetReceiveOkCallback', 
                    'void', 
                    [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, double, ns3::WifiTxVector, ns3::WifiPreamble, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
-    ## wifi-phy-state-helper.h (module 'wifi'): void ns3::WifiPhyStateHelper::SwitchFromRxEndError(ns3::Ptr<ns3::Packet> packet, double snr) [member function]
+    ## wifi-phy-state-helper.h (module 'wifi'): void ns3::WifiPhyStateHelper::SwitchFromRxEndError(ns3::Ptr<ns3::Packet> packet, double snr, ns3::WifiTxVector) [member function]
     cls.add_method('SwitchFromRxEndError', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('double', 'snr')])
+                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('double', 'snr'), param('ns3::WifiTxVector', 'txVector')])
     ## wifi-phy-state-helper.h (module 'wifi'): void ns3::WifiPhyStateHelper::SwitchFromRxEndOk(ns3::Ptr<ns3::Packet> packet, double snr, ns3::WifiTxVector txVector, ns3::WifiPreamble preamble) [member function]
     cls.add_method('SwitchFromRxEndOk', 
                    'void', 
@@ -14878,10 +14878,10 @@ def register_Ns3MacLow_methods(root_module, cls):
     cls.add_constructor([param('ns3::MacLow const &', 'arg0')])
     ## mac-low.h (module 'wifi'): ns3::MacLow::MacLow() [constructor]
     cls.add_constructor([])
-    ## mac-low.h (module 'wifi'): ns3::Ptr<ns3::Packet> ns3::MacLow::AggregateToAmpdu(ns3::Ptr<ns3::Packet const> packet, ns3::WifiMacHeader const hdr) [member function]
+    ## mac-low.h (module 'wifi'): ns3::Ptr<ns3::Packet> ns3::MacLow::AggregateToAmpdu(ns3::Ptr<ns3::Packet const> packet, ns3::WifiMacHeader const hdr, ns3::Ptr<ns3::WifiMacQueue> aggQueue) [member function]
     cls.add_method('AggregateToAmpdu', 
                    'ns3::Ptr< ns3::Packet >', 
-                   [param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::WifiMacHeader const', 'hdr')])
+                   [param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::WifiMacHeader const', 'hdr'), param('ns3::Ptr<ns3::WifiMacQueue>', 'aggQueue')])
     ## mac-low.h (module 'wifi'): ns3::Time ns3::MacLow::CalculateOverallTxTime(ns3::Ptr<ns3::Packet const> packet, ns3::WifiMacHeader const * hdr, ns3::MacLowTransmissionParameters const & params) const [member function]
     cls.add_method('CalculateOverallTxTime', 
                    'ns3::Time', 
diff --git a/ns-3.26/src/wifi/bindings/modulegen__gcc_LP64.py b/ns-3.26/src/wifi/bindings/modulegen__gcc_LP64.py
index 9a8c2e2..9a50882 100644
--- a/ns-3.26/src/wifi/bindings/modulegen__gcc_LP64.py
+++ b/ns-3.26/src/wifi/bindings/modulegen__gcc_LP64.py
@@ -9798,10 +9798,10 @@ def register_Ns3WifiPhyStateHelper_methods(root_module, cls):
     cls.add_method('SetReceiveOkCallback', 
                    'void', 
                    [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, double, ns3::WifiTxVector, ns3::WifiPreamble, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
-    ## wifi-phy-state-helper.h (module 'wifi'): void ns3::WifiPhyStateHelper::SwitchFromRxEndError(ns3::Ptr<ns3::Packet> packet, double snr) [member function]
+    ## wifi-phy-state-helper.h (module 'wifi'): void ns3::WifiPhyStateHelper::SwitchFromRxEndError(ns3::Ptr<ns3::Packet> packet, double snr, ns3::WifiTxVector txVector) [member function]
     cls.add_method('SwitchFromRxEndError', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('double', 'snr')])
+                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('double', 'snr'), param('ns3::WifiTxVector', 'txVector')])
     ## wifi-phy-state-helper.h (module 'wifi'): void ns3::WifiPhyStateHelper::SwitchFromRxEndOk(ns3::Ptr<ns3::Packet> packet, double snr, ns3::WifiTxVector txVector, ns3::WifiPreamble preamble) [member function]
     cls.add_method('SwitchFromRxEndOk', 
                    'void', 
@@ -14881,7 +14881,7 @@ def register_Ns3MacLow_methods(root_module, cls):
     ## mac-low.h (module 'wifi'): ns3::Ptr<ns3::Packet> ns3::MacLow::AggregateToAmpdu(ns3::Ptr<ns3::Packet const> packet, ns3::WifiMacHeader const hdr) [member function]
     cls.add_method('AggregateToAmpdu', 
                    'ns3::Ptr< ns3::Packet >', 
-                   [param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::WifiMacHeader const', 'hdr')])
+                   [param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::WifiMacHeader const', 'hdr'), param('ns3::Ptr<ns3::WifiMacQueue>', 'aggQueue')])
     ## mac-low.h (module 'wifi'): ns3::Time ns3::MacLow::CalculateOverallTxTime(ns3::Ptr<ns3::Packet const> packet, ns3::WifiMacHeader const * hdr, ns3::MacLowTransmissionParameters const & params) const [member function]
     cls.add_method('CalculateOverallTxTime', 
                    'ns3::Time', 
diff --git a/ns-3.26/src/wifi/helper/wifi-helper.cc b/ns-3.26/src/wifi/helper/wifi-helper.cc
index 86bc8a1..b49884d 100644
--- a/ns-3.26/src/wifi/helper/wifi-helper.cc
+++ b/ns-3.26/src/wifi/helper/wifi-helper.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2008 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,19 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * Modified by Mitch Watrous <watrous@u.washington.edu>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "wifi-helper.h"
@@ -33,6 +47,7 @@
 #include "ns3/wifi-remote-station-manager.h"
 #include "ns3/wifi-channel.h"
 #include "ns3/yans-wifi-channel.h"
+#include "ns3/HE-wifi-channel.h"
 #include "ns3/propagation-delay-model.h"
 #include "ns3/propagation-loss-model.h"
 #include "ns3/mobility-model.h"
@@ -708,6 +723,31 @@ WifiHelper::SetStandard (enum WifiPhyStandard standard)
   m_standard = standard;
 }
 
+NetDeviceContainer
+WifiHelper::Install (const WifiPhyHelper &phyHelper,
+                     const WifiMacHelper &macHelper, NodeContainer c, Mac48Address addr) const
+{
+  NetDeviceContainer devices;
+  for (NodeContainer::Iterator i = c.Begin (); i != c.End (); ++i)
+    {
+      Ptr<Node> node = *i;
+      Ptr<WifiNetDevice> device = CreateObject<WifiNetDevice> ();
+      Ptr<WifiRemoteStationManager> manager = m_stationManager.Create<WifiRemoteStationManager> ();
+      Ptr<WifiMac> mac = macHelper.Create ();
+      Ptr<WifiPhy> phy = phyHelper.Create (node, device);
+      mac->SetAddress (addr);
+      mac->ConfigureStandard (m_standard);
+      phy->ConfigureStandard (m_standard);
+      device->SetMac (mac);
+      device->SetPhy (phy);
+      device->SetRemoteStationManager (manager);
+      node->AddDevice (device);
+      devices.Add (device);
+      NS_LOG_DEBUG ("node=" << node << ", mob=" << node->GetObject<MobilityModel> ());
+    }
+  return devices;
+}
+
 NetDeviceContainer
 WifiHelper::Install (const WifiPhyHelper &phyHelper,
                      const WifiMacHelper &macHelper, NodeContainer c) const
diff --git a/ns-3.26/src/wifi/helper/wifi-helper.h b/ns-3.26/src/wifi/helper/wifi-helper.h
index 8a55fcb..01227eb 100644
--- a/ns-3.26/src/wifi/helper/wifi-helper.h
+++ b/ns-3.26/src/wifi/helper/wifi-helper.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2008 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,19 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * Modified by Mitch Watrous <watrous@u.washington.edu>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_HELPER_H
@@ -295,6 +309,8 @@ public:
    */
   virtual NetDeviceContainer Install (const WifiPhyHelper &phy,
                                       const WifiMacHelper &mac, NodeContainer c) const;
+  virtual NetDeviceContainer Install (const WifiPhyHelper &phyHelper, const WifiMacHelper &macHelper,
+                                      NodeContainer c, Mac48Address addr) const;
   /**
    * \param phy the PHY helper to create PHY objects
    * \param mac the MAC helper to create MAC objects
diff --git a/ns-3.26/src/wifi/model/ap-wifi-mac.cc b/ns-3.26/src/wifi/model/ap-wifi-mac.cc
index 97702d2..f66a9cc 100644
--- a/ns-3.26/src/wifi/model/ap-wifi-mac.cc
+++ b/ns-3.26/src/wifi/model/ap-wifi-mac.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ap-wifi-mac.h"
@@ -35,6 +48,9 @@
 #include "mac-low.h"
 #include "amsdu-subframe-header.h"
 #include "msdu-aggregator.h"
+#include "msdu-standard-aggregator.h"
+#include "mpdu-standard-aggregator.h"
+
 
 namespace ns3 {
 
@@ -55,6 +71,11 @@ ApWifiMac::GetTypeId (void)
                    MakeTimeAccessor (&ApWifiMac::GetBeaconInterval,
                                      &ApWifiMac::SetBeaconInterval),
                    MakeTimeChecker ())
+    .AddAttribute ("BSSColor",
+                   "BSS color of this AP",
+                   UintegerValue (0x0),
+                   MakeUintegerAccessor(&ApWifiMac::m_color),
+		   MakeUintegerChecker <uint8_t> ())
     .AddAttribute ("BeaconJitter",
                    "A uniform random variable to cause the initial beacon starting time (after simulation time 0) "
                    "to be distributed between 0 and the BeaconInterval.",
@@ -98,6 +119,12 @@ ApWifiMac::ApWifiMac ()
   m_enableBeaconGeneration = false;
 }
 
+Ptr<MacLow>
+ApWifiMac::GetMacLow(void) const
+{
+  return m_low;
+}
+
 ApWifiMac::~ApWifiMac ()
 {
   NS_LOG_FUNCTION (this);
@@ -161,6 +188,12 @@ ApWifiMac::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> stationMan
   NS_LOG_FUNCTION (this << stationManager);
   m_beaconDca->SetWifiRemoteStationManager (stationManager);
   RegularWifiMac::SetWifiRemoteStationManager (stationManager);
+  if (m_heSupported)
+    {
+      m_stationManager->SetupDcfManager(m_dcfManager);
+      //Lets setup the broadcast queue here for OFDMA access
+      SetupStationQueue(0,Mac48Address::GetBroadcast());
+    }
 }
 
 void
@@ -173,6 +206,7 @@ ApWifiMac::SetLinkUpCallback (Callback<void> linkUp)
   //the link is always up, so we immediately invoke the callback if
   //one is set
   linkUp ();
+  m_phy->SetColor(m_color);
 }
 
 void
@@ -293,7 +327,7 @@ ApWifiMac::ForwardDown (Ptr<const Packet> packet, Mac48Address from,
       hdr.SetTypeData ();
     }
 
-  if (m_htSupported || m_vhtSupported)
+  if (m_htSupported || m_vhtSupported || m_heSupported)
     {
       hdr.SetNoOrder ();
     }
@@ -307,7 +341,22 @@ ApWifiMac::ForwardDown (Ptr<const Packet> packet, Mac48Address from,
     {
       //Sanity check that the TID is valid
       NS_ASSERT (tid < 8);
-      m_edca[QosUtilsMapTidToAc (tid)]->Queue (packet, hdr);
+      if (m_heSupported)
+	{
+	  std::map<uint16_t, EdcaStaQueues>::iterator it = m_ofdmaMap.find(GetAid(to));
+	  if(it != m_ofdmaMap.end())
+	    {
+	      it->second[QosUtilsMapTidToAc (tid)]->Queue(packet, hdr);
+	    }
+	  else
+	    {
+	      NS_LOG_ERROR("No Queue exits for the station");
+	    }
+	}
+      else
+	{
+	  m_edca[QosUtilsMapTidToAc (tid)]->Queue (packet, hdr);
+	}
     }
   else
     {
@@ -351,7 +400,7 @@ ApWifiMac::GetSupportedRates (void) const
   //The standard says that the BSSMembershipSelectorSet
   //must have its MSB set to 1 (must be treated as a Basic Rate)
   //Also the standard mentioned that at least 1 element should be included in the SupportedRates the rest can be in the ExtendedSupportedRates
-  if (m_htSupported || m_vhtSupported)
+  if (m_htSupported || m_vhtSupported || m_heSupported)
     {
       for (uint32_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
         {
@@ -448,7 +497,7 @@ ApWifiMac::GetEdcaParameterSet (void) const
       edcaParameters.SetBeCWmax(edca->GetMaxCw ());
       edcaParameters.SetBeAifsn(edca->GetAifsn ());
       edcaParameters.SetBeTXOPLimit(txopLimit.GetMicroSeconds () / 32);
-      
+
       edca = m_edca.find (AC_BK)->second;
       txopLimit = edca->GetTxopLimit ();
       edcaParameters.SetBkAci(1);
@@ -526,7 +575,7 @@ ApWifiMac::SendProbeResp (Mac48Address to)
     {
       probe.SetEdcaParameterSet (GetEdcaParameterSet ());
     }
-  if (m_htSupported || m_vhtSupported)
+  if (m_htSupported || m_vhtSupported || m_heSupported)
     {
       probe.SetHtCapabilities (GetHtCapabilities ());
       probe.SetHtOperations (GetHtOperations ());
@@ -536,6 +585,10 @@ ApWifiMac::SendProbeResp (Mac48Address to)
     {
       probe.SetVhtCapabilities (GetVhtCapabilities ());
     }
+  if (m_heSupported)
+    {
+
+    }
   packet->AddHeader (probe);
 
   //The standard is not clear on the correct queue for management
@@ -545,6 +598,101 @@ ApWifiMac::SendProbeResp (Mac48Address to)
   m_dca->Queue (packet, hdr);
 }
 
+uint16_t
+ApWifiMac::GetAid(Mac48Address mac)
+{
+  uint16_t aid = 0;
+  std::map<Mac48Address, uint16_t>::iterator it;
+  it = m_aidMap.find(mac);
+  if(it != m_aidMap.end())
+    {
+      aid=it->second;
+    }
+  else
+    {
+
+     // aid = AllocateAid(mac); ///XXX: this is temp code till beacon exits
+     // SetupStationQueue(aid, mac); //XXX: as above
+     // NS_FATAL_ERROR("No map between Mac and Aid exists");
+    }
+  return aid;
+}
+
+uint16_t
+ApWifiMac::AllocateAid(Mac48Address mac)
+{
+  static uint16_t aid = 0;
+  std::map<Mac48Address, uint16_t>::iterator it;
+  it = m_aidMap.find(mac);
+  if(it != m_aidMap.end())
+    {
+      NS_LOG_UNCOND("Reassociated mac : " << mac << " Aid : " << it->second);
+      return it->second;
+    }
+  aid++;
+  m_aidMap.insert(std::make_pair(mac, aid));
+  SetupStationQueue(aid, mac);
+  NS_LOG_UNCOND("AllocateAid mac : " << mac << " Aid : " << aid);
+  return aid;
+}
+
+Ptr<EdcaTxopN>
+ApWifiMac::SetupStationEdcaQueue (uint16_t aid, Mac48Address mac, enum AcIndex ac)
+{
+  Ptr<EdcaTxopN> edca = CreateObject<EdcaTxopN> ();
+  edca->Initialize();
+  edca->SetTypeOfStation(AP);   // Just to denote that this edca resides in AP
+  edca->SetHeSupported(true);
+  edca->SetAid(mac, aid);
+  edca->SetLow (m_low);
+  edca->SetManager (m_dcfManager);
+  edca->SetTxMiddle (m_txMiddle);
+  edca->SetTxOkCallback (MakeCallback (&ApWifiMac::TxOk, this));
+  edca->SetTxFailedCallback (MakeCallback (&ApWifiMac::TxFailed, this));
+  edca->SetAccessCategory (ac);
+  edca->SetWifiRemoteStationManager(m_stationManager);
+  edca->CompleteConfig ();
+
+  Ptr<MsduStandardAggregator> msduAggregator = CreateObject<MsduStandardAggregator> ();
+  edca->SetMsduAggregator (msduAggregator);
+  Ptr<MpduStandardAggregator> mpduAggregator = CreateObject<MpduStandardAggregator> ();
+  edca->SetMpduAggregator (mpduAggregator);
+#if 0
+  if (ac == AC_VO)
+    {
+      edca->GetMsduAggregator ()->SetMaxAmsduSize (m_voMaxAmsduSize);
+      edca->GetMpduAggregator ()->SetMaxAmpduSize (m_voMaxAmpduSize);
+    }
+  else if (ac == AC_VI)
+    {
+      edca->GetMsduAggregator ()->SetMaxAmsduSize (m_viMaxAmsduSize);
+      edca->GetMpduAggregator ()->SetMaxAmpduSize (m_viMaxAmpduSize);
+    }
+  else if (ac == AC_BE)
+    {
+      edca->GetMsduAggregator ()->SetMaxAmsduSize (m_beMaxAmsduSize);
+      edca->GetMpduAggregator ()->SetMaxAmpduSize (m_beMaxAmpduSize);
+    }
+  else
+    {
+      edca->GetMsduAggregator ()->SetMaxAmsduSize (m_bkMaxAmsduSize);
+      edca->GetMpduAggregator ()->SetMaxAmpduSize (m_bkMaxAmpduSize);
+    }
+#endif
+  return edca;
+}
+
+void
+ApWifiMac::SetupStationQueue(uint16_t aid, Mac48Address mac)
+{
+  EdcaStaQueues edcaList;
+  edcaList.push_back(SetupStationEdcaQueue (aid, mac, AC_BE));
+  edcaList.push_back(SetupStationEdcaQueue (aid, mac, AC_BK));
+  edcaList.push_back(SetupStationEdcaQueue (aid, mac, AC_VI));
+  edcaList.push_back(SetupStationEdcaQueue (aid, mac, AC_VO));
+  m_ofdmaMap.insert(std::make_pair(aid, edcaList));
+}
+
 void
 ApWifiMac::SendAssocResp (Mac48Address to, bool success)
 {
@@ -561,8 +709,11 @@ ApWifiMac::SendAssocResp (Mac48Address to, bool success)
   StatusCode code;
   if (success)
     {
+      uint16_t aid = AllocateAid(to);
       code.SetSuccess ();
       m_staList.push_back (to);
+      assoc.SetAid(aid);
+      assoc.SetColor(m_color);
     }
   else
     {
@@ -589,6 +740,10 @@ ApWifiMac::SendAssocResp (Mac48Address to, bool success)
     {
       assoc.SetVhtCapabilities (GetVhtCapabilities ());
     }
+  if(m_heSupported)
+    {
+
+    }
   packet->AddHeader (assoc);
 
   //The standard is not clear on the correct queue for management
@@ -639,6 +794,10 @@ ApWifiMac::SendOneBeacon (void)
     {
       beacon.SetVhtCapabilities (GetVhtCapabilities ());
     }
+  if(m_heSupported)
+    {
+
+    }
   packet->AddHeader (beacon);
 
   //The beacon has it's own special queue, so we load it in there
@@ -867,6 +1026,10 @@ ApWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
                         }
                     }
                 }
+              if (m_heSupported)
+        	{
+
+        	}
               if (problem)
                 {
                   //One of the Basic Rate set mode is not
@@ -914,6 +1077,10 @@ ApWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
                             }
                         }
                     }
+                  if (m_heSupported)
+                    {
+
+                    }
                   m_stationManager->RecordWaitAssocTxOk (from);
                   if (!isHtStation)
                     {
@@ -957,9 +1124,78 @@ ApWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
               }
               return;
             }
+          if (hdr->IsAction ())
+            {
+              //There is currently only any reason for Management Action
+              //frames to be flying about if we are a QoS STA.
+              NS_ASSERT (m_qosSupported);
+
+              WifiActionHeader actionHdr;
+              packet->PeekHeader(actionHdr);
+
+              if (actionHdr.GetCategory () == WifiActionHeader::BLOCK_ACK)
+                {
+        	  if (actionHdr.GetAction ().blockAck == WifiActionHeader::BLOCK_ACK_ADDBA_RESPONSE)
+        	    {
+            	      packet->RemoveHeader (actionHdr);
+            	      MgtAddBaResponseHeader respHdr;
+            	      packet->RemoveHeader (respHdr);
+            	      //We've received an ADDBA Response. We assume that it
+            	      //indicates success after an ADDBA Request we have
+            	      //sent (we could, in principle, check this, but it
+            	      //seems a waste given the level of the current model)
+            	      //and act by locally establishing the agreement on
+            	      //the appropriate queue.
+            	      AcIndex ac = QosUtilsMapTidToAc (respHdr.GetTid ());
+            	      std::map<uint16_t, EdcaStaQueues>::iterator it = m_ofdmaMap.find(GetAid(hdr->GetAddr2 ()));
+            	     if (it != m_ofdmaMap.end())
+            	       {
+            	         it->second[ac]->GotAddBaResponse(&respHdr, from);
+            	         //This frame is now completely dealt with, so we're done.
+            	         return;
+            	       }
+            	     packet->AddHeader (respHdr);
+            	     packet->AddHeader (actionHdr);
+        	    }
+        	  else if (actionHdr.GetAction ().blockAck == WifiActionHeader::BLOCK_ACK_DELBA)
+        	    {
+            	      packet->RemoveHeader (actionHdr);
+                      MgtDelBaHeader delBaHdr;
+                      packet->RemoveHeader (delBaHdr);
+
+                      if (delBaHdr.IsByOriginator ())
+                        {
+                          //This DELBA frame was sent by the originator, so
+                          //this means that an ingoing established
+                          //agreement exists in MacLow and we need to
+                          //destroy it.
+                          m_low->DestroyBlockAckAgreement (from, delBaHdr.GetTid ());
+                        }
+                      else
+                        {
+                          //We must have been the originator. We need to
+                          //tell the correct queue that the agreement has
+                          //been torn down
+                          AcIndex ac = QosUtilsMapTidToAc (delBaHdr.GetTid ());
+                          std::map<uint16_t, EdcaStaQueues>::iterator it = m_ofdmaMap.find(GetAid(hdr->GetAddr2 ()));
+                          if (it != m_ofdmaMap.end())
+                            {
+                              it->second[ac]->GotDelBaFrame (&delBaHdr, from);
+                              //This frame is now completely dealt with, so we're done.
+                              return;
+                            }
+                        }
+                      packet->AddHeader (delBaHdr);
+            	      packet->AddHeader (actionHdr);
+        	    }
+                }
+              else
+        	{
+                  //packet->AddHeader(actionHdr);
+        	}
+            }
         }
     }
-
   //Invoke the receive handler of our parent class to deal with any
   //other frames. Specifically, this will handle Block Ack-related
   //Management Action frames.
@@ -992,6 +1228,73 @@ ApWifiMac::DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
     }
 }
 
+void
+ApWifiMac::SendAddBaResponse(const MgtAddBaRequestHeader *reqHdr,
+                                   Mac48Address originator)
+{
+  NS_LOG_FUNCTION (this);
+  WifiMacHeader hdr;
+  hdr.SetAction ();
+  hdr.SetAddr1 (originator);
+  hdr.SetAddr2 (GetAddress ());
+  hdr.SetAddr3 (GetAddress ());
+  hdr.SetDsNotFrom ();
+  hdr.SetDsNotTo ();
+
+  MgtAddBaResponseHeader respHdr;
+  StatusCode code;
+  code.SetSuccess ();
+  respHdr.SetStatusCode (code);
+  //Here a control about queues type?
+  respHdr.SetAmsduSupport (reqHdr->IsAmsduSupported ());
+
+  if (reqHdr->IsImmediateBlockAck ())
+    {
+      respHdr.SetImmediateBlockAck ();
+    }
+  else
+    {
+      respHdr.SetDelayedBlockAck ();
+    }
+  respHdr.SetTid (reqHdr->GetTid ());
+  //For now there's not no control about limit of reception. We
+  //assume that receiver has no limit on reception. However we assume
+  //that a receiver sets a bufferSize in order to satisfy next
+  //equation: (bufferSize + 1) % 16 = 0 So if a recipient is able to
+  //buffer a packet, it should be also able to buffer all possible
+  //packet's fragments. See section 7.3.1.14 in IEEE802.11e for more details.
+  respHdr.SetBufferSize (1023);
+  respHdr.SetTimeout (reqHdr->GetTimeout ());
+
+  WifiActionHeader actionHdr;
+  WifiActionHeader::ActionValue action;
+  action.blockAck = WifiActionHeader::BLOCK_ACK_ADDBA_RESPONSE;
+  actionHdr.SetAction (WifiActionHeader::BLOCK_ACK, action);
+
+  Ptr<Packet> packet = Create<Packet> ();
+  packet->AddHeader (respHdr);
+  packet->AddHeader (actionHdr);
+
+  //We need to notify our MacLow object as it will have to buffer all
+  //correctly received packets for this Block Ack session
+  m_low->CreateBlockAckAgreement (&respHdr, originator,
+                                  reqHdr->GetStartingSequence ());
+
+  //It is unclear which queue this frame should go into. For now we
+  //bung it into the queue corresponding to the TID for which we are
+  //establishing an agreement, and push it to the head.
+  AcIndex ac = QosUtilsMapTidToAc (respHdr.GetTid ());
+  std::map<uint16_t, EdcaStaQueues>::iterator it = m_ofdmaMap.find(GetAid(originator));
+  if (it != m_ofdmaMap.end())
+     {
+      it->second[ac]->PushFront (packet, hdr);
+     }
+  else
+    {
+      m_edca[ac]->PushFront (packet, hdr);
+    }
+}
+
 void
 ApWifiMac::DoInitialize (void)
 {
diff --git a/ns-3.26/src/wifi/model/ap-wifi-mac.h b/ns-3.26/src/wifi/model/ap-wifi-mac.h
index 7471e32..4fefedc 100644
--- a/ns-3.26/src/wifi/model/ap-wifi-mac.h
+++ b/ns-3.26/src/wifi/model/ap-wifi-mac.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef AP_WIFI_MAC_H
@@ -127,7 +140,7 @@ public:
    * \return the number of stream indices assigned by this model
    */
   int64_t AssignStreams (int64_t stream);
-
+  virtual Ptr<MacLow> GetMacLow (void) const;
 
 private:
   virtual void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
@@ -161,6 +174,15 @@ private:
    */
   virtual void DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
                                            const WifiMacHeader *hdr);
+  /**
+   * This method can be called to accept a received ADDBA Request. An
+   * ADDBA Response will be constructed and queued for transmission.
+   *
+   * \param reqHdr a pointer to the received ADDBA Request header.
+   * \param originator the MAC address of the originator.
+   */
+  virtual void SendAddBaResponse (const MgtAddBaRequestHeader *reqHdr,
+                                  Mac48Address originator);
   /**
    * Forward the packet down to DCF/EDCAF (enqueue the packet). This method
    * is a wrapper for ForwardDown with traffic id.
@@ -254,6 +276,15 @@ private:
    *         false otherwise
    */
   bool GetUseNonErpProtection (void) const;
+  /**
+   * Allocate Aid for the associated station
+   */
+  uint16_t AllocateAid(Mac48Address mac);
+  uint16_t GetAid(Mac48Address mac);
+
+  void SetupStationQueue(uint16_t aid, Mac48Address mac);
+  Ptr<EdcaTxopN> SetupStationEdcaQueue (uint16_t aid, Mac48Address mac, enum AcIndex ac);
+  typedef std::vector<Ptr<EdcaTxopN>> EdcaStaQueues;
 
   virtual void DoDispose (void);
   virtual void DoInitialize (void);
@@ -267,7 +298,10 @@ private:
   std::list<Mac48Address> m_staList;         //!< List of all stations currently associated to the AP
   std::list<Mac48Address> m_nonErpStations;  //!< List of all non-ERP stations currently associated to the AP
   std::list<Mac48Address> m_nonHtStations;   //!< List of all non-HT stations currently associated to the AP
+  std::map<Mac48Address, uint16_t> m_aidMap; //!< Map between AID and Mac address
+  std::map<uint16_t, EdcaStaQueues> m_ofdmaMap; //!< Map between AID and Mac address
   bool m_enableNonErpProtection;             //!< Flag whether protection mechanism is used or not when non-ERP STAs are present within the BSS
+  uint8_t   m_color;                         // Color code for BSS
 };
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/edca-txop-n.cc b/ns-3.26/src/wifi/model/edca-txop-n.cc
index 450a350..c0716e2 100644
--- a/ns-3.26/src/wifi/model/edca-txop-n.cc
+++ b/ns-3.26/src/wifi/model/edca-txop-n.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/log.h"
@@ -44,6 +57,8 @@ namespace ns3 {
 
 NS_LOG_COMPONENT_DEFINE ("EdcaTxopN");
 
+#define Min(a,b) ((a < b) ? a : b)
+
 class EdcaTxopN::Dcf : public DcfState
 {
 public:
@@ -78,6 +93,11 @@ private:
   {
     m_txop->NotifySleep ();
   }
+
+  virtual Time PeekFirstPacket(WifiMacHeader *hdr)
+  {
+    return m_txop->PeekFirstPacket(hdr);
+  }
   virtual void DoNotifyWakeUp (void)
   {
     m_txop->NotifyWakeUp ();
@@ -108,6 +128,10 @@ public:
   {
     m_txop->MissedCts ();
   }
+  virtual bool IsCtsReceived (void)
+  {
+    return m_txop->IsCtsReceived();
+  }
   virtual void GotAck (double snr, WifiMode txMode)
   {
     m_txop->GotAck (snr, txMode);
@@ -116,6 +140,10 @@ public:
   {
     m_txop->MissedAck ();
   }
+  virtual bool IsAckReceived (void)
+  {
+    return m_txop->IsAckReceived();
+  }
   virtual void GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address source, double rxSnr, WifiMode txMode, double dataSnr)
   {
     m_txop->GotBlockAck (blockAck, source, rxSnr, txMode, dataSnr);
@@ -144,7 +172,26 @@ public:
   {
     return m_txop->GetEdcaQueue ();
   }
-
+  virtual uint16_t GetAid (void)
+  {
+    return m_txop->GetAid();
+  }
+  virtual bool NeedsAccess (void)
+  {
+    return m_txop->NeedsAccess ();
+  }
+  virtual void NotifyAccessGranted (WifiTxVector txVector, Time duration)
+  {
+    m_txop->NotifyAccessGranted(txVector, duration);
+  }
+  virtual Time PeekFirstPacket(WifiMacHeader *hdr)
+  {
+    return m_txop->PeekFirstPacket(hdr);
+  }
+  virtual WifiTxVector GetDataTxVector (void)
+  {
+    return m_txop->GetDataTxVector ();
+  }
 private:
   EdcaTxopN *m_txop;
 };
@@ -226,6 +273,10 @@ public:
   {
     return m_txop->MapDestAddressForAggregation (hdr);
   }
+  virtual Time GetTxopLimit (void) const
+  {
+    return m_txop->GetTxopLimit ();
+  }
 
 private:
   EdcaTxopN *m_txop;
@@ -282,6 +333,11 @@ EdcaTxopN::EdcaTxopN ()
   m_baManager->SetMaxPacketDelay (m_queue->GetMaxDelay ());
   m_baManager->SetTxOkCallback (MakeCallback (&EdcaTxopN::BaTxOk, this));
   m_baManager->SetTxFailedCallback (MakeCallback (&EdcaTxopN::BaTxFailed, this));
+  m_blockAckInactivityTimeout = 0;
+  m_isHeCsmaCaActive = false;
+  m_isHeSupported = false;
+  m_isCtsReceived = false;
+  m_isAckReceived = false;
 }
 
 EdcaTxopN::~EdcaTxopN ()
@@ -289,6 +345,12 @@ EdcaTxopN::~EdcaTxopN ()
   NS_LOG_FUNCTION (this);
 }
 
+AcIndex
+EdcaTxopN::GetAc()
+{
+  return m_ac;
+}
+
 void
 EdcaTxopN::DoDispose (void)
 {
@@ -365,6 +427,25 @@ EdcaTxopN::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> remoteMana
   NS_LOG_FUNCTION (this << remoteManager);
   m_stationManager = remoteManager;
   m_baManager->SetWifiRemoteStationManager (m_stationManager);
+  if (m_isHeSupported)
+    {
+      m_stationManager->SetupAidQueue(m_aid, m_mac, m_transmissionListener, m_ac);
+    }
+}
+
+void
+EdcaTxopN::SetAid(Mac48Address mac, uint16_t aid)
+{
+  NS_LOG_FUNCTION (this << mac << aid);
+  m_mac = mac;
+  m_aid = aid;
+}
+
+void
+EdcaTxopN::SetHeSupported (bool enable)
+{
+  NS_LOG_FUNCTION (this << enable);
+  m_isHeSupported = enable;
 }
 
 void
@@ -388,6 +469,19 @@ EdcaTxopN::GetEdcaQueue () const
   return m_queue;
 }
 
+uint8_t
+EdcaTxopN::GetEdcaQueueSize () const
+{
+  return Min(254, round(m_queue->GetBytes () / 256));
+}
+
+uint8_t
+EdcaTxopN::GetEdcaQueueSize (AcIndex &ac)
+{
+  ac = m_ac;
+  return Min(254, round(m_queue->GetBytes () / 256));
+}
+
 void
 EdcaTxopN::SetMinCw (uint32_t minCw)
 {
@@ -493,11 +587,82 @@ EdcaTxopN::RemoveRetransmitPacket (uint8_t tid, Mac48Address recipient, uint16_t
   m_baManager->RemovePacket (tid, recipient, seqnumber);
 }
 
+WifiTxVector
+EdcaTxopN::GetDataTxVector (void)
+{
+   return m_currentTxVector;
+}
+
+void
+EdcaTxopN::NotifyAccessGranted (WifiTxVector txVector, Time duration)
+{
+  m_currentTxVector = txVector;
+  //Set max AMPDU length
+  if (duration > MicroSeconds (5484))
+    {
+      duration = MicroSeconds (5484);
+    }
+  //Set SI dynamically
+  uint32_t msec = duration.GetMicroSeconds ()/32;
+  msec *= 32;
+  m_startTxop = Simulator::Now ();
+  SetTxopLimit(MicroSeconds(msec));
+  //NS_LOG_UNCOND("Set txop to : " << GetTxopRemaining ());
+  uint32_t maxAmpduLength = txVector.GetMode().GetDataRate(txVector)*duration.GetSeconds()/8;
+  GetMpduAggregator ()->SetMaxAmpduSize(maxAmpduLength);
+  NotifyAccessGranted ();
+}
+
+Time
+EdcaTxopN::PeekFirstPacket(WifiMacHeader *hdr)
+{
+    Time timestamp = Seconds(0.0);
+    if(!m_queue->IsEmpty ()) {
+        if (m_queue->PeekFirstAvailable (hdr, timestamp, m_qosBlockedDestinations)) {
+        }
+    }
+    return timestamp;
+}
+
+uint32_t
+EdcaTxopN::GetQueueInfoSf (uint8_t &ac)
+{
+  uint32_t bytes = 0, sfBytes = 0;
+
+  if(m_queue->IsEmpty ()) {
+      sfBytes = 0;
+  }
+  bytes = m_queue->GetBytes(); 
+
+  if(bytes < 16) {
+     sfBytes = 0;
+  } else if(bytes < 128) {
+     sfBytes = 1;
+  } else if(bytes < 2048) {
+     sfBytes = 2;
+  } else if(bytes < 16384) {
+     sfBytes = 3;
+  }
+  ac = m_ac;
+
+#if 0 
+  // Only for testing.
+  if(m_ac == 0)
+     sfBytes = 2;
+  else if(m_ac == 2)
+     sfBytes = 3;
+#endif
+
+  return sfBytes;
+}
+
 void
 EdcaTxopN::NotifyAccessGranted (void)
 {
   NS_LOG_FUNCTION (this);
   m_isAccessRequestedForRts = false;
+  m_isAckReceived = false;
+  m_isCtsReceived = false;
   if (m_currentPacket == 0)
     {
       if (m_queue->IsEmpty () && !m_baManager->HasPackets ())
@@ -514,17 +679,30 @@ EdcaTxopN::NotifyAccessGranted (void)
       m_currentPacket = m_baManager->GetNextPacket (m_currentHdr);
       if (m_currentPacket == 0)
         {
-          if (m_queue->PeekFirstAvailable (&m_currentHdr, m_currentPacketTimestamp, m_qosBlockedDestinations) == 0)
+	  Ptr<const Packet> packet = m_queue->PeekFirstAvailable (&m_currentHdr, m_currentPacketTimestamp, m_qosBlockedDestinations);
+          if (packet == 0)
             {
               NS_LOG_DEBUG ("no available packets in the queue");
               return;
             }
+          if (m_isHeSupported && m_isHeCsmaCaActive == false)
+            {
+              //Check if enough txop is there to tx this packet
+              Time needed = Low ()->GetPhy()->CalculateTxDuration (packet->GetSize(), m_currentTxVector, WIFI_PREAMBLE_HE, Low ()->GetPhy()->GetFrequency ());
+              if (GetTxopRemaining () < needed)
+                {
+                  NS_LOG_UNCOND("Not enough room in txop to send data Needed: " << needed << " Available : " << GetTxopRemaining ());
+                  return;
+                }
+            }
+#if 1
           if (m_currentHdr.IsQosData () && !m_currentHdr.GetAddr1 ().IsBroadcast ()
               && !m_baManager->ExistsAgreement (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ())
               && SetupBlockAckIfNeeded ())
             {
               return;
             }
+#endif
           m_currentPacket = m_queue->DequeueFirstAvailable (&m_currentHdr, m_currentPacketTimestamp, m_qosBlockedDestinations);
           NS_ASSERT (m_currentPacket != 0);
 
@@ -650,6 +828,7 @@ EdcaTxopN::NotifyAccessGranted (void)
             }
         }
     }
+  m_isHeCsmaCaActive = false;
 }
 
 void EdcaTxopN::NotifyInternalCollision (void)
@@ -741,6 +920,16 @@ EdcaTxopN::GotCts (double snr, WifiMode txMode)
 {
   NS_LOG_FUNCTION (this << snr << txMode);
   NS_LOG_DEBUG ("got cts");
+  if (m_isHeSupported)
+    {
+      m_isCtsReceived = true;
+    }
+}
+
+bool
+EdcaTxopN::IsCtsReceived () const
+{
+  return m_isCtsReceived;
 }
 
 uint8_t
@@ -901,9 +1090,21 @@ void
 EdcaTxopN::Queue (Ptr<const Packet> packet, const WifiMacHeader &hdr)
 {
   NS_LOG_FUNCTION (this << packet << &hdr);
-  m_stationManager->PrepareForQueue (hdr.GetAddr1 (), &hdr, packet);
+  if (m_isHeCsmaCaActive == false && m_isHeSupported == false)
+    {
+      m_stationManager->PrepareForQueue (hdr.GetAddr1 (), &hdr, packet);
+    }
   m_queue->Enqueue (packet, hdr);
-  StartAccessIfNeeded ();
+  if(m_isHeSupported == true && m_typeOfStation == STA)
+    {
+  //    m_isHeCsmaCaActive = true;
+ //     Simulator::Schedule (MicroSeconds(2000), &EdcaTxopN::StartAccessIfNeeded, this);
+//      StartAccessIfNeeded ();
+    }
+  else
+    {
+      StartAccessIfNeeded ();
+    }
 }
 
 void
@@ -954,6 +1155,13 @@ EdcaTxopN::GotAck (double snr, WifiMode txMode)
     {
       NS_LOG_DEBUG ("got ack. tx not done, size=" << m_currentPacket->GetSize ());
     }
+  m_isAckReceived = true;
+}
+
+bool
+EdcaTxopN::IsAckReceived () const
+{
+  return m_isAckReceived;
 }
 
 void
@@ -1112,6 +1320,11 @@ void
 EdcaTxopN::RestartAccessIfNeeded (void)
 {
   NS_LOG_FUNCTION (this);
+  if (m_isHeCsmaCaActive == false && m_isHeSupported)
+    {
+      //OFDMA does not require medium access at this point. It will be granted by OFDMA/RRM manager
+      return;
+    }
   if ((m_currentPacket != 0
        || !m_queue->IsEmpty () || m_baManager->HasPackets ())
       && !m_dcf->IsAccessRequested ())
@@ -1147,6 +1360,11 @@ void
 EdcaTxopN::StartAccessIfNeeded (void)
 {
   NS_LOG_FUNCTION (this);
+  if (m_isHeCsmaCaActive == false && m_isHeSupported)
+    {
+      //OFDMA does not require medium access at this point. It will be granted by OFDMA/RRM manager
+      return;
+    }
   if (m_currentPacket == 0
       && (!m_queue->IsEmpty () || m_baManager->HasPackets ())
       && !m_dcf->IsAccessRequested ())
@@ -1232,6 +1450,7 @@ EdcaTxopN::StartNextFragment (void)
   NS_LOG_FUNCTION (this);
   NS_LOG_DEBUG ("start next packet fragment");
   /* this callback is used only for fragments. */
+  m_isAckReceived = false;
   NextFragment ();
   WifiMacHeader hdr;
   Ptr<Packet> fragment = GetFragmentPacket (&hdr);
@@ -1256,7 +1475,7 @@ EdcaTxopN::StartNext (void)
   NS_LOG_FUNCTION (this);
   WifiMacHeader hdr;
   Time tstamp;
-
+  m_isAckReceived = false;
   Ptr<const Packet> peekedPacket = m_queue->PeekByTidAndAddress (&hdr,
                                                                  m_currentHdr.GetQosTid (),
                                                                  WifiMacHeader::ADDR1,
@@ -1295,10 +1514,31 @@ EdcaTxopN::StartNext (void)
                                                          m_currentHdr.GetQosTid (),
                                                          WifiMacHeader::ADDR1,
                                                          m_currentHdr.GetAddr1 ());
+      uint16_t sequence = m_txMiddle->GetNextSequenceNumberfor (&m_currentHdr);
+      m_currentHdr.SetSequenceNumber (sequence);
       Low ()->StartTransmission (m_currentPacket, &m_currentHdr, params, m_transmissionListener);
     }
 }
 
+Ptr<const Packet>
+EdcaTxopN::GetCurrentPktInQueue(WifiMacHeader *head)
+{
+  Ptr<const Packet> currentPacket;
+
+  if(!m_queue->IsEmpty()) {
+       currentPacket = m_queue->Peek(&m_currentHdr);
+       *head = m_currentHdr;
+       return currentPacket;
+  }
+  return NULL;
+}
+
+uint16_t
+EdcaTxopN::GetAid (void) const
+{
+  return m_aid;
+}
+
 Time
 EdcaTxopN::GetTxopRemaining (void)
 {
@@ -1381,6 +1621,7 @@ bool
 EdcaTxopN::NeedFragmentation (void) const
 {
   NS_LOG_FUNCTION (this);
+  return false;
   if (m_stationManager->HasVhtSupported ()
       || GetAmpduExist (m_currentHdr.GetAddr1 ())
       || (m_stationManager->HasHtSupported ()
@@ -1540,6 +1781,11 @@ EdcaTxopN::GotDelBaFrame (const MgtDelBaHeader *delBaHdr, Mac48Address recipient
 {
   NS_LOG_FUNCTION (this << delBaHdr << recipient);
   NS_LOG_DEBUG ("received DELBA frame from=" << recipient);
+  if (m_baManager->HasBar(m_currentBar))
+    {
+       //There may be pending BAR, lets not tear down BA
+      return;
+    }
   m_baManager->TearDownBlockAck (recipient, delBaHdr->GetTid ());
 }
 
@@ -1548,6 +1794,7 @@ EdcaTxopN::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address rec
 {
   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << txMode.GetUniqueName () << dataSnr);
   NS_LOG_DEBUG ("got block ack from=" << recipient);
+
   m_baManager->NotifyGotBlockAck (blockAck, recipient, rxSnr, txMode, dataSnr);
   if (!m_txOkCallback.IsNull ())
     {
@@ -1559,6 +1806,7 @@ EdcaTxopN::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address rec
   m_backoffTrace = m_rng->GetNext (0, m_dcf->GetCw ());
   m_dcf->StartBackoffNow (m_backoffTrace);
   RestartAccessIfNeeded ();
+  m_isAckReceived = true;
 }
 
 void
@@ -1636,7 +1884,8 @@ EdcaTxopN::SetupBlockAckIfNeeded ()
 
   uint32_t packets = m_queue->GetNPacketsByTidAndAddress (tid, WifiMacHeader::ADDR1, recipient);
 
-  if ((m_blockAckThreshold > 0 && packets >= m_blockAckThreshold) || (packets > 1 && m_mpduAggregator != 0) || m_stationManager->HasVhtSupported ())
+  if ((m_blockAckThreshold > 0 && packets >= m_blockAckThreshold) || (packets > 1 && m_mpduAggregator != 0) || m_stationManager->HasVhtSupported ()
+      || m_stationManager->HasHeSupported ())
     {
       /* Block ack setup */
       uint16_t startingSequence = m_txMiddle->GetNextSeqNumberByTidAndAddress (tid, recipient);
@@ -1695,7 +1944,7 @@ EdcaTxopN::CompleteConfig (void)
 {
   NS_LOG_FUNCTION (this);
   m_baManager->SetTxMiddle (m_txMiddle);
-  m_low->RegisterBlockAckListenerForAc (m_ac, m_blockAckListener);
+  m_low->RegisterBlockAckListenerForAc (m_ac, m_blockAckListener, m_mac);
   m_baManager->SetBlockAckInactivityCallback (MakeCallback (&EdcaTxopN::SendDelbaFrame, this));
 }
 
@@ -1712,6 +1961,7 @@ EdcaTxopN::SetBlockAckInactivityTimeout (uint16_t timeout)
 {
   NS_LOG_FUNCTION (this << timeout);
   m_blockAckInactivityTimeout = timeout;
+//  m_blockAckInactivityTimeout = 10000; 
 }
 
 uint8_t
diff --git a/ns-3.26/src/wifi/model/edca-txop-n.h b/ns-3.26/src/wifi/model/edca-txop-n.h
index fc265b9..10a2377 100644
--- a/ns-3.26/src/wifi/model/edca-txop-n.h
+++ b/ns-3.26/src/wifi/model/edca-txop-n.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,7 +19,20 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
+
 #ifndef EDCA_TXOP_N_H
 #define EDCA_TXOP_N_H
 
@@ -136,6 +150,11 @@ public:
    * \param remoteManager WifiRemoteStationManager
    */
   void SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> remoteManager);
+  /**
+   * Enable or disable HE support.
+   * \param enable enable or disable HE  support
+   */
+  void SetHeSupported (bool enable);
   /**
    * Set type of station with the given type.
    *
@@ -154,6 +173,13 @@ public:
    * \return WifiMacQueue
    */
   Ptr<WifiMacQueue > GetEdcaQueue () const;
+  /**
+   * Return the packet queue associated with this EdcaTxopN.
+   *
+   * \return WifiMacQueue
+   */
+  uint8_t GetEdcaQueueSize () const;
+  uint8_t GetEdcaQueueSize (AcIndex &ac);
 
   virtual void SetMinCw (uint32_t minCw);
   virtual void SetMaxCw (uint32_t maxCw);
@@ -220,6 +246,20 @@ public:
    * Notify the EDCAF that access has been granted.
    */
   void NotifyAccessGranted (void);
+  /**
+   * Notify the EDCAF that access has been granted with TxVector to be used.
+   */
+  void NotifyAccessGranted (WifiTxVector txVector, Time duration);
+
+  /* Return queue Scaling factor for that edca */
+  uint32_t GetQueueInfoSf (uint8_t &ac);
+
+  Time PeekFirstPacket(WifiMacHeader *hdr);
+
+  /**
+   * Returns the data vector to be used for tranmission
+   */
+  WifiTxVector GetDataTxVector (void);
   /**
    * Notify the EDCAF that internal collision has occurred.
    */
@@ -253,6 +293,12 @@ public:
    * Event handler when a CTS timeout has occurred.
    */
   void MissedCts (void);
+  /**
+   * Handler to check if CTS is received
+   *
+   * \return ture if CTS has been received
+   */
+  bool IsCtsReceived (void) const;
   /**
    * Event handler when an ACK is received.
    *
@@ -280,6 +326,12 @@ public:
    * Event handler when an ACK is missed.
    */
   void MissedAck (void);
+  /**
+   * Handler to check if ACK is received
+   *
+   * \return ture if CTS has been received
+   */
+  bool IsAckReceived (void) const;
   /**
    * Start transmission for the next fragment.
    * This is called for fragment only.
@@ -289,6 +341,18 @@ public:
    * Start transmission for the next packet if allowed by the TxopLimit.
    */
   void StartNext (void);
+  /**
+   * Peak the next packet from the queue
+   */
+  Ptr<const Packet>GetCurrentPktInQueue(WifiMacHeader *head);
+  /**
+   * Set Aid of the station this EdcaTxop connected to
+   */
+  void SetAid (Mac48Address mac, uint16_t aid);
+  /**
+   * Get Aid of the station this EdcaTxop is associated to
+   */
+  uint16_t GetAid (void) const;
   /**
    * Cancel the transmission.
    */
@@ -477,6 +541,7 @@ public:
    * \return the number of stream indices assigned by this model
    */
   int64_t AssignStreams (int64_t stream);
+  AcIndex GetAc(void);
 
 
 private:
@@ -594,6 +659,13 @@ private:
   bool m_isAccessRequestedForRts;
   TracedValue<uint32_t> m_backoffTrace;
   TracedValue<uint32_t> m_cwTrace;
+  bool  m_isHeSupported;
+  bool  m_isHeCsmaCaActive;
+  bool  m_isCtsReceived;
+  bool  m_isAckReceived;
+  WifiTxVector m_currentTxVector;
+  Mac48Address m_mac;
+  uint16_t     m_aid;
 };
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/interference-helper.cc b/ns-3.26/src/wifi/model/interference-helper.cc
index 421f33d..76ea526 100644
--- a/ns-3.26/src/wifi/model/interference-helper.cc
+++ b/ns-3.26/src/wifi/model/interference-helper.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "interference-helper.h"
@@ -104,9 +117,10 @@ InterferenceHelper::Event::GetPreambleType (void) const
  *       short period of time.
  ****************************************************************/
 
-InterferenceHelper::NiChange::NiChange (Time time, double delta)
+InterferenceHelper::NiChange::NiChange (Time time, double delta, uint8_t ru)
   : m_time (time),
-    m_delta (delta)
+    m_delta (delta),
+    m_ru (ru)
 {
 }
 
@@ -122,6 +136,12 @@ InterferenceHelper::NiChange::GetDelta (void) const
   return m_delta;
 }
 
+double
+InterferenceHelper::NiChange::GetRu (void) const
+{
+  return m_ru;
+}
+
 bool
 InterferenceHelper::NiChange::operator < (const InterferenceHelper::NiChange& o) const
 {
@@ -225,19 +245,21 @@ InterferenceHelper::AppendEvent (Ptr<InterferenceHelper::Event> event)
   if (!m_rxing)
     {
       NiChanges::iterator nowIterator = GetPosition (now);
+      //Disable floor noise for now.
+#if 0
       for (NiChanges::iterator i = m_niChanges.begin (); i != nowIterator; i++)
         {
           m_firstPower += i->GetDelta ();
         }
+#endif
       m_niChanges.erase (m_niChanges.begin (), nowIterator);
-      m_niChanges.insert (m_niChanges.begin (), NiChange (event->GetStartTime (), event->GetRxPowerW ()));
+      m_niChanges.insert (m_niChanges.begin (), NiChange (event->GetStartTime (), event->GetRxPowerW (), event->GetTxVector().GetRu()));
     }
   else
     {
-      AddNiChangeEvent (NiChange (event->GetStartTime (), event->GetRxPowerW ()));
+      AddNiChangeEvent (NiChange (event->GetStartTime (), event->GetRxPowerW (), event->GetTxVector().GetRu()));
     }
-  AddNiChangeEvent (NiChange (event->GetEndTime (), -event->GetRxPowerW ()));
-
+  AddNiChangeEvent (NiChange (event->GetEndTime (), -event->GetRxPowerW (), event->GetTxVector().GetRu()));
 }
 
 
@@ -263,14 +285,23 @@ InterferenceHelper::CalculateNoiseInterferenceW (Ptr<InterferenceHelper::Event>
   NS_ASSERT (m_rxing);
   for (NiChanges::const_iterator i = m_niChanges.begin () + 1; i != m_niChanges.end (); i++)
     {
+      if (i->GetTime () <= event->GetStartTime () )
+	{
+	  //Consider only those events which occured after rxing started on the RU
+	  continue;
+	}
       if ((event->GetEndTime () == i->GetTime ()) && event->GetRxPowerW () == -i->GetDelta ())
         {
           break;
         }
-      ni->push_back (*i);
+      if (i->GetRu() == 0xff || event->GetTxVector().GetRu() == i->GetRu())
+	{
+	  // noise is considered only for the same RU events as that of current event
+	  ni->push_back (*i);
+	}
     }
-  ni->insert (ni->begin (), NiChange (event->GetStartTime (), noiseInterference));
-  ni->push_back (NiChange (event->GetEndTime (), 0));
+  ni->insert (ni->begin (), NiChange (event->GetStartTime (), noiseInterference, event->GetTxVector().GetRu()));
+  ni->push_back (NiChange (event->GetEndTime (), 0, event->GetTxVector().GetRu()));
   return noiseInterference;
 }
 
@@ -844,7 +875,7 @@ InterferenceHelper::EraseEvents (void)
 InterferenceHelper::NiChanges::iterator
 InterferenceHelper::GetPosition (Time moment)
 {
-  return std::upper_bound (m_niChanges.begin (), m_niChanges.end (), NiChange (moment, 0));
+  return std::upper_bound (m_niChanges.begin (), m_niChanges.end (), NiChange (moment, 0, 0));
 }
 
 void
@@ -865,6 +896,7 @@ InterferenceHelper::NotifyRxEnd ()
 {
   NS_LOG_FUNCTION (this);
   m_rxing = false;
+  EraseEvents();
 }
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/interference-helper.h b/ns-3.26/src/wifi/model/interference-helper.h
index ad1bd5a..20403d8 100644
--- a/ns-3.26/src/wifi/model/interference-helper.h
+++ b/ns-3.26/src/wifi/model/interference-helper.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef INTERFERENCE_HELPER_H
@@ -234,7 +247,7 @@ public:
      * \param time time of the event
      * \param delta the power
      */
-    NiChange (Time time, double delta);
+    NiChange (Time time, double delta, uint8_t ru);
     /**
      * Return the event time.
      *
@@ -247,6 +260,12 @@ public:
      * \return the power
      */
     double GetDelta (void) const;
+    /**
+     * Return the power
+     *
+     * \return the power
+     */
+    double GetRu (void) const;
     /**
      * Compare the event time of two NiChange objects (a < o).
      *
@@ -259,6 +278,7 @@ public:
 private:
     Time m_time;
     double m_delta;
+    uint8_t m_ru;
   };
   /**
    * typedef for a vector of NiChanges
@@ -317,6 +337,7 @@ private:
    * \return the error rate of the packet
    */
   double CalculatePlcpPayloadPer (Ptr<const Event> event, NiChanges *ni) const;
+  double CalculateHEPlcpPayloadPer (Ptr<const InterferenceHelper::Event> event, NiChanges *ni, double noiseInterferenceW);
   /**
    * Calculate the error rate of the plcp header. The plcp header can be divided into
    * multiple chunks (e.g. due to interference from other transmissions).
diff --git a/ns-3.26/src/wifi/model/mac-low.cc b/ns-3.26/src/wifi/model/mac-low.cc
index e80c37f..1464fa9 100644
--- a/ns-3.26/src/wifi/model/mac-low.cc
+++ b/ns-3.26/src/wifi/model/mac-low.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2005,2006 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/assert.h"
@@ -37,6 +50,7 @@
 #include "yans-wifi-phy.h"
 #include "ampdu-tag.h"
 #include "wifi-mac-queue.h"
+#include "ns3/he-bitmap.h"
 
 #undef NS_LOG_APPEND_CONTEXT
 #define NS_LOG_APPEND_CONTEXT std::clog << "[mac=" << m_self << "] "
@@ -59,6 +73,57 @@ void
 MacLowTransmissionListener::MissedBlockAck (uint32_t nMpdus)
 {
 }
+bool
+MacLowTransmissionListener::IsAckReceived (void)
+{
+  return false;
+}
+bool
+MacLowTransmissionListener::IsCtsReceived (void)
+{
+  return false;
+}
+Ptr<Packet>
+MacLowTransmissionListener::StartNext (WifiMacHeader *hdr)
+{
+  hdr = 0;
+  return 0;
+}
+uint16_t
+MacLowTransmissionListener::GetAid (void)
+{
+  return 0;
+}
+Ptr<const Packet>
+MacLowTransmissionListener::GetCurrentPktInQueue(WifiMacHeader *hdr)
+{
+  hdr = 0;
+  return 0;
+}
+Ptr<WifiMacQueue>
+MacLowTransmissionListener::GetQueue (void)
+{
+  return 0;
+}
+bool
+MacLowTransmissionListener::NeedsAccess (void)
+{
+   return false;
+}
+void
+MacLowTransmissionListener::NotifyAccessGranted (WifiTxVector txVector, Time duration)
+{
+}
+Time
+MacLowTransmissionListener::PeekFirstPacket(WifiMacHeader *hdr)
+{
+   return Seconds(0.0);
+}
+WifiTxVector
+MacLowTransmissionListener::GetDataTxVector (void)
+{
+  return WifiTxVector();
+}
 
 MacLowDcfListener::MacLowDcfListener ()
 {
@@ -132,6 +197,11 @@ MacLowAggregationCapableTransmissionListener::GetDestAddressForAggregation (cons
 {
   return 0;
 }
+Time
+MacLowAggregationCapableTransmissionListener::GetTxopLimit (void) const
+{
+  return MilliSeconds(10);
+}
 
 MacLowTransmissionParameters::MacLowTransmissionParameters ()
   : m_nextSize (0),
@@ -378,6 +448,31 @@ MacLow::MacLow ()
   m_ampdu = false;
   m_sentMpdus = 0;
   m_aggregateQueue = CreateObject<WifiMacQueue> ();
+  m_aid = 0;
+  m_isHeMuMpduStarted = false;
+  m_isHeMuTbMpduStarted = false;
+  m_currentSI = Seconds(0);
+  m_highLoadingAxResourceDL = 0;
+  m_usedAxResourceDL = 0;
+  m_totalAxResourceDL = 0;
+}
+
+double
+MacLow::GetHighLoadingAxResourceDL()
+{
+  return m_highLoadingAxResourceDL;
+}
+
+double
+MacLow::GetUsedAxResourceDL()
+{
+  return m_usedAxResourceDL;
+}
+
+double
+MacLow::GetTotalAxResourceDL()
+{
+  return m_totalAxResourceDL;
 }
 
 MacLow::~MacLow ()
@@ -551,6 +646,12 @@ MacLow::SetAddress (Mac48Address ad)
   m_self = ad;
 }
 
+void
+MacLow::SetAid (uint16_t aid)
+{
+  m_aid = aid;
+}
+
 void
 MacLow::SetAckTimeout (Time ackTimeout)
 {
@@ -629,6 +730,12 @@ MacLow::GetAddress (void) const
   return m_self;
 }
 
+uint16_t
+MacLow::GetAid (void) const
+{
+  return m_aid;
+}
+
 Time
 MacLow::GetAckTimeout (void) const
 {
@@ -638,12 +745,28 @@ MacLow::GetAckTimeout (void) const
 Time
 MacLow::GetBasicBlockAckTimeout () const
 {
+  if (m_stationManager->HasHeSupported() && m_isHeMuTbMpduStarted)
+    {
+      Time duration = Seconds(0);
+      duration += GetSifs ();
+      WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
+      duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
+      return duration;
+    }
   return m_basicBlockAckTimeout;
 }
 
 Time
 MacLow::GetCompressedBlockAckTimeout () const
 {
+  if (m_stationManager->HasHeSupported() && m_isHeMuTbMpduStarted)
+    {
+      Time duration = GetSifs ();
+      duration += GetSifs ();
+      WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
+      duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
+      return duration;
+    }
   return m_compressedBlockAckTimeout;
 }
 
@@ -695,6 +818,86 @@ MacLow::SetRxCallback (Callback<void, Ptr<Packet>, const WifiMacHeader *> callba
   m_rxCallback = callback;
 }
 
+void
+MacLow::SetOfdmaFecthCallback (Callback<void, WifiTxVector, Time> callback)
+{
+  m_ofdmaFetchCallback = callback;
+}
+
+void
+MacLow::SetOfdmaFecthBsrCallback (Callback<void, Time , WifiTxVector , double , Mac48Address> callback)
+{
+  m_ofdmaFetchBsrCallback = callback;
+}
+
+void
+MacLow::SetOfdmaHeTransmit (bool enable)
+{
+  NS_LOG_FUNCTION(this);
+  m_currentSI =  Seconds(0);
+  m_isHeMuMpduStarted = enable;
+  m_heStations.clear ();
+}
+
+void
+MacLow::EnqueueToHeMpduList (Ptr<const Packet> packet,
+	                     const WifiMacHeader* hdr,
+			     MacLowTransmissionParameters params,
+			     MacLowTransmissionListener *listener)
+{
+  /**
+   * HE packets follow a different approach Trigger/MURTS-DATA-ACK and
+   * the data may be destined to more than one clients at the same time
+   * We just save the packets here and use it appropiately in the state machine.
+   */
+
+  HeMpduItem item;
+  item.hdr = *hdr;
+  item.listener = listener;
+  item.packet = packet->Copy();
+  SocketPriorityTag priorityTag;
+  item.packet->RemovePacketTag (priorityTag);
+  item.params = params;
+  item.txVector = GetDataTxVector(item.packet, &item.hdr);
+
+  //Perform MPDU aggregation if possible
+  uint32_t size, actualSize;
+  WifiMacTrailer fcs;
+  size = packet->GetSize () + hdr->GetSize () + fcs.GetSerializedSize ();
+  item.aggQueue = CreateObject<WifiMacQueue> ();
+  Ptr<Packet> p = AggregateToAmpdu (packet, *hdr, item.aggQueue);
+  //Ptr<Packet> p = packet->Copy();
+  actualSize = p->GetSize ();
+  if (actualSize > size)
+    {
+      item.packet = p->Copy();
+      item.isAmpdu = true;
+      AmpduTag ampdu;
+      item.packet->PeekPacketTag (ampdu);
+      if (ampdu.GetRemainingNbOfMpdus () > 0)
+        {
+	  item.params.EnableCompressedBlockAck ();
+        }
+      else if (item.hdr.IsQosData ())
+        {
+          //VHT single MPDUs are followed by normal ACKs
+	  item.params.EnableAck ();
+        }
+    }
+  else
+    {
+      item.isAmpdu = false;
+    }
+  m_heStations.insert(std::make_pair(hdr->GetAddr1(),item));
+}
+
+void
+MacLow::SetOfdmaHeTbTransmit (bool enable)
+{
+  m_isHeMuTbMpduStarted = enable;
+  m_ampdu = false;
+}
+
 void
 MacLow::RegisterDcfListener (MacLowDcfListener *listener)
 {
@@ -707,7 +910,7 @@ MacLow::IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
   uint32_t size, actualSize;
   WifiMacTrailer fcs;
   size = packet->GetSize () + hdr.GetSize () + fcs.GetSerializedSize ();
-  Ptr<Packet> p = AggregateToAmpdu (packet, hdr);
+  Ptr<Packet> p = AggregateToAmpdu (packet, hdr, m_aggregateQueue);
   actualSize = p->GetSize ();
   if (actualSize > size)
     {
@@ -741,16 +944,20 @@ MacLow::StartTransmission (Ptr<const Packet> packet,
    * QapScheduler has taken access to the channel from
    * one of the Edca of the QAP.
    */
+  CancelAllEvents ();
+  m_listener = listener;
+  if (m_isHeMuMpduStarted)
+    {
+      EnqueueToHeMpduList(packet, hdr, params, listener);
+      return;
+    }
   m_currentPacket = packet->Copy ();
   // remove the priority tag attached, if any
   SocketPriorityTag priorityTag;
   m_currentPacket->RemovePacketTag (priorityTag);
   m_currentHdr = *hdr;
-  CancelAllEvents ();
-  m_listener = listener;
   m_txParams = params;
   m_currentTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
-
   if (!m_currentHdr.IsQosData () && !m_currentHdr.IsBlockAck () && !m_currentHdr.IsBlockAckReq ())
     {
       //This is mainly encountered when a higher priority control frame (such as beacons)
@@ -793,6 +1000,41 @@ MacLow::StartTransmission (Ptr<const Packet> packet,
             }
         }
     }
+  if (m_isHeMuTbMpduStarted)
+    {
+      Time txDuration, padDuration;
+      uint32_t padSize;
+      if (m_ampdu)
+	{
+	  txDuration = m_phy->CalculateTxDuration (m_currentPacket->GetSize(), m_currentTxVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());
+	}
+      else
+	{
+	  txDuration = m_phy->CalculateTxDuration (m_currentPacket->GetSize() + m_currentHdr.GetSize() + 4, m_currentTxVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());
+	}
+      padDuration = m_tbMpduDuration - txDuration;
+
+      double seconds = padDuration.GetSeconds();
+      double dataRate = m_currentTxVector.GetMode ().GetDataRate (m_currentTxVector);
+
+      padSize = round((seconds * dataRate)/8);
+
+      if (padDuration > Seconds(0.0))
+	{
+	  if(m_ampdu)
+	    {
+	      WifiMacHeader hdr;
+	      Ptr<Packet> newPacket = m_aggregateQueue->Dequeue(&hdr)->Copy ();
+	      newPacket->AddPaddingAtEnd (padSize);
+	      m_aggregateQueue->PushFront(newPacket, hdr);
+	      m_currentPacket->AddPaddingAtEnd(padSize);
+	    }
+	  else
+	    {
+	      m_currentPacket->AddPaddingAtEnd(padSize);
+	    }
+	}
+    }
     
   if (NeedRts ())
     {
@@ -823,7 +1065,7 @@ MacLow::StartTransmission (Ptr<const Packet> packet,
     }
 
   /* When this method completes, we have taken ownership of the medium. */
-  NS_ASSERT (m_phy->IsStateTx ());
+ // NS_ASSERT (m_phy->IsStateTx ());
 }
 
 bool
@@ -890,19 +1132,128 @@ void
 MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, WifiPreamble preamble, bool ampduSubframe)
 {
   NS_LOG_FUNCTION (this << packet << rxSnr << txVector.GetMode () << preamble);
+
   /* A packet is received from the PHY.
    * When we have handled this packet,
    * we handle any packet present in the
    * packet queue.
    */
+  WifiHeTriggerMacHeader trgHdr;
+  WifiHeMuRtsHeader muRts;
+  WifiHEBasicTriggerMacHeader basicTrgHdr;
+  staRuMap  ruMapGetInfo;
+  uint8_t numOfUsersGet;
   WifiMacHeader hdr;
+  struct RUInfo ruInfoRx;
   packet->RemoveHeader (hdr);
   m_lastReceivedHdr = hdr;
+  WifiHEBsrpMacHeader bsrpTrgHdr;
+
 
   bool isPrevNavZero = IsNavZero ();
   NS_LOG_DEBUG ("duration/id=" << hdr.GetDuration ());
   NotifyNav (packet, hdr, preamble);
-  if (hdr.IsRts ())
+
+  if (hdr.IsHeTrigger())
+    {
+      packet->RemoveHeader(trgHdr);
+
+      if(trgHdr.IsMuRts()) {
+	    if (ampduSubframe)
+		{
+		  NS_FATAL_ERROR ("Received RTS as part of an A-MPDU");
+		}
+	      else
+		{
+		  numOfUsersGet = trgHdr.GetNumOfUsers();
+                  m_phy->SetRu(0xff);
+		  muRts.SetNumOfUsers(numOfUsersGet);
+		  packet->RemoveHeader(muRts);
+		  ruMapGetInfo = muRts.GetRuMap();
+
+		  for (staRuMap::const_iterator j = ruMapGetInfo.begin (); j != ruMapGetInfo.end (); j ++)
+		  {
+                      if(j->second.m_aid == GetAid()) {
+                          HEBitMap BitMap;
+
+                          ruInfoRx = BitMap.GetRUInfoFromTriggerBitMap(j->second.index);
+
+		          NS_LOG_DEBUG ("rx RTS from=" << hdr.GetAddr2 () << ", schedule CTS");
+			  NS_ASSERT (m_sendCtsEvent.IsExpired ());
+			  txVector.SetAid(GetAid());
+                          txVector.SetRu(j->second.index);
+                          m_phy->SetRu(j->second.index);
+		          SetChannelWidthForRu(txVector);
+			  m_sendCtsEvent = Simulator::Schedule (GetSifs (),
+								&MacLow::SendCtsAfterRts, this,
+								hdr.GetAddr2 (),
+								hdr.GetDuration (),
+								txVector,
+								rxSnr);
+                      }
+		  }
+               }
+      } else if(trgHdr.IsBasicTrigger()) {  /* Basic Trigger. */
+              if (ampduSubframe)
+		{
+                  NS_FATAL_ERROR ("Received Basic Trigger as part of an A-MPDU");
+		}
+	      else
+		{
+	          m_phy->SetRu(0xff);
+		  numOfUsersGet = trgHdr.GetNumOfUsers();
+
+		  basicTrgHdr.SetNumOfUsers(numOfUsersGet);
+		  packet->RemoveHeader(basicTrgHdr);
+		  ruMapGetInfo = basicTrgHdr.GetRuMap();
+
+		  for (staRuMap::const_iterator j = ruMapGetInfo.begin (); j != ruMapGetInfo.end (); j ++)
+		  {
+                      if(j->second.m_aid == GetAid()) { /*For now, later we have to do for its own m_aid*/
+		          NS_LOG_DEBUG ("Basic Trigger from=" << hdr.GetAddr2 () << ", schedule Data");
+		          //Data duration is duration- GetAckD
+		          Time duration = hdr.GetDuration() - GetBlockAckDuration(hdr.GetAddr2(), txVector, COMPRESSED_BLOCK_ACK);
+		          duration -= GetSifs();
+		          duration -= GetSifs();
+
+		          txVector.SetRu(j->second.index);
+		          m_phy->SetRu(j->second.index);
+		          SetChannelWidthForRu(txVector);
+		          txVector.SetMode(m_phy->GetHeMcs(j->second.mcs));
+	                  m_sendDataEvent = Simulator::Schedule (GetSifs (),
+                                  &MacLow::SendDataAfterTrigger, this, duration, txVector);
+                      }
+		  }
+               }
+      } else if(trgHdr.IsBsrpTrigger()) {  /* BSRP Trigger. */
+              if (ampduSubframe)
+                {
+                  NS_FATAL_ERROR ("Received BSRP as part of an A-MPDU");
+                }
+              else
+                {
+                  m_phy->SetRu(0xff);
+                  numOfUsersGet = trgHdr.GetNumOfUsers();
+
+                  bsrpTrgHdr.SetNumOfUsers(numOfUsersGet);
+                  packet->RemoveHeader(bsrpTrgHdr);
+                  ruMapGetInfo = bsrpTrgHdr.GetRuMap();
+
+                  for (staRuMap::const_iterator j = ruMapGetInfo.begin (); j != ruMapGetInfo.end (); j ++)
+                  {
+                      if(j->second.m_aid == GetAid()) { /*For now, later we have to do for its own m_aid*/
+                          txVector.SetRu(j->second.index);
+                          m_phy->SetRu(j->second.index);
+                          txVector.SetAid (GetAid ());
+		          SetChannelWidthForRu(txVector);
+	                  m_sendDataEvent = Simulator::Schedule (GetSifs (),
+                                  &MacLow::SendBsrAfterBsrp, this, hdr.GetDuration(), txVector, rxSnr, hdr.GetAddr2 ());
+                      }
+                  }
+               }
+       }
+   }
+  else if (hdr.IsRts ())
     {
       /* see section 9.2.5.7 802.11-1999
        * A STA that is addressed by an RTS frame shall transmit a CTS frame after a SIFS
@@ -939,7 +1290,7 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
   else if (hdr.IsCts ()
            && hdr.GetAddr1 () == m_self
            && m_ctsTimeoutEvent.IsRunning ()
-           && m_currentPacket != 0)
+           && (m_currentPacket != 0 || m_isHeMuMpduStarted))
     {
       if (ampduSubframe)
         {
@@ -950,19 +1301,19 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
 
       SnrTag tag;
       packet->RemovePacketTag (tag);
-      m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
+      m_stationManager->ReportRxOk (hdr.GetAddr2 (), &hdr,
                                     rxSnr, txVector.GetMode ());
-      m_stationManager->ReportRtsOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
+      m_stationManager->ReportRtsOk (hdr.GetAddr2 (), &hdr,
                                      rxSnr, txVector.GetMode (), tag.Get ());
-
-      m_ctsTimeoutEvent.Cancel ();
-      NotifyCtsTimeoutResetNow ();
-      m_listener->GotCts (rxSnr, txVector.GetMode ());
-      NS_ASSERT (m_sendDataEvent.IsExpired ());
-      m_sendDataEvent = Simulator::Schedule (GetSifs (),
-                                             &MacLow::SendDataAfterCts, this,
-                                             hdr.GetAddr1 (),
-                                             hdr.GetDuration ());
+      Time ctsDiffDuration;
+      if (GotCts(rxSnr, txVector, ctsDiffDuration)&&m_sendDataEvent.IsExpired ())
+	{
+	  NS_ASSERT (m_sendDataEvent.IsExpired ());
+	  m_sendDataEvent = Simulator::Schedule (GetSifs () + ctsDiffDuration,
+						 &MacLow::SendDataAfterCts, this,
+						 hdr.GetAddr1 (),
+						 hdr.GetDuration ());
+	}
     }
   else if (hdr.IsAck ()
            && hdr.GetAddr1 () == m_self
@@ -974,46 +1325,9 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
       NS_LOG_DEBUG ("receive ack from=" << m_currentHdr.GetAddr1 ());
       SnrTag tag;
       packet->RemovePacketTag (tag);
-      m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
-                                    rxSnr, txVector.GetMode ());
-      m_stationManager->ReportDataOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
-                                      rxSnr, txVector.GetMode (), tag.Get ());
-
-      bool gotAck = false;
-      if (m_txParams.MustWaitNormalAck ()
-          && m_normalAckTimeoutEvent.IsRunning ())
-        {
-          m_normalAckTimeoutEvent.Cancel ();
-          NotifyAckTimeoutResetNow ();
-          gotAck = true;
-        }
-      if (m_txParams.MustWaitFastAck ()
-          && m_fastAckTimeoutEvent.IsRunning ())
-        {
-          m_fastAckTimeoutEvent.Cancel ();
-          NotifyAckTimeoutResetNow ();
-          gotAck = true;
-        }
-      if (gotAck)
-        {
-          m_listener->GotAck (rxSnr, txVector.GetMode ());
-        }
-      if (m_txParams.HasNextPacket ())
-        {
-          m_waitSifsEvent = Simulator::Schedule (GetSifs (),
-                                                 &MacLow::WaitSifsAfterEndTxFragment, this);
-        }
-      else if (m_currentHdr.IsQosData () && !m_ampdu)
-        {
-          m_waitSifsEvent = Simulator::Schedule (GetSifs (),
-                                                 &MacLow::WaitSifsAfterEndTx, this);
-        }
-
-      FlushAggregateQueue ();
-      m_ampdu = false;
+      GotAck(rxSnr, txVector, tag.Get ());
     }
   else if (hdr.IsBlockAck () && hdr.GetAddr1 () == m_self
-           && (m_txParams.MustWaitBasicBlockAck () || m_txParams.MustWaitCompressedBlockAck ())
            && m_blockAckTimeoutEvent.IsRunning ())
     {
       NS_LOG_DEBUG ("got block ack from " << hdr.GetAddr2 ());
@@ -1021,12 +1335,19 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
       packet->RemovePacketTag (tag);
       CtrlBAckResponseHeader blockAck;
       packet->RemoveHeader (blockAck);
-      m_blockAckTimeoutEvent.Cancel ();
-      NotifyAckTimeoutResetNow ();
-      m_listener->GotBlockAck (&blockAck, hdr.GetAddr2 (), rxSnr, txVector.GetMode (), tag.Get ());
-      m_sentMpdus = 0;
-      m_ampdu = false;
-      FlushAggregateQueue ();
+      if (m_isHeMuMpduStarted == false && (m_txParams.MustWaitBasicBlockAck () || m_txParams.MustWaitCompressedBlockAck ()))
+	{
+	  m_blockAckTimeoutEvent.Cancel ();
+	  NotifyAckTimeoutResetNow ();
+	  m_listener->GotBlockAck (&blockAck, hdr.GetAddr2 (), rxSnr, txVector.GetMode (), tag.Get ());
+	  m_sentMpdus = 0;
+	  m_ampdu = false;
+	  FlushAggregateQueue ();
+	}
+      else
+	{
+	  GotBlockAck(&blockAck, hdr, rxSnr, txVector, tag.Get ());
+	}
     }
   else if (hdr.IsBlockAckReq () && hdr.GetAddr1 () == m_self)
     {
@@ -1044,7 +1365,7 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
               (*i).second.UpdateWithBlockAckReq (blockAckReq.GetStartingSequence ());
 
               //NS_ASSERT (m_sendAckEvent.IsExpired ());
-              m_sendAckEvent.Cancel ();
+              //m_sendAckEvent.Cancel ();
               /* See section 11.5.3 in IEEE 802.11 for mean of this timer */
               ResetBlockAckInactivityTimerIfNeeded (it->second.first);
               if ((*it).second.first.IsImmediateBlockAck ())
@@ -1055,7 +1376,7 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
                                                         blockAckReq,
                                                         hdr.GetAddr2 (),
                                                         hdr.GetDuration (),
-                                                        txVector.GetMode (),
+                                                        txVector,
                                                         rxSnr);
                 }
               else
@@ -1081,7 +1402,10 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
     {
       m_stationManager->ReportRxOk (hdr.GetAddr2 (), &hdr,
                                     rxSnr, txVector.GetMode ());
-      if (hdr.IsQosData () && ReceiveMpdu (packet, hdr))
+      if(hdr.IsQosData () && hdr.IsCtrlBsrHdr()) {
+            // TO DO
+        }
+      else if (hdr.IsQosData () && ReceiveMpdu (packet, hdr))
         {
           /* From section 9.10.4 in IEEE 802.11:
              Upon the receipt of a QoS data frame from the originator for which
@@ -1096,12 +1420,13 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
               RxCompleteBufferedPacketsWithSmallerSequence (it->second.first.GetStartingSequenceControl (),
                                                             hdr.GetAddr2 (), hdr.GetQosTid ());
               RxCompleteBufferedPacketsUntilFirstLost (hdr.GetAddr2 (), hdr.GetQosTid ());
-              NS_ASSERT (m_sendAckEvent.IsExpired ());
+              //NS_ASSERT (m_sendAckEvent.IsExpired ());
+              txVector.SetAid (GetAid ());
               m_sendAckEvent = Simulator::Schedule (GetSifs (),
                                                     &MacLow::SendAckAfterData, this,
                                                     hdr.GetAddr2 (),
                                                     hdr.GetDuration (),
-                                                    txVector.GetMode (),
+                                                    txVector,
                                                     rxSnr);
             }
           else if (hdr.IsQosBlockAck ())
@@ -1123,7 +1448,11 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
              them and shall send a DELBA frame using the normal access
              mechanisms. */
           AcIndex ac = QosUtilsMapTidToAc (hdr.GetQosTid ());
-          m_edcaListeners[ac]->BlockAckInactivityTimeout (hdr.GetAddr2 (), hdr.GetQosTid ());
+          QueueListenersI it = m_edcaListeners.find (std::make_pair (hdr.GetAddr1 (), ac));
+          if (it != m_edcaListeners.end ())
+            {
+              it->second->BlockAckInactivityTimeout (hdr.GetAddr2 (), hdr.GetQosTid ());
+            }
           return;
         }
       else if (hdr.IsQosData () && hdr.IsQosNoAck ())
@@ -1153,12 +1482,16 @@ MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, Wifi
           else
             {
               NS_LOG_DEBUG ("rx unicast/sendAck from=" << hdr.GetAddr2 ());
-              NS_ASSERT (m_sendAckEvent.IsExpired ());
+              if (!m_stationManager->HasHeSupported())
+        	{
+                  NS_ASSERT (m_sendAckEvent.IsExpired ());
+        	}
+              txVector.SetAid (GetAid ());
               m_sendAckEvent = Simulator::Schedule (GetSifs (),
                                                     &MacLow::SendAckAfterData, this,
                                                     hdr.GetAddr2 (),
                                                     hdr.GetDuration (),
-                                                    txVector.GetMode (),
+                                                    txVector,
                                                     rxSnr);
             }
         }
@@ -1274,8 +1607,15 @@ MacLow::GetRtsSize (void) const
 Time
 MacLow::GetAckDuration (Mac48Address to, WifiTxVector dataTxVector) const
 {
-  WifiTxVector ackTxVector = GetAckTxVectorForData (to, dataTxVector.GetMode ());
-  return GetAckDuration (ackTxVector);
+  if (m_stationManager->HasHeSupported())
+    {
+      return GetAckDuration (dataTxVector);
+    }
+  else
+    {
+      WifiTxVector ackTxVector = GetAckTxVectorForData (to, dataTxVector.GetMode ());
+      return GetAckDuration (ackTxVector);
+    }
 }
 
 Time
@@ -1283,7 +1623,11 @@ MacLow::GetAckDuration (WifiTxVector ackTxVector) const
 {
   NS_ASSERT (ackTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //ACK should always use non-HT PPDU (HT PPDU cases not supported yet)
   WifiPreamble preamble;
-  if (m_stationManager->GetShortPreambleEnabled ())
+  if (ackTxVector.GetMode().GetModulationClass() == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (m_stationManager->GetShortPreambleEnabled ())
     {
       preamble = WIFI_PREAMBLE_SHORT;
     }
@@ -1302,7 +1646,11 @@ MacLow::GetBlockAckDuration (Mac48Address to, WifiTxVector blockAckReqTxVector,
    * as the BlockAckReq.
    */
   WifiPreamble preamble;
-  if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT && type == BASIC_BLOCK_ACK)
+  if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT && type == BASIC_BLOCK_ACK)
     {
       preamble = WIFI_PREAMBLE_HT_MF;
     }
@@ -1317,6 +1665,16 @@ MacLow::GetBlockAckDuration (Mac48Address to, WifiTxVector blockAckReqTxVector,
   return m_phy->CalculateTxDuration (GetBlockAckSize (type), blockAckReqTxVector, preamble, m_phy->GetFrequency ());
 }
 
+Time
+MacLow::GetBsrpDuration (WifiTxVector bsrpTxVector) const
+{
+  NS_ASSERT(bsrpTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE);
+  WifiPreamble preamble;
+  
+  preamble = WIFI_PREAMBLE_HE;
+  return m_phy->CalculateTxDuration (GetBsrSize (), bsrpTxVector, preamble, m_phy->GetFrequency ());
+}
+
 Time
 MacLow::GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector) const
 {
@@ -1329,7 +1687,11 @@ MacLow::GetCtsDuration (WifiTxVector ctsTxVector) const
 {
   NS_ASSERT (ctsTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //CTS should always use non-HT PPDU (HT PPDU cases not supported yet)
   WifiPreamble preamble;
-  if (m_stationManager->GetShortPreambleEnabled ())
+  if (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (m_stationManager->GetShortPreambleEnabled ())
     {
       preamble = WIFI_PREAMBLE_SHORT;
     }
@@ -1348,6 +1710,14 @@ MacLow::GetCtsSize (void) const
   return cts.GetSize () + 4;
 }
 
+uint32_t
+MacLow::GetBsrSize (void) const
+{
+  /* Normal data packet size which includes control header, this will have BSRP response info. */
+  /* Type/subtype + duration + src1 + src2 + src3 + fragment/seq + qos data + control header */
+  return 2 + 2 + 6 + 6 + 6 + 2 + 2 + 4;
+}
+
 uint32_t
 MacLow::GetSize (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
 {
@@ -1381,7 +1751,14 @@ WifiTxVector
 MacLow::GetDataTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
 {
   Mac48Address to = hdr->GetAddr1 ();
-  return m_stationManager->GetDataTxVector (to, hdr, packet);
+  if (m_isHeMuMpduStarted || m_isHeMuTbMpduStarted)
+    {
+      return m_listener->GetDataTxVector ();
+    }
+  else
+    {
+      return m_stationManager->GetDataTxVector (to, hdr, packet);
+    }
 }
 
 WifiTxVector
@@ -1393,7 +1770,26 @@ MacLow::GetCtsTxVector (Mac48Address to, WifiMode rtsTxMode) const
 WifiTxVector
 MacLow::GetAckTxVector (Mac48Address to, WifiMode dataTxMode) const
 {
-  return m_stationManager->GetAckTxVector (to, dataTxMode);
+  if (m_stationManager->HasHeSupported())
+    {
+      //WifiTxVector txVector = m_stationManager->GetBlockAckTxVector (to, dataTxMode);
+      return WifiTxVector (dataTxMode, m_stationManager->GetDefaultTxPowerLevel (), 0, m_phy->GetGuardInterval(), 1, 0, m_phy->GetChannelWidth(), false, false);
+      //txVector.SetMode(dataTxMode);
+      //return txVector;
+    }
+  else
+    {
+      return m_stationManager->GetAckTxVector (to, dataTxMode);
+    }
+}
+
+WifiTxVector
+MacLow::GetBlockAckTxVector (WifiTxVector dataTxVector) const
+{
+  WifiTxVector txVector = WifiTxVector (dataTxVector.GetMode(), m_stationManager->GetDefaultTxPowerLevel (), 0, m_phy->GetGuardInterval(), 1, 0, m_phy->GetChannelWidth(), false, false);
+  txVector.SetRu(dataTxVector.GetRu());
+  txVector.SetChannelWidth(dataTxVector.GetChannelWidth());
+  return txVector;
 }
 
 WifiTxVector
@@ -1443,7 +1839,11 @@ MacLow::CalculateOverallTxTime (Ptr<const Packet> packet,
       txTime += Time (GetSifs () * 2);
     }
   WifiTxVector dataTxVector = GetDataTxVector (packet, hdr);
-  if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
+  if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
     {
       preamble = WIFI_PREAMBLE_VHT;
     }
@@ -1483,7 +1883,11 @@ MacLow::CalculateTransmissionTime (Ptr<const Packet> packet,
     {
       WifiTxVector dataTxVector = GetDataTxVector (packet, hdr);
       WifiPreamble preamble;
-      if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
+      if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+        {
+          preamble = WIFI_PREAMBLE_HE;
+        }
+      else if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
         {
           preamble = WIFI_PREAMBLE_VHT;
         }
@@ -1524,7 +1928,7 @@ MacLow::NotifyNav (Ptr<const Packet> packet,const WifiMacHeader &hdr, WifiPreamb
     }
   /// \todo We should also handle CF_END specially here
   /// but we don't for now because we do not generate them.
-  else if (hdr.GetAddr1 () != m_self)
+  else if (hdr.GetAddr1 () != m_self && !hdr.IsHeTrigger ())
     {
       // see section 9.2.5.4 802.11-1999
       bool navUpdated = DoNavStartNow (duration);
@@ -1627,7 +2031,7 @@ MacLow::NotifyCtsTimeoutResetNow ()
 
 void
 MacLow::ForwardDown (Ptr<const Packet> packet, const WifiMacHeader* hdr,
-                     WifiTxVector txVector, WifiPreamble preamble)
+                     WifiTxVector txVector, WifiPreamble preamble, Ptr<WifiMacQueue> aggQueue)
 {
   NS_LOG_FUNCTION (this << packet << hdr << txVector);
   NS_LOG_DEBUG ("send " << hdr->GetTypeString () <<
@@ -1646,15 +2050,15 @@ MacLow::ForwardDown (Ptr<const Packet> packet, const WifiMacHeader* hdr,
       Ptr <const Packet> dequeuedPacket;
       WifiMacHeader newHdr;
       WifiMacTrailer fcs;
-      m_nTxMpdus = m_aggregateQueue->GetSize ();
-      uint32_t queueSize = m_aggregateQueue->GetSize ();
+      m_nTxMpdus = aggQueue->GetSize ();
+      uint32_t queueSize = aggQueue->GetSize ();
       bool vhtSingleMpdu = false;
       bool last = false;
       enum mpduType mpdutype = NORMAL_MPDU;
       
       uint8_t tid = GetTid (packet, *hdr);
       AcIndex ac = QosUtilsMapTidToAc (tid);
-      std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
+      QueueListenersI  listenerIt = m_edcaListeners.find (std::make_pair(hdr->GetAddr1 (), ac));
 
       if (queueSize == 1)
         {
@@ -1672,7 +2076,7 @@ MacLow::ForwardDown (Ptr<const Packet> packet, const WifiMacHeader* hdr,
         }
       for (; queueSize > 0; queueSize--)
         {
-          dequeuedPacket = m_aggregateQueue->Dequeue (&newHdr);
+          dequeuedPacket = aggQueue->Dequeue (&newHdr);
           newPacket = dequeuedPacket->Copy ();
           newHdr.SetDuration (hdr->GetDuration ());
           newPacket->AddHeader (newHdr);
@@ -1746,16 +2150,36 @@ MacLow::CtsTimeout (void)
   /// \todo should check that there was no rx start before now.
   /// we should restart a new cts timeout now until the expected
   /// end of rx if there was a rx start before now.
-  m_stationManager->ReportRtsFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
-  if (m_sentMpdus == 0)
+  if (m_isHeMuMpduStarted == false)
+    {
+      m_stationManager->ReportRtsFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
+      if (m_sentMpdus == 0)
+        {
+          m_currentPacket = 0;
+        }
+      MacLowTransmissionListener *listener = m_listener;
+      m_listener = 0;
+      m_sentMpdus = 0;
+      m_ampdu = false;
+      listener->MissedCts ();
+      return;
+    }
+  else
     {
-      m_currentPacket = 0;
+      int missedCts = 0;
+      for(HEStationsI it = m_heStations.begin(); it != m_heStations.end(); ++it)
+        {
+          HeMpduItem item = it->second;
+          if(!item.listener->IsCtsReceived ())
+            {
+              missedCts++;
+            }
+        }
+      if (missedCts == m_heStations.size ())
+	{
+	  SetOfdmaHeTransmit (false);
+	}
     }
-  MacLowTransmissionListener *listener = m_listener;
-  m_listener = 0;
-  m_sentMpdus = 0;
-  m_ampdu = false;
-  listener->MissedCts ();
 }
 
 void
@@ -1766,13 +2190,33 @@ MacLow::NormalAckTimeout (void)
   /// \todo should check that there was no rx start before now.
   /// we should restart a new ack timeout now until the expected
   /// end of rx if there was a rx start before now.
-  m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
-  MacLowTransmissionListener *listener = m_listener;
-  m_listener = 0;
-  m_sentMpdus = 0;
-  m_ampdu = false;
-  FlushAggregateQueue ();
-  listener->MissedAck ();
+  if (m_isHeMuMpduStarted == false)
+    {
+      m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
+      MacLowTransmissionListener *listener = m_listener;
+      m_listener = 0;
+      m_sentMpdus = 0;
+      m_ampdu = false;
+      FlushAggregateQueue ();
+      listener->MissedAck ();
+      return;
+    }
+  for(HEStationsI it = m_heStations.begin(); it != m_heStations.end(); ++it)
+    {
+      HeMpduItem item = it->second;
+      if(!item.listener->IsAckReceived()&&item.params.MustWaitNormalAck ())
+	{
+	  //Inform the client State machine and remove the client from the list of current clients
+          m_stationManager->ReportDataFailed (item.hdr.GetAddr1 (), &item.hdr);
+	  item.listener->MissedAck();
+	}
+    }
+  //received ACK from all parties
+  if (m_blockAckTimeoutEvent.IsExpired())
+    {
+      SetOfdmaHeTransmit(false);
+      //Simulator::Schedule (GetSifs (), &MacLow::StartNextHeMuMpdu, this);
+    }
 }
 
 void
@@ -1798,12 +2242,32 @@ MacLow::BlockAckTimeout (void)
 {
   NS_LOG_FUNCTION (this);
   NS_LOG_DEBUG ("block ack timeout");
-  MacLowTransmissionListener *listener = m_listener;
-  m_listener = 0;
-  m_sentMpdus = 0;
-  m_ampdu = false;
-  FlushAggregateQueue ();
-  listener->MissedBlockAck (m_nTxMpdus);
+  if (m_isHeMuMpduStarted == false)
+    {
+      MacLowTransmissionListener *listener = m_listener;
+      m_listener = 0;
+      m_sentMpdus = 0;
+      m_ampdu = false;
+      FlushAggregateQueue ();
+      listener->MissedBlockAck (m_nTxMpdus);
+      return;
+    }
+
+  for(HEStationsI it = m_heStations.begin(); it != m_heStations.end(); ++it)
+    {
+      HeMpduItem item = it->second;
+      if(!item.listener->IsAckReceived() && !item.params.MustWaitNormalAck ())
+	{
+	  //Inform the client State machine and remove the client from the list of current clients
+	  item.listener->MissedBlockAck(item.aggQueue->GetSize());
+	}
+    }
+  //received ACK from all parties
+  if (m_normalAckTimeoutEvent.IsExpired ())
+    {
+      SetOfdmaHeTransmit(false);
+      //Simulator::Schedule (GetSifs (), &MacLow::StartNextHeMuMpdu, this);
+    }
 }
 
 void
@@ -1825,6 +2289,584 @@ MacLow::SuperFastAckTimeout ()
     }
 }
 
+Time
+MacLow::GetMaxDurationForCts (void)
+{
+  Time              txDuration = Seconds(0);
+  Time              maxDuration = Seconds(0);
+
+  for(HEStationsI s = m_heStations.begin(); s != m_heStations.end(); s++)
+  {
+      HeMpduItem item = s->second;
+      WifiTxVector muRtsTxVector = m_stationManager->GetMuRtsTxVector();
+      muRtsTxVector.SetRu(item.txVector.GetRu ());
+      muRtsTxVector.SetChannelWidth(item.txVector.GetChannelWidth ());
+      txDuration = GetCtsDuration (muRtsTxVector);
+      if(txDuration > maxDuration) {
+          maxDuration = txDuration;
+      }
+  }
+  for(HEStationsI s = m_heStations.begin(); s != m_heStations.end(); s++)
+  {
+      HeMpduItem item = s->second;
+      WifiTxVector muRtsTxVector = m_stationManager->GetMuRtsTxVector();
+      muRtsTxVector.SetRu(item.txVector.GetRu ());
+      muRtsTxVector.SetChannelWidth(item.txVector.GetChannelWidth ());
+      txDuration = GetCtsDuration (muRtsTxVector);
+      s->second.ctsDurationDiff = maxDuration - txDuration;
+  }
+
+
+  return maxDuration;
+}
+
+Time
+MacLow::GetMaxDurationForBsr (staRuMap staMap, WifiTxVector bsrpTxVector)
+{
+  Time              txDuration = Seconds(0);
+  Time              maxDuration = Seconds(0);
+
+  for (staRuMap::const_iterator j = staMap.begin (); j != staMap.end (); j ++)
+  {
+      HEBitMap bitmap;
+      RUInfo ruI = bitmap.GetRUInfoFromTriggerBitMap(j->second.index);
+      uint32_t chanW = 20;
+      if (ruI.type == 1)
+        chanW = 2;
+      else if (ruI.type == 2)
+        chanW = 4;
+      else if (ruI.type == 3)
+        chanW = 8;
+
+      WifiTxVector txVector = WifiTxVector (bsrpTxVector.GetMode (), 0, 0, false, 1, 0, chanW, false, false);
+
+      txDuration = GetBsrpDuration (txVector);
+      if(txDuration > maxDuration) {
+          maxDuration = txDuration;
+      }
+  }
+
+  return maxDuration;
+}
+
+Time
+MacLow::GetMaxDurationForAck ()
+{
+  Time              txDuration = Seconds(0);
+  Time              maxDuration = Seconds(0);
+
+  for(HEStationsI s = m_heStations.begin(); s != m_heStations.end(); s++)
+  {
+      HeMpduItem item = s->second;
+      if (item.isAmpdu && item.aggQueue->GetSize() > 1)
+	{
+	  WifiTxVector ackTxVector = GetBlockAckTxVector (item.txVector);
+	  txDuration =  GetBlockAckDuration (item.hdr.GetAddr1 (), ackTxVector, COMPRESSED_BLOCK_ACK);
+	}
+      else
+	{
+	  WifiTxVector ackTxVector = GetAckTxVector (item.hdr.GetAddr1 (), item.txVector.GetMode());
+	  ackTxVector.SetRu(item.txVector.GetRu());
+	  ackTxVector.SetChannelWidth(item.txVector.GetChannelWidth());
+	  txDuration = GetAckDuration (ackTxVector);
+	}
+      if(txDuration > maxDuration) {
+          maxDuration = txDuration;
+      }
+  }
+  return maxDuration;
+}
+
+Time
+MacLow::GetMaxDurationForSI (void)
+{
+  Time              txDuration = Seconds(0);
+  Time              maxDuration = Seconds(0);
+
+  for(HEStationsI s = m_heStations.begin(); s != m_heStations.end(); s++)
+  {
+      HeMpduItem item = s->second;
+      if (item.isAmpdu)
+	{
+	  txDuration = m_phy->CalculateTxDuration (item.packet->GetSize (), item.txVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());
+	}
+      else
+	{
+	  txDuration = m_phy->CalculateTxDuration (item.packet->GetSize () + item.hdr.GetSize()+4, item.txVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());
+	}
+      if(txDuration > maxDuration) {
+          maxDuration = txDuration;
+      }
+  }
+  return maxDuration;
+}
+
+void
+MacLow::PadHeMpduIfNeeded (Time duration)
+{
+  Time              txDuration;
+  Time              maxDuration;
+  Time              padDuration;
+  uint32_t          padSize;
+
+  for(HEStationsI s = m_heStations.begin(); s != m_heStations.end(); s++)
+    {
+      HeMpduItem item = s->second;
+      if (item.isAmpdu)
+	{
+	  txDuration = m_phy->CalculateTxDuration (item.packet->GetSize (), item.txVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());
+	}
+      else
+	{
+	  txDuration = m_phy->CalculateTxDuration (item.packet->GetSize () + item.hdr.GetSize() + 4, item.txVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());
+	}
+      padDuration = duration - txDuration;
+
+      double seconds = padDuration.GetSeconds();
+      double dataRate = item.txVector.GetMode ().GetDataRate (item.txVector);
+
+      padSize = round((seconds * dataRate)/8);
+
+      if (padDuration <= Seconds(0.0))
+	{
+	  continue;
+	}
+      if(item.isAmpdu)
+	{
+	  WifiMacHeader hdr;
+	  Ptr<Packet> newPacket = item.aggQueue->Dequeue(&hdr)->Copy ();
+	  padSize += (4 - (padSize % 4 )) % 4;
+          newPacket->AddPaddingAtEnd (padSize);
+          item.aggQueue->PushFront(newPacket, hdr);
+	  item.packet->AddPaddingAtEnd(padSize);
+	}
+      else
+	{
+	  item.packet->AddPaddingAtEnd(padSize);
+	}
+    }
+}
+
+
+void
+MacLow::SendBsrpTrigger(staRuMap staMap)
+{
+  NS_LOG_FUNCTION (this);
+  /* send an Bsrp Trigger for this packet. */
+  WifiMacHeader macHdr;
+  WifiHeTriggerMacHeader trgHdr;
+  WifiHEBsrpMacHeader bsrpTrg;
+  WifiMacTrailer fcs;
+
+  WifiTxVector basicTrgTxVector = m_stationManager->GetMuRtsTxVector();
+  basicTrgTxVector.SetRu(0xff);  //Since it goes in 20MHz channel.
+
+  /* Mac Header */
+  macHdr.SetType (WIFI_MAC_CTL_HE_TRIGGER);
+  macHdr.SetDsNotFrom ();
+  macHdr.SetDsNotTo ();
+  macHdr.SetNoRetry ();
+  macHdr.SetNoMoreFragments ();
+  macHdr.SetAddr1(Mac48Address::GetBroadcast ());
+  macHdr.SetAddr2 (m_self);
+
+  /* Trigger Header */
+  trgHdr.ConfigTriggerSubType(WIFI_MAC_CTL_TRIGGER_HE_BSRP);
+  trgHdr.SetType(WIFI_MAC_CTL_TRIGGER_HE_BSRP);
+  trgHdr.SetNumOfUsers(staMap.size());
+
+  bsrpTrg.SetStaRuMap(staMap);
+  /* Bsrp Trigger Packet */
+  Ptr<Packet> packet = Create<Packet> ();
+  packet->AddHeader (bsrpTrg);   /* Basic Trigger User Info */
+  packet->AddHeader (trgHdr);  /* Trigger Header */
+
+  // We will be protecting on the trigger + sifs
+  Time duration = GetSifs();
+  duration += GetMaxDurationForBsr(staMap, basicTrgTxVector);
+
+  macHdr.SetDuration (duration);
+  packet->AddHeader (macHdr);  /* Wifi Mac Header */
+  packet->AddTrailer (fcs);
+
+  //Set phy for expected RU list on tx/rx is going to happen
+  SetPhyRuMap  (staMap);
+  m_phy->SendPacket(packet, basicTrgTxVector, WIFI_PREAMBLE_HE);
+}
+
+
+void
+MacLow::SendMuRtsForPacket (Time currentSI)
+{
+  NS_LOG_FUNCTION (this);
+  staRuMap  staMap;
+  m_currentSI = currentSI;
+
+  if (m_heStations.size() == 0)
+    {
+      // nothing to send
+      SetOfdmaHeTransmit(false);
+      return;
+    }
+  else
+    {
+      for(HEStationsI it=m_heStations.begin(); it != m_heStations.end(); it++)
+        {
+         RuInfo   ruInfoTx;
+         uint16_t staAid = it->second.listener->GetAid ();
+         ruInfoTx.index = it->second.txVector.GetRu();
+         // We are going to serve these AIDs in this iteration
+         ruInfoTx.m_aid = staAid;
+         staMap.insert (std::make_pair (staAid, ruInfoTx));
+        }
+    }
+  /* send an MuRTS for this packet. */
+  WifiMacHeader macHdr;
+  WifiHeTriggerMacHeader trgHdr;
+  WifiHeMuRtsHeader muRts;
+  WifiMacTrailer fcs;
+  WifiTxVector muRtsTxVector = m_stationManager->GetMuRtsTxVector();
+  muRtsTxVector.SetRu(0xff);  //Since it goes in 20MHz channel.
+  WifiPreamble preamble; 
+  Time duration = Seconds(0.0);
+
+  /* Mac Header */
+  macHdr.SetType (WIFI_MAC_CTL_HE_TRIGGER);
+  macHdr.SetDsNotFrom ();
+  macHdr.SetDsNotTo ();
+  macHdr.SetNoRetry ();
+  macHdr.SetNoMoreFragments ();
+  macHdr.SetAddr1(Mac48Address::GetBroadcast ());
+  macHdr.SetAddr2 (m_self);
+  preamble = WIFI_PREAMBLE_HE;
+
+  duration += GetSifs ();
+  duration += GetMaxDurationForCts();  //?? correct?
+  duration += GetSifs ();
+  duration += GetMaxDurationForSI();
+  duration += GetSifs ();
+  duration += GetMaxDurationForAck();
+
+
+  macHdr.SetDuration (m_currentSI);
+  m_currentSI -= duration;
+  /* Trigger Header */
+  trgHdr.ConfigTriggerSubType(WIFI_MAC_CTL_TRIGGER_HE_MU_RTS);
+  trgHdr.SetType(WIFI_MAC_CTL_TRIGGER_HE_MU_RTS);
+  trgHdr.SetNumOfUsers(staMap.size());
+
+  muRts.SetStaRuMap(staMap);
+  /* Mu RTS Packet */
+  Ptr<Packet> packet = Create<Packet> ();
+  packet->AddHeader (muRts);   /* MU RTS User Info */
+  packet->AddHeader (trgHdr);  /* Trigger Header */
+  packet->AddHeader (macHdr);  /* Wifi Mac Header */
+  packet->AddTrailer (fcs);
+
+
+  Time txDuration = m_phy->CalculateTxDuration (packet->GetSize(), muRtsTxVector, preamble, m_phy->GetFrequency ());
+  Time timerDelay = txDuration + GetSifs() + GetMaxDurationForCts () + GetSifs ();
+
+  NS_ASSERT (m_ctsTimeoutEvent.IsExpired ());
+  NotifyCtsTimeoutStartNow (timerDelay);
+
+  //Set phy for expected RU list on tx/rx is going to happen
+  SetPhyRuMap  (staMap);
+  m_ctsTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::CtsTimeout, this);
+  m_phy->SendPacket(packet, muRtsTxVector, preamble);
+}
+
+void
+MacLow::SetPhyRuMap(staRuMap staMap)
+{
+  //clear prev state
+  m_phy->SetRu(0xff);
+  for (staRuMap::iterator it = staMap.begin (); it != staMap.end() ; it++)
+    {
+       m_phy->SetRu(it->second.index);
+    }
+}
+
+void
+MacLow::SendBasicTrigger(staRuMap staMap, Time uplinkDuration)
+{
+  NS_LOG_FUNCTION (this);
+  /* send an Basic Trigger for this packet. */
+  WifiMacHeader macHdr;
+  WifiHeTriggerMacHeader trgHdr;
+  WifiHEBasicTriggerMacHeader basicTrg;
+  WifiMacTrailer fcs;
+
+  WifiTxVector basicTrgTxVector = m_stationManager->GetMuRtsTxVector();
+  basicTrgTxVector.SetRu(0xff);  //Since it goes in 20MHz channel.
+  //Time duration = MilliSeconds (30);
+
+  /* Mac Header */
+  macHdr.SetType (WIFI_MAC_CTL_HE_TRIGGER);
+  macHdr.SetDsNotFrom ();
+  macHdr.SetDsNotTo ();
+  macHdr.SetNoRetry ();
+  macHdr.SetNoMoreFragments ();
+  macHdr.SetAddr1(Mac48Address::GetBroadcast ());
+  macHdr.SetAddr2 (m_self);
+
+  /* Trigger Header */
+  trgHdr.ConfigTriggerSubType(WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER);
+  trgHdr.SetType(WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER);
+  trgHdr.SetNumOfUsers(staMap.size());
+
+  basicTrg.SetStaRuMap(staMap);
+  /* Basic Trigger Packet */
+  Ptr<Packet> packet = Create<Packet> ();
+  packet->AddHeader (basicTrg);   /* Basic Trigger User Info */
+  packet->AddHeader (trgHdr);  /* Trigger Header */
+
+  // We will be protecting on the trigger + sifs
+  Time duration = GetSifs();
+  duration += uplinkDuration;  // For Data
+  duration += GetSifs();
+  duration += m_phy->CalculateTxDuration (GetBlockAckSize (COMPRESSED_BLOCK_ACK), basicTrgTxVector, WIFI_PREAMBLE_HE, m_phy->GetFrequency ());;
+
+  macHdr.SetDuration (duration);
+  packet->AddHeader (macHdr);  /* Wifi Mac Header */
+  packet->AddTrailer (fcs);
+
+  Time timerDelay = MilliSeconds (1);
+
+  //NS_ASSERT (m_ctsTimeoutEvent.IsExpired ());
+
+  //m_ctsTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::BasicTrgTimeout, this);
+  //Set phy for expected RU list on tx/rx is going to happen
+  SetPhyRuMap  (staMap);
+  m_phy->SendPacket(packet, basicTrgTxVector, WIFI_PREAMBLE_HE);
+}
+
+bool
+MacLow::IsFirstHeMuMpdu(WifiMacHeader hdr)
+{
+  return m_heStations.begin ()->first == hdr.GetAddr1();
+}
+
+void
+MacLow::SetChannelWidthForRu(WifiTxVector &txVector)
+{
+  HEBitMap bitmap;
+  RUInfo ruI = bitmap.GetRUInfoFromTriggerBitMap(txVector.GetRu());
+  uint32_t chanW = 20;
+  if (ruI.type == 1)
+    chanW = 2;
+  else if (ruI.type == 2)
+    chanW = 4;
+  else if (ruI.type == 3)
+    chanW = 8;
+  else if (ruI.type == 4)
+    chanW = 20;
+  else if (ruI.type == 5)
+    chanW = 40;
+  else if (ruI.type == 6)
+    chanW = 80;
+  else if (ruI.type == 7)
+    chanW = 160;
+  txVector.SetChannelWidth(chanW);
+}
+void
+MacLow::SendDataAfterTrigger (Time duration, WifiTxVector txVector)
+{
+  NS_LOG_FUNCTION (this);
+  SetOfdmaHeTbTransmit(true);
+  m_tbMpduDuration = duration;
+  m_ofdmaFetchCallback(txVector, duration);
+  SetOfdmaHeTbTransmit(false);
+  m_tbMpduDuration = Seconds(0.0);
+}
+
+void
+MacLow::SendBsrDataPkt(WifiMacHeader hdr, WifiTxVector txVector, double rxSnr)
+{
+  WifiMacTrailer fcs;
+
+  Ptr<Packet> packet = Create<Packet> ();
+  packet->AddHeader (hdr);
+  packet->AddTrailer (fcs);
+  SnrTag tag;
+  tag.Set (rxSnr);
+  packet->AddPacketTag (tag);
+  m_phy->SendPacket (packet, txVector, WIFI_PREAMBLE_HE);
+}
+
+void
+MacLow::SendBsrAfterBsrp (Time duration, WifiTxVector txVector, double rxSnr, Mac48Address to)
+{
+  NS_LOG_FUNCTION (this);
+  duration -= GetSifs();
+
+  m_ofdmaFetchBsrCallback(duration, txVector, rxSnr, to);
+}
+
+void
+MacLow::StartNextHeMuMpdu (void)
+{
+  NS_LOG_FUNCTION (this);
+  HEStations        m_heStationsCopy = m_heStations;
+  m_heStations.clear();
+  for(HEStationsI it=m_heStationsCopy.begin(); it != m_heStationsCopy.end(); it++)
+    {
+      HeMpduItem item = it->second;
+      m_listener = item.listener;
+      if (item.params.HasNextPacket())
+       {
+         item.listener->StartNextFragment();
+       }
+      else if (item.hdr.IsQosData ())
+         //     && (!item.isAmpdu || item.aggQueue->GetSize() == 1))
+       {
+         item.listener->StartNext();
+       }
+    }
+  if (!m_heStations.empty())
+    {
+      // Lets begin next round
+      SendHeMuMpdu(m_currentSI);
+    }
+  else
+    {
+      SetOfdmaHeTransmit(false);
+    }
+}
+
+void
+MacLow::SendHeMuMpdu (Time duration)
+{
+  NS_LOG_FUNCTION(this);
+  WifiPreamble preamble = WIFI_PREAMBLE_HE;
+  Time txDuration = GetMaxDurationForSI();
+  PadHeMpduIfNeeded (txDuration);
+  uint32_t t_ac;
+  uint32_t numSubCarriers;
+  uint32_t mcs;
+
+  if (txDuration + GetSifs () + GetMaxDurationForAck () + GetSifs () > duration)
+    {
+      //Not enough room in the SI for the HE MPDU to complete
+      SetOfdmaHeTransmit(false);
+      return;
+    }
+  duration -= txDuration;
+  duration -= GetSifs ();
+  NS_ASSERT(duration > Seconds(0));
+  m_currentSI = duration;
+  for (HEStationsI it = m_heStations.begin(); it != m_heStations.end();)
+    {
+      HeMpduItem item = it->second;
+      if(!item.listener->IsCtsReceived())
+	{
+	  //Inform the client State machine and remove the client from the list of current clients
+	  item.listener->MissedCts();
+	  HEStationsI it1 = it;
+	  it1++;
+	  m_heStations.erase(it);
+	  it = it1;
+	}
+      else
+	{
+	  it++;
+	}
+    }
+  if (m_heStations.empty())
+    {
+      SetOfdmaHeTransmit(false);
+      return;
+    }
+  m_phy->SetRu(0xff);
+
+  Time ackTimeout = txDuration;
+  ackTimeout += GetSifs ();
+  ackTimeout += GetMaxDurationForAck();
+  ackTimeout += GetSifs ();
+  ackTimeout += GetSifs ();
+
+  for (HEStationsI it = m_heStations.begin(); it != m_heStations.end(); it++)
+    {
+      HeMpduItem item = it->second;
+      m_txParams = item.params;
+      item.hdr.SetDuration(m_currentSI);
+      if (m_txParams.MustWaitNormalAck ())
+	{
+	  if(!m_normalAckTimeoutEvent.IsRunning ())
+	    {
+	      NS_ASSERT (m_normalAckTimeoutEvent.IsExpired ());
+	      m_normalAckTimeoutEvent = Simulator::Schedule (ackTimeout, &MacLow::NormalAckTimeout, this);
+	    }
+	}
+      else if (m_txParams.MustWaitBasicBlockAck ())
+        {
+          NS_ASSERT (m_blockAckTimeoutEvent.IsExpired ());
+          m_blockAckTimeoutEvent = Simulator::Schedule (ackTimeout, &MacLow::BlockAckTimeout, this);
+        }
+      else if (m_txParams.MustWaitCompressedBlockAck ())
+        {
+	  if(!m_blockAckTimeoutEvent.IsRunning ())
+	    {
+	      NS_ASSERT (m_blockAckTimeoutEvent.IsExpired ());
+	      m_blockAckTimeoutEvent = Simulator::Schedule (ackTimeout, &MacLow::BlockAckTimeout, this);
+	    }
+        }
+      else
+        {
+          // since we do not expect any timer to be triggered.
+	  //item.listener->EndTxNoAck();
+          Simulator::Schedule (txDuration, &MacLowTransmissionListener::EndTxNoAck, item.listener);
+        }
+
+      if (!item.isAmpdu)
+        {
+	  item.packet->AddHeader (item.hdr);
+          WifiMacTrailer fcs;
+          item.packet->AddTrailer (fcs);
+          m_ampdu = false;
+        }
+      else
+	{
+	  m_ampdu = true;
+	}
+      if (item.txVector.GetChannelWidth() == 2)
+        numSubCarriers = 26;
+      else if (item.txVector.GetChannelWidth() == 4)
+        numSubCarriers = 52;
+      else if (item.txVector.GetChannelWidth() == 8)
+        numSubCarriers = 106;
+      else if (item.txVector.GetChannelWidth() == 20)
+        numSubCarriers = 242;
+      else if (item.txVector.GetChannelWidth() == 40)
+        numSubCarriers = 484;
+      else if (item.txVector.GetChannelWidth() == 80)
+        numSubCarriers = 996;
+      else if (item.txVector.GetChannelWidth() == 160)
+        numSubCarriers = 996*2;
+      else
+        numSubCarriers = 0;
+      if (item.hdr.IsQosData ()){
+        uint8_t tid = GetTid (item.packet, item.hdr);
+        t_ac = QosUtilsMapTidToAc (tid);
+        mcs = item.txVector.GetMode().GetMcsValue();
+        if((t_ac == AC_VI || t_ac == AC_VO) || mcs < 3){
+          if(Now()>Seconds(2.0))
+            m_highLoadingAxResourceDL = m_highLoadingAxResourceDL + (txDuration + GetSifs() + GetMaxDurationForAck() + GetSifs() + GetMaxDurationForCts()).GetMilliSeconds()*numSubCarriers;
+        }
+        if(Now()>Seconds(2.0)){
+          m_usedAxResourceDL = m_usedAxResourceDL + (txDuration + GetSifs() + GetMaxDurationForAck() + GetSifs() + GetMaxDurationForCts()).GetMilliSeconds()*numSubCarriers;
+        }
+      }
+      m_phy->SetRu(item.txVector.GetRu());
+      ForwardDown (item.packet, &item.hdr, item.txVector, preamble, item.aggQueue);
+      m_ampdu = false;
+      item.aggQueue->Flush ();
+    }
+  m_totalAxResourceDL = m_totalAxResourceDL + (txDuration + GetSifs() + GetMaxDurationForAck() + GetSifs() + GetMaxDurationForCts()).GetMilliSeconds()*242;
+  //Notify Dcf of Ack Timeout
+  NotifyAckTimeoutStartNow (ackTimeout);
+}
+
 void
 MacLow::SendRtsForPacket (void)
 {
@@ -1871,12 +2913,12 @@ MacLow::SendRtsForPacket (void)
       duration += GetSifs ();
       if (m_txParams.MustWaitBasicBlockAck ())
         {
-          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
+          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector(m_currentTxVector);
           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, BASIC_BLOCK_ACK);
         }
       else if (m_txParams.MustWaitCompressedBlockAck ())
         {
-          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
+          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
         }
       else if (m_txParams.MustWaitAck ())
@@ -1908,7 +2950,7 @@ MacLow::SendRtsForPacket (void)
   WifiMacTrailer fcs;
   packet->AddTrailer (fcs);
 
-  ForwardDown (packet, &rts, rtsTxVector, preamble);
+  ForwardDown (packet, &rts, rtsTxVector, preamble, NULL);
 }
 
 void
@@ -1916,7 +2958,11 @@ MacLow::StartDataTxTimers (WifiTxVector dataTxVector)
 {
   WifiPreamble preamble;
 
-  if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
+  if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
     {
       preamble = WIFI_PREAMBLE_VHT;
     }
@@ -2003,7 +3049,11 @@ MacLow::SendDataPacket (void)
   NS_LOG_FUNCTION (this);
   /* send this packet directly. No RTS is needed. */
   WifiPreamble preamble;
-  if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
+  if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
     {
       preamble = WIFI_PREAMBLE_VHT;
     }
@@ -2043,7 +3093,7 @@ MacLow::SendDataPacket (void)
       else if (m_txParams.MustWaitCompressedBlockAck ())
         {
           duration += GetSifs ();
-          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
+          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
         }
       else if (m_txParams.MustWaitAck ())
@@ -2072,7 +3122,7 @@ MacLow::SendDataPacket (void)
       m_currentPacket->AddTrailer (fcs);
     }
 
-  ForwardDown (m_currentPacket, &m_currentHdr, m_currentTxVector, preamble);
+  ForwardDown (m_currentPacket, &m_currentHdr, m_currentTxVector, preamble, m_aggregateQueue);
   m_currentPacket = 0;
 }
 
@@ -2103,7 +3153,11 @@ MacLow::SendCtsToSelf (void)
   WifiTxVector ctsTxVector = GetRtsTxVector (m_currentPacket, &m_currentHdr);
 
   WifiPreamble preamble;
-  if (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
+  if (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
     {
       preamble = WIFI_PREAMBLE_HT_MF;
     }
@@ -2171,7 +3225,7 @@ MacLow::SendCtsToSelf (void)
   WifiMacTrailer fcs;
   packet->AddTrailer (fcs);
 
-  ForwardDown (packet, &cts, ctsTxVector,preamble);
+  ForwardDown (packet, &cts, ctsTxVector,preamble, NULL);
 
   Time txDuration = m_phy->CalculateTxDuration (GetCtsSize (), ctsTxVector, preamble, m_phy->GetFrequency ());
   txDuration += GetSifs ();
@@ -2191,7 +3245,19 @@ MacLow::SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxV
   /* send a CTS when you receive a RTS
    * right after SIFS.
    */
-  WifiTxVector ctsTxVector = GetCtsTxVector (source, rtsTxVector.GetMode ());
+  WifiTxVector ctsTxVector;
+  if (m_stationManager->HasHeSupported())
+    {
+      ctsTxVector = rtsTxVector;
+      SetChannelWidthForRu(ctsTxVector);
+      duration -= GetCtsDuration (ctsTxVector);
+    }
+  else
+    {
+      ctsTxVector = GetCtsTxVector (source, rtsTxVector.GetMode ());
+      duration -= GetCtsDuration (source, rtsTxVector);
+    }
+  duration -= GetSifs ();
   WifiMacHeader cts;
   cts.SetType (WIFI_MAC_CTL_CTS);
   cts.SetDsNotFrom ();
@@ -2199,8 +3265,6 @@ MacLow::SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxV
   cts.SetNoMoreFragments ();
   cts.SetNoRetry ();
   cts.SetAddr1 (source);
-  duration -= GetCtsDuration (source, rtsTxVector);
-  duration -= GetSifs ();
   NS_ASSERT (duration >= MicroSeconds (0));
   cts.SetDuration (duration);
 
@@ -2208,7 +3272,6 @@ MacLow::SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxV
   packet->AddHeader (cts);
   WifiMacTrailer fcs;
   packet->AddTrailer (fcs);
-
   SnrTag tag;
   tag.Set (rtsSnr);
   packet->AddPacketTag (tag);
@@ -2224,7 +3287,8 @@ MacLow::SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxV
     }
 
   //CTS should always use non-HT PPDU (HT PPDU cases not supported yet)
-  ForwardDown (packet, &cts, ctsTxVector, preamble);
+  m_ampdu = false;
+  ForwardDown (packet, &cts, ctsTxVector, preamble, NULL);
 }
 
 void
@@ -2234,6 +3298,11 @@ MacLow::SendDataAfterCts (Mac48Address source, Time duration)
   /* send the third step in a
    * RTS/CTS/DATA/ACK hanshake
    */
+  if (m_isHeMuMpduStarted)
+    {
+      SendHeMuMpdu (duration);
+      return;
+    }
   NS_ASSERT (m_currentPacket != 0);
 
   if (m_aggregateQueue->GetSize () != 0)
@@ -2242,7 +3311,7 @@ MacLow::SendDataAfterCts (Mac48Address source, Time duration)
         {
           uint8_t tid = GetTid (m_txPackets.at (i).packet, m_txPackets.at (i).hdr);
           AcIndex ac = QosUtilsMapTidToAc (tid);
-          std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
+          QueueListenersI  listenerIt = m_edcaListeners.find (std::make_pair(m_txPackets.at (i).hdr.GetAddr1 (), ac));
 
           listenerIt->second->CompleteMpduTx (m_txPackets.at (i).packet, m_txPackets.at (i).hdr, m_txPackets.at (i).timestamp);
         }
@@ -2250,7 +3319,11 @@ MacLow::SendDataAfterCts (Mac48Address source, Time duration)
     }
 
   WifiPreamble preamble;
-  if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
+  if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
     {
       preamble = WIFI_PREAMBLE_VHT;
     }
@@ -2277,13 +3350,13 @@ MacLow::SendDataAfterCts (Mac48Address source, Time duration)
   if (m_txParams.MustWaitBasicBlockAck ())
     {
       newDuration += GetSifs ();
-      WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
+      WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
       newDuration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, BASIC_BLOCK_ACK);
     }
   else if (m_txParams.MustWaitCompressedBlockAck ())
     {
       newDuration += GetSifs ();
-      WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
+      WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
       newDuration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
     }
   else if (m_txParams.MustWaitAck ())
@@ -2298,7 +3371,7 @@ MacLow::SendDataAfterCts (Mac48Address source, Time duration)
       if (m_txParams.MustWaitCompressedBlockAck ())
         {
           newDuration += GetSifs ();
-          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
+          WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentTxVector);
           newDuration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
         }
       else if (m_txParams.MustWaitAck ())
@@ -2323,7 +3396,7 @@ MacLow::SendDataAfterCts (Mac48Address source, Time duration)
       m_currentPacket->AddTrailer (fcs);
     }
 
-  ForwardDown (m_currentPacket, &m_currentHdr, m_currentTxVector, preamble);
+  ForwardDown (m_currentPacket, &m_currentHdr, m_currentTxVector, preamble, m_aggregateQueue);
   m_currentPacket = 0;
 }
 
@@ -2339,6 +3412,221 @@ MacLow::WaitSifsAfterEndTx (void)
   m_listener->StartNext ();
 }
 
+bool
+MacLow::GotCts (double snr, WifiTxVector txVector, Time &ctsDiffDuration)
+{
+  NS_LOG_FUNCTION (this << snr << txVector);
+  NS_LOG_DEBUG ("got cts");
+  HEStationsI it;
+  uint16_t aid = txVector.GetAid();
+  uint16_t gotCts=0;
+  bool ctsDelivered = false;
+
+  if (m_isHeMuMpduStarted == false)
+    {
+      m_ctsTimeoutEvent.Cancel ();
+      NotifyCtsTimeoutResetNow ();
+      m_listener->GotCts(snr,txVector.GetMode());
+      return true;
+    }
+
+  for(it = m_heStations.begin(); it != m_heStations.end(); ++it)
+    {
+      HeMpduItem item = it->second;
+      if(item.listener->GetAid () == aid)
+	{
+	  item.listener->GotCts(snr, txVector.GetMode());
+	  ctsDelivered = true;
+	}
+      if(item.listener->IsCtsReceived())
+	{
+	  gotCts++;
+          ctsDiffDuration = item.ctsDurationDiff;
+	}
+    }
+  if(it == m_heStations.end() && ctsDelivered == false)
+    {
+      NS_LOG_DEBUG ("got cts for unknown station");
+    }
+  if(gotCts == m_heStations.size())
+    {
+      //received CTS from all parties
+      m_ctsTimeoutEvent.Cancel ();
+      NotifyCtsTimeoutResetNow ();
+    }
+  if (gotCts == 1)
+    {
+      return true;
+    }
+  return false;
+}
+
+bool
+MacLow::GotBlockAck(const CtrlBAckResponseHeader *blockAck, WifiMacHeader hdr, double rxSnr, WifiTxVector txVector, double dataSnr)
+{
+  NS_LOG_FUNCTION (this);
+  NS_LOG_DEBUG ("got  Ack");
+
+  HEStationsI it;
+  uint16_t aid = txVector.GetAid();
+
+  uint16_t gotAck=0;
+  bool     retVal = false;
+  bool     ackDelivered = false;
+  uint32_t  blockAckclients = 0;
+  uint16_t  totalAck = 0;
+
+  for(it = m_heStations.begin(); it != m_heStations.end(); it++)
+    {
+      HeMpduItem item = it->second;
+      m_stationManager->ReportRxOk (item.hdr.GetAddr1 (), &item.hdr,
+                                    rxSnr, txVector.GetMode ());
+      m_stationManager->ReportDataOk (item.hdr.GetAddr1 (), &item.hdr,
+                                      rxSnr, txVector.GetMode (), dataSnr);
+      if ((item.params.MustWaitBasicBlockAck () ||  item.params.MustWaitCompressedBlockAck ()) &&
+	  m_blockAckTimeoutEvent.IsRunning ())
+	{
+	  blockAckclients++;
+	  if(item.listener->GetAid () == aid)
+	    {
+	      item.listener->GotBlockAck (blockAck, hdr.GetAddr2 (), rxSnr, txVector.GetMode (), dataSnr);
+	      item.aggQueue->Flush ();
+	      item.isAmpdu = false;
+
+	      ackDelivered = true;
+	    }
+	  if(item.listener->IsAckReceived())
+	    {
+	      gotAck++;
+	    }
+	}
+      if (item.listener->IsAckReceived())
+	{
+	  totalAck++;
+	}
+    }
+  if(ackDelivered == false && it == m_heStations.end())
+    {
+      NS_LOG_DEBUG ("got Ack for unknown station");
+    }
+  if (gotAck == blockAckclients)
+    {
+      m_blockAckTimeoutEvent.Cancel ();
+    }
+  if(gotAck && m_heStations.size() == totalAck)
+    {
+      //received ACK from all parties
+      NotifyAckTimeoutResetNow ();
+      CancelAllEvents();
+      //StartNextHeMuMpdu ();
+      Simulator::Schedule (GetSifs (), &MacLow::StartNextHeMuMpdu, this);
+      retVal = true;
+    }
+  return retVal;
+}
+bool
+MacLow::GotAck (double rxSnr, WifiTxVector txVector, double dataSnr)
+{
+  NS_LOG_FUNCTION (this);
+  NS_LOG_DEBUG ("got  Ack");
+  HEStationsI it;
+  uint16_t aid = txVector.GetAid();
+  uint16_t gotAckClients=0;
+  uint16_t totalAck = 0;
+  bool     retVal = false;
+  bool     ackDelivered = false;
+  uint32_t  normalAckclients = 0;
+
+  if (m_isHeMuMpduStarted == false)
+    {
+      m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
+                                    rxSnr, txVector.GetMode ());
+      m_stationManager->ReportDataOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
+                                      rxSnr, txVector.GetMode (), dataSnr);
+      bool gotAck = false;
+      if (m_txParams.MustWaitNormalAck ()
+          && m_normalAckTimeoutEvent.IsRunning ())
+        {
+          m_normalAckTimeoutEvent.Cancel ();
+          NotifyAckTimeoutResetNow ();
+          gotAck = true;
+        }
+      if (m_txParams.MustWaitFastAck ()
+          && m_fastAckTimeoutEvent.IsRunning ())
+        {
+          m_fastAckTimeoutEvent.Cancel ();
+          NotifyAckTimeoutResetNow ();
+          gotAck = true;
+        }
+      if (gotAck)
+        {
+          m_listener->GotAck (rxSnr, txVector.GetMode ());
+        }
+      else
+	{
+	  std::cout<<"Ack not handled"<<std::endl;
+	}
+      if (m_txParams.HasNextPacket ())
+        {
+          m_waitSifsEvent = Simulator::Schedule (GetSifs (),
+                                                 &MacLow::WaitSifsAfterEndTxFragment, this);
+        }
+      else if (m_currentHdr.IsQosData () && !m_ampdu)
+        {
+          m_waitSifsEvent = Simulator::Schedule (GetSifs (),
+                                                 &MacLow::WaitSifsAfterEndTx, this);
+        }
+
+      FlushAggregateQueue ();
+      m_ampdu = false;
+
+      return true;
+    }
+
+  for(it = m_heStations.begin(); it != m_heStations.end(); it++)
+    {
+      HeMpduItem item = it->second;
+      if ((item.params.MustWaitNormalAck () && m_normalAckTimeoutEvent.IsRunning ()) ||
+	  (item.params.MustWaitCompressedBlockAck () && m_blockAckTimeoutEvent.IsRunning ()))
+	{
+	  normalAckclients++;
+	  if(item.listener->GetAid () == aid)
+	    {
+	      m_stationManager->ReportRxOk (item.hdr.GetAddr1 (), &item.hdr,
+	                                    rxSnr, txVector.GetMode ());
+	      m_stationManager->ReportDataOk (item.hdr.GetAddr1 (), &item.hdr,
+	                                      rxSnr, txVector.GetMode (), dataSnr);
+	      item.listener->GotAck (rxSnr, txVector.GetMode ());
+	      ackDelivered = true;
+	    }
+	  if(item.listener->IsAckReceived())
+	    {
+	      gotAckClients++;
+	    }
+	}
+      if (item.listener->IsAckReceived())
+	{
+	  totalAck++;
+	}
+    }
+  if(ackDelivered == false && it == m_heStations.end())
+    {
+      NS_LOG_DEBUG ("got Ack for unknown station");
+    }
+  if (gotAckClients == normalAckclients)
+    {
+      m_normalAckTimeoutEvent.Cancel ();
+    }
+  if(gotAckClients && m_heStations.size() == totalAck)
+    {
+      //received ACK from all parties
+      NotifyAckTimeoutResetNow ();
+      CancelAllEvents();
+      Simulator::Schedule (GetSifs (), &MacLow::StartNextHeMuMpdu, this);
+      retVal = true;
+    }
+  return retVal;
+}
 void
 MacLow::EndTxNoAck (void)
 {
@@ -2358,11 +3646,24 @@ MacLow::FastAckFailedTimeout (void)
 }
 
 void
-MacLow::SendAckAfterData (Mac48Address source, Time duration, WifiMode dataTxMode, double dataSnr)
+MacLow::SendAckAfterData (Mac48Address source, Time duration, WifiTxVector dataTxVector, double dataSnr)
 {
   NS_LOG_FUNCTION (this);
+  Time now = Simulator::Now();
   // send an ACK, after SIFS, when you receive a packet 
-  WifiTxVector ackTxVector = GetAckTxVector (source, dataTxMode);
+  WifiTxVector ackTxVector;
+
+  if (m_stationManager->HasHeSupported())
+    {
+      ackTxVector = GetAckTxVector (source, dataTxVector.GetMode());
+      ackTxVector.SetAid(GetAid());
+      ackTxVector.SetRu(dataTxVector.GetRu());
+      ackTxVector.SetChannelWidth(dataTxVector.GetChannelWidth());
+    }
+  else
+    {
+      ackTxVector = GetAckTxVector (source, dataTxVector.GetMode());
+    }
   WifiMacHeader ack;
   ack.SetType (WIFI_MAC_CTL_ACK);
   ack.SetDsNotFrom ();
@@ -2381,13 +3682,16 @@ MacLow::SendAckAfterData (Mac48Address source, Time duration, WifiMode dataTxMod
   packet->AddHeader (ack);
   WifiMacTrailer fcs;
   packet->AddTrailer (fcs);
-
   SnrTag tag;
   tag.Set (dataSnr);
   packet->AddPacketTag (tag);
   
   WifiPreamble preamble;
-  if (m_stationManager->GetShortPreambleEnabled ())
+  if (ackTxVector.GetMode().GetModulationClass() == WIFI_MOD_CLASS_HE )
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (m_stationManager->GetShortPreambleEnabled ())
     {
       preamble = WIFI_PREAMBLE_SHORT;
     }
@@ -2397,7 +3701,7 @@ MacLow::SendAckAfterData (Mac48Address source, Time duration, WifiMode dataTxMod
     }
 
   //ACK should always use non-HT PPDU (HT PPDU cases not supported yet)
-  ForwardDown (packet, &ack, ackTxVector, preamble);
+  ForwardDown (packet, &ack, ackTxVector, preamble, NULL);
 }
 
 bool
@@ -2409,7 +3713,12 @@ MacLow::IsInWindow (uint16_t seq, uint16_t winstart, uint16_t winsize)
 bool
 MacLow::ReceiveMpdu (Ptr<Packet> packet, WifiMacHeader hdr)
 {
-  if (m_stationManager->HasHtSupported () || m_stationManager->HasVhtSupported ())
+  if(packet->GetSize() <= WIFI_MAC_FCS_LENGTH)
+    {
+      //Handle NULL frames
+      return true;
+    }
+  if (m_stationManager->HasHtSupported () || m_stationManager->HasVhtSupported () || m_stationManager->HasHeSupported ())
     {
       Mac48Address originator = hdr.GetAddr2 ();
       uint8_t tid = 0;
@@ -2441,6 +3750,10 @@ MacLow::ReceiveMpdu (Ptr<Packet> packet, WifiMacHeader hdr)
               RxCompleteBufferedPacketsUntilFirstLost (originator, tid); //forwards up packets starting from winstart and set winstart to last +1
               (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
             }
+          else
+            {
+//              std::cout << "Drop out of sequence pkt, window start : " << (*it).second.first.GetStartingSequence () << " Rcvd seq num in packet : " << seqNumber <<  " src : "  << hdr.GetAddr2() << " dst : "  << hdr.GetAddr1() <<  " Aid : " << GetAid() << std::endl;
+            }
           return true;
         }
       return false;
@@ -2514,10 +3827,11 @@ MacLow::CreateBlockAckAgreement (const MgtAddBaResponseHeader *respHdr, Mac48Add
       Time timeout = MicroSeconds (1024 * agreement.GetTimeout ());
 
       AcIndex ac = QosUtilsMapTidToAc (agreement.GetTid ());
-
+      QueueListenersI listenerIt = m_edcaListeners.find (std::make_pair (agreement.GetPeer (), ac));
+      NS_ASSERT (listenerIt != m_edcaListeners.end ());
       it->second.first.m_inactivityEvent = Simulator::Schedule (timeout,
                                                                 &MacLowAggregationCapableTransmissionListener::BlockAckInactivityTimeout,
-                                                                m_edcaListeners[ac],
+								listenerIt->second,
                                                                 originator, tid);
     }
 }
@@ -2632,7 +3946,7 @@ MacLow::RxCompleteBufferedPacketsUntilFirstLost (Mac48Address originator, uint8_
 }
 void
 MacLow::SendBlockAckResponse (const CtrlBAckResponseHeader* blockAck, Mac48Address originator, bool immediate,
-                              Time duration, WifiMode blockAckReqTxMode, double rxSnr)
+                              Time duration, WifiMode blockAckReqTxMode, double rxSnr, uint8_t ru)
 {
   Ptr<Packet> packet = Create<Packet> ();
   packet->AddHeader (*blockAck);
@@ -2647,6 +3961,10 @@ MacLow::SendBlockAckResponse (const CtrlBAckResponseHeader* blockAck, Mac48Addre
   hdr.SetNoMoreFragments ();
 
   WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (originator, blockAckReqTxMode);
+  blockAckReqTxVector.SetMode(blockAckReqTxMode);
+  blockAckReqTxVector.SetRu(ru);
+  SetChannelWidthForRu(blockAckReqTxVector);
+  blockAckReqTxVector.SetAid(GetAid ());
 
   m_currentPacket = packet;
   m_currentHdr = hdr;
@@ -2688,7 +4006,11 @@ MacLow::SendBlockAckResponse (const CtrlBAckResponseHeader* blockAck, Mac48Addre
   WifiMacTrailer fcs;
   packet->AddTrailer (fcs);
   WifiPreamble preamble;
-  if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
+  if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+    }
+  else if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
     {
       preamble = WIFI_PREAMBLE_HT_MF;
     }
@@ -2703,7 +4025,7 @@ MacLow::SendBlockAckResponse (const CtrlBAckResponseHeader* blockAck, Mac48Addre
   SnrTag tag;
   tag.Set (rxSnr);
   packet->AddPacketTag (tag);
-  ForwardDown (packet, &hdr, blockAckReqTxVector, preamble);
+  ForwardDown (packet, &hdr, blockAckReqTxVector, preamble, m_aggregateQueue);
   m_currentPacket = 0;
 }
 
@@ -2726,12 +4048,12 @@ MacLow::SendBlockAckAfterAmpdu (uint8_t tid, Mac48Address originator, Time durat
   NS_LOG_DEBUG ("Got Implicit block Ack Req with seq " << seqNumber);
   (*i).second.FillBlockAckBitmap (&blockAck);
 
-  SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxVector.GetMode (), rxSnr);
+  SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxVector.GetMode (), rxSnr, blockAckReqTxVector.GetRu ());
 }
 
 void
 MacLow::SendBlockAckAfterBlockAckRequest (const CtrlBAckRequestHeader reqHdr, Mac48Address originator,
-                                          Time duration, WifiMode blockAckReqTxMode, double rxSnr)
+                                          Time duration, WifiTxVector blockAckTxVector, double rxSnr)
 {
   NS_LOG_FUNCTION (this);
   CtrlBAckResponseHeader blockAck;
@@ -2789,7 +4111,7 @@ MacLow::SendBlockAckAfterBlockAckRequest (const CtrlBAckRequestHeader reqHdr, Ma
       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
     }
 
-  SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxMode, rxSnr);
+  SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckTxVector.GetMode (), rxSnr, blockAckTxVector.GetRu ());
 }
 
 void
@@ -2797,22 +4119,24 @@ MacLow::ResetBlockAckInactivityTimerIfNeeded (BlockAckAgreement &agreement)
 {
   if (agreement.GetTimeout () != 0)
     {
-      NS_ASSERT (agreement.m_inactivityEvent.IsRunning ());
+    //  NS_ASSERT (agreement.m_inactivityEvent.IsRunning ());
       agreement.m_inactivityEvent.Cancel ();
       Time timeout = MicroSeconds (1024 * agreement.GetTimeout ());
       AcIndex ac = QosUtilsMapTidToAc (agreement.GetTid ());
+      QueueListenersI listenerIt = m_edcaListeners.find (std::make_pair (agreement.GetPeer (), ac));
+      NS_ASSERT (listenerIt != m_edcaListeners.end ());
       agreement.m_inactivityEvent = Simulator::Schedule (timeout,
                                                          &MacLowAggregationCapableTransmissionListener::BlockAckInactivityTimeout,
-                                                         m_edcaListeners[ac],
+							 listenerIt->second,
                                                          agreement.GetPeer (),
                                                          agreement.GetTid ());
     }
 }
 
 void
-MacLow::RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowAggregationCapableTransmissionListener *listener)
+MacLow::RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowAggregationCapableTransmissionListener *listener, Mac48Address mac)
 {
-  m_edcaListeners.insert (std::make_pair (ac, listener));
+  m_edcaListeners.insert (std::make_pair (std::make_pair(mac, ac), listener));
 }
 
 void
@@ -2842,7 +4166,7 @@ MacLow::DeaggregateAmpduAndReceive (Ptr<Packet> aggregatedPacket, double rxSnr,
               NS_LOG_DEBUG ("Receive VHT single MPDU");
               ampduSubframe = false;
             }
-          else if (preamble != WIFI_PREAMBLE_NONE || !m_sendAckEvent.IsRunning ())
+          else if (preamble != WIFI_PREAMBLE_NONE)
             {
               m_sendAckEvent = Simulator::Schedule (ampdu.GetRemainingAmpduDuration () + GetSifs (),
                                                     &MacLow::SendBlockAckAfterAmpdu, this,
@@ -2888,7 +4212,6 @@ MacLow::DeaggregateAmpduAndReceive (Ptr<Packet> aggregatedPacket, double rxSnr,
                       /* See section 11.5.3 in IEEE 802.11 for mean of this timer */
                       ResetBlockAckInactivityTimerIfNeeded (it->second.first);
                       NS_LOG_DEBUG ("rx A-MPDU/sendImmediateBlockAck from=" << firsthdr.GetAddr2 ());
-                      NS_ASSERT (m_sendAckEvent.IsRunning ());
                     }
                   else
                     {
@@ -2918,9 +4241,13 @@ MacLow::StopMpduAggregation (Ptr<const Packet> peekedPacket, WifiMacHeader peeke
 
   uint8_t tid = GetTid (peekedPacket, peekedHdr);
   AcIndex ac = QosUtilsMapTidToAc (tid);
-  std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
-
-  if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
+  QueueListeners::const_iterator listenerIt = m_edcaListeners.find (std::make_pair (peekedHdr.GetAddr1 (), ac));
+  if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
+    {
+      preamble = WIFI_PREAMBLE_HE;
+      aPPDUMaxTime = listenerIt->second->GetTxopLimit();
+    }
+  else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
     {
       preamble = WIFI_PREAMBLE_VHT;
       aPPDUMaxTime = MicroSeconds (5484);
@@ -2959,9 +4286,9 @@ MacLow::StopMpduAggregation (Ptr<const Packet> peekedPacket, WifiMacHeader peeke
 }
 
 Ptr<Packet>
-MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
+MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr, Ptr<WifiMacQueue> aggQueue)
 {
-  NS_ASSERT (m_aggregateQueue->GetSize () == 0);
+  NS_ASSERT (aggQueue->GetSize () == 0);
   bool isAmpdu = false;
   Ptr<Packet> newPacket, tempPacket;
   WifiMacHeader peekedHdr;
@@ -2987,7 +4314,7 @@ MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
       Ptr<WifiMacQueue> queue;
       AcIndex ac = QosUtilsMapTidToAc (tid);
       //since a blockack agreement always preceeds mpdu aggregation there should always exist blockAck listener
-      std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
+      QueueListenersI listenerIt = m_edcaListeners.find (std::make_pair (hdr.GetAddr1 (), ac));
       NS_ASSERT (listenerIt != m_edcaListeners.end ());
       queue = listenerIt->second->GetQueue ();
 
@@ -3027,7 +4354,7 @@ MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
                       NS_LOG_DEBUG ("Adding packet with Sequence number " << peekedHdr.GetSequenceNumber () << " to A-MPDU, packet size = " << newPacket->GetSize () << ", A-MPDU size = " << currentAggregatedPacket->GetSize ());
                       i++;
                       m_sentMpdus++;
-                      m_aggregateQueue->Enqueue (aggPacket, peekedHdr);
+                      aggQueue->Enqueue (aggPacket, peekedHdr);
                     }
                 }
               else if (hdr.IsBlockAckReq ())
@@ -3094,7 +4421,8 @@ MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
                   aggregated = listenerIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
                   if (aggregated)
                     {
-                      m_aggregateQueue->Enqueue (aggPacket, peekedHdr);
+                      peekedHdr.SetMultiQueueInfo(hdr);
+                      aggQueue->Enqueue (aggPacket, peekedHdr);
                       if (i == 1 && hdr.IsQosData ())
                         {
                           if (!m_txParams.MustSendRts ())
@@ -3189,7 +4517,8 @@ MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
                       newPacket = packet->Copy ();
                       peekedHdr = hdr;
                       Ptr<Packet> aggPacket = newPacket->Copy ();
-                      m_aggregateQueue->Enqueue (aggPacket, peekedHdr);
+                      peekedHdr.SetMultiQueueInfo(hdr);
+                      aggQueue->Enqueue (aggPacket, peekedHdr);
                       newPacket->AddHeader (peekedHdr);
                       WifiMacTrailer fcs;
                       newPacket->AddTrailer (fcs);
@@ -3214,25 +4543,26 @@ MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
                 }
               else
                 {
-                  uint32_t queueSize = m_aggregateQueue->GetSize ();
+                  uint32_t queueSize = aggQueue->GetSize ();
                   NS_ASSERT (queueSize <= 2); //since it is not an A-MPDU then only 2 packets should have been added to the queue no more
                   if (queueSize >= 1)
                     {
                       //remove any packets that we added to the aggregate queue
-                      FlushAggregateQueue ();
+                      aggQueue->Flush ();
+                      m_txPackets.clear ();
                     }
                 }
             }
           //VHT single MPDU operation
           WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
-          if (!isAmpdu && dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT && hdr.IsQosData ())
+          if (!isAmpdu && hdr.IsQosData () && (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT || dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE))
             {
               peekedHdr = hdr;
               peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
 
               currentAggregatedPacket = Create<Packet> ();
               listenerIt->second->GetMpduAggregator ()->AggregateVhtSingleMpdu (packet, currentAggregatedPacket);
-              m_aggregateQueue->Enqueue (packet, peekedHdr);
+              aggQueue->Enqueue (packet, peekedHdr);
               m_sentMpdus = 1;
 
               if (listenerIt->second->GetBlockAckAgreementExists (hdr.GetAddr1 (), tid))
@@ -3260,6 +4590,10 @@ MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
 void
 MacLow::FlushAggregateQueue (void)
 {
+  if (m_isHeMuMpduStarted)
+    {
+      return;
+    }
   if (m_aggregateQueue->GetSize () > 0)
     {
       NS_LOG_DEBUG ("Flush aggregate queue");
@@ -3290,7 +4624,7 @@ MacLow::PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Ti
 
   Ptr<WifiMacQueue> queue;
   AcIndex ac = QosUtilsMapTidToAc (GetTid (packet, *hdr));
-  std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
+  QueueListenersI listenerIt = m_edcaListeners.find (std::make_pair (hdr->GetAddr1 (), ac));
   NS_ASSERT (listenerIt != m_edcaListeners.end ());
   queue = listenerIt->second->GetQueue ();
 
@@ -3338,4 +4672,10 @@ MacLow::PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Ti
     }
 }
 
+void
+MacLow::HEForwardDown (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble, std::map<uint16_t, uint8_t>   aidRumapList) 
+{
+      m_phy->SendPacket (packet, txVector, preamble);
+}
+ 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/mac-low.h b/ns-3.26/src/wifi/model/mac-low.h
index a660aec..d39653a 100644
--- a/ns-3.26/src/wifi/model/mac-low.h
+++ b/ns-3.26/src/wifi/model/mac-low.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2005, 2006 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,8 +18,21 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
- * Author: Mirko Banchi <mk.banchi@gmail.com>
+ * Authors: Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
+ 
 #ifndef MAC_LOW_H
 #define MAC_LOW_H
 
@@ -45,6 +59,7 @@
 #include "wifi-tx-vector.h"
 #include "mpdu-aggregator.h"
 #include "msdu-aggregator.h"
+#include "ns3/he-bitmap.h"
 
 class TwoLevelAggregationTest;
 class AmpduAggregationTest;
@@ -148,6 +163,19 @@ public:
    *
    */
   virtual void EndTxNoAck (void) = 0;
+  virtual bool IsAckReceived (void);
+  virtual bool IsCtsReceived (void);
+  virtual Ptr<Packet> StartNext (WifiMacHeader *hdr);
+  virtual uint16_t GetAid (void);
+  virtual Ptr<const Packet> GetCurrentPktInQueue(WifiMacHeader *head);
+  virtual bool NeedsAccess (void);
+  virtual void NotifyAccessGranted (WifiTxVector txVector, Time duration);
+  virtual Time PeekFirstPacket(WifiMacHeader *hdr);
+  virtual WifiTxVector GetDataTxVector (void);
+  /**
+   * Returns the EDCA queue to check if there are packets that can be aggregated with a Block Ack
+   */
+  virtual Ptr<WifiMacQueue> GetQueue (void);
 };
 
 
@@ -298,6 +326,9 @@ public:
   /**
    */
   virtual Mac48Address GetDestAddressForAggregation (const WifiMacHeader &hdr);
+  /**
+   */
+  virtual Time GetTxopLimit (void) const;
 };
 
 /**
@@ -507,6 +538,8 @@ public:
    * typedef for a callback for MacLowRx
    */
   typedef Callback<void, Ptr<Packet>, const WifiMacHeader*> MacLowRxCallback;
+  typedef Callback<void, WifiTxVector, Time> OfdmaPktFetchCallback;
+  typedef Callback<void, Time, WifiTxVector, double, Mac48Address> OfdmaPktFetchBsrCallback;
 
   MacLow ();
   virtual ~MacLow ();
@@ -516,7 +549,6 @@ public:
    * \return The TypeId.
    */
   static TypeId GetTypeId (void);
-
   /**
    * Set up WifiPhy associated with this MacLow.
    *
@@ -545,6 +577,12 @@ public:
    * \param ad Mac48Address of this MacLow
    */
   void SetAddress (Mac48Address ad);
+  /**
+   * Set Aid of this MacLow.
+   *
+   * \param aid AID of this MacLow
+   */
+  void SetAid (uint16_t aid);
   /**
    * Set ACK timeout of this MacLow.
    *
@@ -621,6 +659,12 @@ public:
    * \return Mac48Address of this MacLow
    */
   Mac48Address GetAddress (void) const;
+  /**
+   * Return the aid of this MacLow.
+   *
+   * \return aid of this MacLow
+   */
+  uint16_t GetAid (void) const;
   /**
    * Return ACK timeout of this MacLow.
    *
@@ -795,16 +839,17 @@ public:
    * The lifetime of the registered listener is typically equal to the lifetime of the queue
    * associated to this AC.
    */
-  void RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowAggregationCapableTransmissionListener *listener);
+  void RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowAggregationCapableTransmissionListener *listener, Mac48Address mac);
   /**
    * \param packet the packet to be aggregated. If the aggregation is succesfull, it corresponds either to the first data packet that will be aggregated or to the BAR that will be piggybacked at the end of the A-MPDU.
    * \param hdr the WifiMacHeader for the packet.
+   * \param Queue in which aggregaation has to happen
    * \return the A-MPDU packet if aggregation is successfull, the input packet otherwise
    *
    * This function adds the packets that will be added to an A-MPDU to an aggregate queue
    *
    */
-  Ptr<Packet> AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
+  Ptr<Packet> AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr, Ptr<WifiMacQueue> aggQueue);
   /**
    * \param aggregatedPacket which is the current A-MPDU
    * \param rxSnr snr of packet received
@@ -843,7 +888,94 @@ public:
    * \return TXVECTOR for the given packet
    */
   virtual WifiTxVector GetDataTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
+  /**
+   * Send CTS after receiving RTS.
+   *
+   * \param source
+   * \param duration
+   * \param rtsTxVector
+   * \param rtsSnr
+   */
+  void SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
+
+  void SendBsrDataPkt(WifiMacHeader hdr, WifiTxVector txVector, double rxSnr);
+  
+  /**
+   * Checks if the given packet will be aggregated to an A-MPDU or not
+   *
+   * \param packet packet to check whether it can be aggregated in an A-MPDU
+   * \param hdr 802.11 header for packet to check whether it can be aggregated in an A-MPDU
+   *
+   */
+  bool IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
+  /**
+   * Notify DcfManager (via DcfListener) that
+   * CTS timer should be started for the given
+   * duration.
+   *
+   * \param duration
+   */
+  void NotifyCtsTimeoutStartNow (Time duration);
+  /**
+   * Notify DcfManager (via DcfListener) that
+   * ACK timer should be started for the given
+   * duration.
+   *
+   * \param duration
+   */
+  void NotifyAckTimeoutStartNow (Time duration);
+  /**
+   * Notify DcfManager (via DcfListener) that
+   * ACK timer should be resetted.
+   */
+  void NotifyAckTimeoutResetNow ();
+    /**
+   * Notify DcfManager (via DcfListener) that
+   * CTS timer should be resetted.
+   */
+  void NotifyCtsTimeoutResetNow ();
+  /**
+   * Send MU RTS to begin MURTS-CTS-DATA(HE-MU-MPDU)-ACK transaction.
+   */
+  void SendMuRtsForPacket (Time currentSI);
+  /**
+   * Start another HE MU MPDU round
+   */
+  void StartNextHeMuMpdu (void);
 
+  /**
+   * Send BSRP to get the client buffer status. 
+   */
+  void SendBsrpTrigger(staRuMap staMap);
+  /**
+   * Send Basic Trigger to begin Trigger-DATA(TB-MU-MPDU)-ACK transaction.
+   */
+  void SendBasicTrigger(staRuMap staMap, Time duration);
+  /**
+   * Set Resoure Unit allocations in the Phy
+   *  this will set right expectation in the phy Tx/Rx
+   */
+  void SetPhyRuMap(staRuMap staMap);
+  /**
+   * \param callback the callback which Fetches next ofdma packet to be transmitted from station
+   *
+   * This callback typically gets outgoing packets from
+   * an instance of ns3::StaWifiMac.
+   */
+  void SetOfdmaFecthCallback (Callback<void, WifiTxVector, Time> callback);
+  /*  For Bsr */
+  void SetOfdmaFecthBsrCallback (Callback<void, Time , WifiTxVector , double , Mac48Address > callback);
+  /**
+   * Notify the Mac low when it needs to handle HE MU MPDU transmit
+   */
+  void SetOfdmaHeTransmit (bool enable);
+  /**
+   * Notify the Mac low when it needs to handle HE MU MPDU transmit
+   */
+  void SetOfdmaHeTbTransmit (bool enable);
+  double GetHighLoadingAxResourceDL();
+  double GetUsedAxResourceDL();
+  double GetTotalAxResourceDL();
 private:
   /**
    * Cancel all scheduled events. Called before beginning a transmission
@@ -875,6 +1007,8 @@ private:
    * \return the total CTS size
    */
   uint32_t GetCtsSize (void) const;
+  /* Get Bsr Size */
+  uint32_t GetBsrSize (void) const;
   /**
    * Return the total size of the packet after WifiMacHeader and FCS trailer
    * have been added.
@@ -893,7 +1027,9 @@ private:
    * \param preamble
    */
   void ForwardDown (Ptr<const Packet> packet, const WifiMacHeader *hdr,
-                    WifiTxVector txVector, WifiPreamble preamble);
+                    WifiTxVector txVector, WifiPreamble preamble, Ptr<WifiMacQueue> aggQueue);
+  void HEForwardDown (Ptr<const Packet> packet,
+                    WifiTxVector txVector, WifiPreamble preamble, std::map<uint16_t, uint8_t>   aidRumapList);
   /**
    * Forward the MPDU down to WifiPhy for transmission. This is called for each MPDU when MPDU aggregation is used.
    *
@@ -986,6 +1122,8 @@ private:
    * \return the time required to transmit the CTS (including preamble and FCS)
    */
   Time GetCtsDuration (WifiTxVector ctsTxVector) const;
+  /* Return the Bsrp duration for that Tx Vector */
+  Time GetBsrpDuration (WifiTxVector bsrpTxVector) const;
   /**
    * Return the time required to transmit the CTS to the specified address
    * given the TXVECTOR of the RTS (including preamble and FCS).
@@ -1057,32 +1195,6 @@ private:
    *         false otherwise
    */
   bool IsNavZero (void) const;
-  /**
-   * Notify DcfManager (via DcfListener) that
-   * ACK timer should be started for the given
-   * duration.
-   *
-   * \param duration
-   */
-  void NotifyAckTimeoutStartNow (Time duration);
-  /**
-   * Notify DcfManager (via DcfListener) that
-   * ACK timer should be resetted.
-   */
-  void NotifyAckTimeoutResetNow ();
-  /**
-   * Notify DcfManager (via DcfListener) that
-   * CTS timer should be started for the given
-   * duration.
-   *
-   * \param duration
-   */
-  void NotifyCtsTimeoutStartNow (Time duration);
-  /**
-   * Notify DcfManager (via DcfListener) that
-   * CTS timer should be resetted.
-   */
-  void NotifyCtsTimeoutResetNow ();
   /**
    * Reset NAV after CTS was missed when the NAV was
    * setted with RTS.
@@ -1119,15 +1231,6 @@ private:
    * Send CTS for a CTS-to-self mechanism.
    */
   void SendCtsToSelf (void);
-  /**
-   * Send CTS after receiving RTS.
-   *
-   * \param source
-   * \param duration
-   * \param rtsTxVector
-   * \param rtsSnr
-   */
-  void SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
   /**
    * Send ACK after receiving DATA.
    *
@@ -1136,7 +1239,7 @@ private:
    * \param dataTxMode
    * \param dataSnr
    */
-  void SendAckAfterData (Mac48Address source, Time duration, WifiMode dataTxMode, double dataSnr);
+  void SendAckAfterData (Mac48Address source, Time duration, WifiTxVector txVector, double dataSnr);
   /**
    * Send DATA after receiving CTS.
    *
@@ -1160,6 +1263,13 @@ private:
    * Send RTS to begin RTS-CTS-DATA-ACK transaction.
    */
   void SendRtsForPacket (void);
+  /**
+   * Send Data packet TB-HE-MPDU after receiving Trigger frame
+   */
+  void SendDataAfterTrigger (Time duration, WifiTxVector txVector);
+  /* For Bsr */
+  void SendBsrAfterBsrp (Time duration, WifiTxVector txVector, double rxSnr, Mac48Address to);
+
   /**
    * Send DATA packet, which can be DATA-ACK or
    * RTS-CTS-DATA-ACK transaction.
@@ -1235,7 +1345,7 @@ private:
    * \param rxSnr
    */
   void SendBlockAckAfterBlockAckRequest (const CtrlBAckRequestHeader reqHdr, Mac48Address originator,
-                                         Time duration, WifiMode blockAckReqTxMode, double rxSnr);
+                                         Time duration, WifiTxVector blockAckTxVector, double rxSnr);
   /**
    * Invoked after an A-MPDU has been received. Looks for corresponding
    * block ack agreement and creates block ack bitmap on a received packets basis.
@@ -1253,7 +1363,7 @@ private:
    * \param rxSnr
    */
   void SendBlockAckResponse (const CtrlBAckResponseHeader* blockAck, Mac48Address originator, bool immediate,
-                             Time duration, WifiMode blockAckReqTxMode, double rxSnr);
+                             Time duration, WifiMode blockAckReqTxMode, double rxSnr, uint8_t ru);
   /**
    * Every time that a block ack request or a packet with ack policy equals to <i>block ack</i>
    * are received, if a relative block ack agreement exists and the value of inactivity timeout
@@ -1276,14 +1386,6 @@ private:
    * \param phy the WifiPhy this MacLow is connected to
    */
   void RemovePhyMacLowListener (Ptr<WifiPhy> phy);
-  /**
-   * Checks if the given packet will be aggregated to an A-MPDU or not
-   *
-   * \param packet packet to check whether it can be aggregated in an A-MPDU
-   * \param hdr 802.11 header for packet to check whether it can be aggregated in an A-MPDU
-   *
-   */
-  bool IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
   /**
    * Insert in a temporary queue.
    * It is only used with a RTS/CTS exchange for an A-MPDU transmission.
@@ -1301,11 +1403,43 @@ private:
    * \return the aggregate if MSDU aggregation succeeded, 0 otherwise
    */
   Ptr<Packet> PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Time *tstamp, Ptr<Packet> currentAmpduPacket, uint16_t blockAckSize);
+  /**
+   * Invoked when Ack is received for this mac low.
+   */
+  bool GotAck (double rxSnr, WifiTxVector txVector, double dataSnr);
+  /**
+   * Invoked when Ack is received for this mac low.
+   */
+  bool GotCts (double rxSnr, WifiTxVector txVector, Time &ctsDiffDuration);
+  /**
+   * Invoked when Block Ack is received for this mac low.
+   */
+  bool GotBlockAck (const CtrlBAckResponseHeader *blockAck, WifiMacHeader hdr, double rxSnr, WifiTxVector txVector, double dataSnr);
+  /**
+   * Calculate the Max duration required to transmit HE MU MPDU
+   */
+  Time GetMaxDurationForSI(void);
+  Time GetMaxDurationForCts(void);
+  Time GetMaxDurationForAck(void);
+  Time GetMaxDurationForBsr(staRuMap staMap, WifiTxVector bsrpTxVector);
+  WifiTxVector GetBlockAckTxVector (WifiTxVector dataTxVector) const;
+
+  void PadHeMpduIfNeeded (Time duration);
 
   Ptr<WifiPhy> m_phy; //!< Pointer to WifiPhy (actually send/receives frames)
   Ptr<WifiRemoteStationManager> m_stationManager; //!< Pointer to WifiRemoteStationManager (rate control)
   MacLowRxCallback m_rxCallback; //!< Callback to pass packet up
-
+  /**
+   * Is this first packet in the MuMPDU
+   */
+  bool IsFirstHeMuMpdu(WifiMacHeader hdr);
+  /**
+   * Enqueue the PPDUs that are going to be part of HE MU MPDU
+   */
+  void EnqueueToHeMpduList (Ptr<const Packet> packet, const WifiMacHeader* hdr,
+			    MacLowTransmissionParameters params, MacLowTransmissionListener *listener);
+  void SendHeMuMpdu (Time duration);
+  void SetChannelWidthForRu(WifiTxVector &txVector);
   /**
    * A struct for packet, Wifi header, and timestamp.
    */
@@ -1341,12 +1475,15 @@ private:
   EventId m_waitRifsEvent;              //!< Wait for RIFS event
 
   Ptr<Packet> m_currentPacket;              //!< Current packet transmitted/to be transmitted
+  std::map<uint16_t, uint8_t>   aidRumapList;  /* Aid and RU Number bitmap. */ 
+ 
   WifiMacHeader m_currentHdr;               //!< Header of the current transmitted packet
   WifiMacHeader m_lastReceivedHdr;          //!< Header of the last received packet
   MacLowTransmissionParameters m_txParams;  //!< Transmission parameters of the current packet
   MacLowTransmissionListener *m_listener;   //!< Transmission listener for the current packet
   Mac48Address m_self;                      //!< Address of this MacLow (Mac48Address)
   Mac48Address m_bssid;                     //!< BSSID address (Mac48Address)
+  uint16_t     m_aid;                       //!< Aid of this MacLow (Mac48Address)
   Time m_ackTimeout;                        //!< ACK timeout duration
   Time m_basicBlockAckTimeout;              //!< Basic block ACK timeout duration
   Time m_compressedBlockAckTimeout;         //!< Compressed block ACK timeout duration
@@ -1379,10 +1516,31 @@ private:
   typedef std::map<AgreementKey, BlockAckCache> BlockAckCaches;
   typedef std::map<AgreementKey, BlockAckCache>::iterator BlockAckCachesI;
 
+  /**
+   * A helper truct for HE-MU-MPDU.
+   */
+  typedef struct
+  {
+    Ptr<Packet> packet;
+    WifiMacHeader hdr;
+    MacLowTransmissionListener *listener;
+    MacLowTransmissionParameters params;
+    WifiTxVector                 txVector;
+    Ptr<WifiMacQueue>            aggQueue;
+    bool                         isAmpdu;
+    Time                         ctsDurationDiff;
+  } HeMpduItem;
+
+  typedef std::map<Mac48Address, HeMpduItem> HEStations;
+  typedef std::map<Mac48Address, HeMpduItem>::iterator HEStationsI;
+
+
   Agreements m_bAckAgreements;
   BlockAckCaches m_bAckCaches;
 
-  typedef std::map<AcIndex, MacLowAggregationCapableTransmissionListener*> QueueListeners;
+  typedef std::pair<Mac48Address, AcIndex> EdcaListenerKey;
+  typedef std::map<EdcaListenerKey, MacLowAggregationCapableTransmissionListener*> QueueListeners;
+  typedef std::map<EdcaListenerKey, MacLowAggregationCapableTransmissionListener*>::iterator QueueListenersI;
   QueueListeners m_edcaListeners;
   bool m_ctsToSelfSupported;          //!< Flag whether CTS-to-self is supported
   uint8_t m_sentMpdus;                //!< Number of transmitted MPDUs in an A-MPDU that have not been acknowledged yet
@@ -1390,6 +1548,17 @@ private:
   WifiTxVector m_currentTxVector;     //!< TXVECTOR used for the current packet transmission
   std::vector<Item> m_txPackets;      //!< Contain temporary items to be sent with the next A-MPDU transmission, once RTS/CTS exchange has succeeded. It is not used in other cases.
   uint32_t m_nTxMpdus;                //!<Holds the number of transmitted MPDUs in the last A-MPDU transmission
+  HEStations        m_heStations;
+  bool              m_isHeMuMpduStarted;
+  bool              m_isHeMuTbMpduStarted;
+  Time              m_tbMpduDuration;
+  Time              m_currentSI;
+  OfdmaPktFetchCallback m_ofdmaFetchCallback; //!< Callback to pass packet up
+  OfdmaPktFetchBsrCallback m_ofdmaFetchBsrCallback; //!< Callback to pass packet up
+  Ptr<HEBitMap> m_ruBitmap;
+  double m_highLoadingAxResourceDL;
+  double m_usedAxResourceDL;
+  double m_totalAxResourceDL;
 };
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/mgt-headers.cc b/ns-3.26/src/wifi/model/mgt-headers.cc
index d46e3b5..bb879d2 100644
--- a/ns-3.26/src/wifi/model/mgt-headers.cc
+++ b/ns-3.26/src/wifi/model/mgt-headers.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,15 +19,31 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include <sstream>
 #include "mgt-headers.h"
 #include "ns3/simulator.h"
 #include "ns3/assert.h"
+#include "ns3/log.h"
+
 
 namespace ns3 {
 
+NS_LOG_COMPONENT_DEFINE ("MgtHeaders");
+
 /***********************************************************
  *          Probe Request
  ***********************************************************/
@@ -662,6 +679,30 @@ MgtAssocResponseHeader::SetEdcaParameterSet (EdcaParameterSet edcaparameters)
   m_edcaParameterSet = edcaparameters;
 }
 
+void
+MgtAssocResponseHeader::SetAid (uint16_t aid)
+{
+  m_aid = aid;
+}
+
+uint16_t
+MgtAssocResponseHeader::GetAid ()
+{
+  return m_aid;
+}
+
+void
+MgtAssocResponseHeader::SetColor (uint8_t color)
+{
+  m_color = color;
+}
+
+uint8_t
+MgtAssocResponseHeader::GetColor ()
+{
+  return m_color;
+}
+
 EdcaParameterSet
 MgtAssocResponseHeader::GetEdcaParameterSet (void) const
 {
@@ -699,6 +740,7 @@ MgtAssocResponseHeader::GetSerializedSize (void) const
   size += m_htCapability.GetSerializedSize ();
   size += m_htOperations.GetSerializedSize ();
   size += m_vhtCapability.GetSerializedSize ();
+  size += 1; // for color
   return size;
 }
 
@@ -727,6 +769,7 @@ MgtAssocResponseHeader::Serialize (Buffer::Iterator start) const
   i = m_htCapability.Serialize (i);
   i = m_htOperations.Serialize (i);
   i = m_vhtCapability.Serialize (i);
+  i.WriteU8 (m_color);
 }
 
 uint32_t
@@ -743,6 +786,7 @@ MgtAssocResponseHeader::Deserialize (Buffer::Iterator start)
   i = m_htCapability.DeserializeIfPresent (i);
   i = m_htOperations.DeserializeIfPresent (i);
   i = m_vhtCapability.DeserializeIfPresent (i);
+  m_color = i.ReadU8();
   return i.GetDistanceFrom (start);
 }
 
diff --git a/ns-3.26/src/wifi/model/mgt-headers.h b/ns-3.26/src/wifi/model/mgt-headers.h
index c17bb3b..fbe0d4e 100644
--- a/ns-3.26/src/wifi/model/mgt-headers.h
+++ b/ns-3.26/src/wifi/model/mgt-headers.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not 
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef MGT_HEADERS_H
@@ -251,6 +264,31 @@ public:
    */
   void SetEdcaParameterSet (EdcaParameterSet edcaParameterSet);
 
+  /**
+   * Set Aid allocated to the station
+   *
+   * \param aid the aid allocated to the station
+   */
+  void SetAid (uint16_t aid);
+
+  /**
+   * Get Aid allocated to the station
+   */
+  uint16_t GetAid();
+
+  /**
+   * Set Color allocated to the BSS
+   *
+   * \param color the color allocated to the BSS
+   */
+  void SetColor (uint8_t color);
+
+  /**
+   * Get Color allocated to the BSS
+   */
+  uint8_t GetColor();
+
+
   /**
    * Register this type.
    * \return The TypeId.
@@ -268,6 +306,7 @@ private:
   CapabilityInformation m_capability; //!< Capability information
   StatusCode m_code; //!< Status code
   uint16_t m_aid;
+  uint8_t  m_color;
   HtCapabilities m_htCapability; //!< HT capabilities
   HtOperations m_htOperations; //!< HT operations
   VhtCapabilities m_vhtCapability; //!< VHT capabilities
diff --git a/ns-3.26/src/wifi/model/mpdu-aggregator.cc b/ns-3.26/src/wifi/model/mpdu-aggregator.cc
index 902c7bc..a12398a 100644
--- a/ns-3.26/src/wifi/model/mpdu-aggregator.cc
+++ b/ns-3.26/src/wifi/model/mpdu-aggregator.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2013
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Ghada Badawy <gbadawy@gmail.com>
+ * Authors: Ghada Badawy <gbadawy@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/log.h"
@@ -70,6 +83,11 @@ MpduAggregator::Deaggregate (Ptr<Packet> aggregatedPacket)
 
       std::pair<Ptr<Packet>, AmpduSubframeHeader> packetHdr (extractedMpdu, hdr);
       set.push_back (packetHdr);
+      if (maxSize - deserialized < 4)
+	{
+	  // These may be sync(pad) bytes added by station for timing alignment
+	  break;
+	}
     }
   NS_LOG_INFO ("Deaggreated A-MPDU: extracted " << set.size () << " MPDUs");
   return set;
diff --git a/ns-3.26/src/wifi/model/mpdu-standard-aggregator.cc b/ns-3.26/src/wifi/model/mpdu-standard-aggregator.cc
index a440094..f7316df 100644
--- a/ns-3.26/src/wifi/model/mpdu-standard-aggregator.cc
+++ b/ns-3.26/src/wifi/model/mpdu-standard-aggregator.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2013
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Ghada Badawy <gbadawy@gmail.com>
+ * Authors: Ghada Badawy <gbadawy@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/log.h"
@@ -127,13 +140,14 @@ MpduStandardAggregator::AddHeaderAndPad (Ptr<Packet> packet, bool last, bool vht
   //done before when deciding how many packets to add to the queue
   currentHdr.SetCrc (1);
   currentHdr.SetSig ();
-  currentHdr.SetLength (packet->GetSize ());
+  currentHdr.SetLength (packet->GetSize () - packet->GetPadSize ());
   if (vhtSingleMpdu)
     {
       currentHdr.SetEof (1);
     }
 
   packet->AddHeader (currentHdr);
+#if 0
   uint32_t padding = CalculatePadding (packet);
 
   if (padding && !last)
@@ -141,6 +155,7 @@ MpduStandardAggregator::AddHeaderAndPad (Ptr<Packet> packet, bool last, bool vht
       Ptr<Packet> pad = Create<Packet> (padding);
       packet->AddAtEnd (pad);
     }
+#endif
 }
 
 bool
diff --git a/ns-3.26/src/wifi/model/msdu-standard-aggregator.cc b/ns-3.26/src/wifi/model/msdu-standard-aggregator.cc
index 6306815..013868a 100644
--- a/ns-3.26/src/wifi/model/msdu-standard-aggregator.cc
+++ b/ns-3.26/src/wifi/model/msdu-standard-aggregator.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,18 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/log.h"
@@ -37,7 +50,7 @@ MsduStandardAggregator::GetTypeId (void)
     .SetGroupName ("Wifi")
     .AddConstructor<MsduStandardAggregator> ()
     .AddAttribute ("MaxAmsduSize", "Max length in byte of an A-MSDU (Deprecated!)",
-                   UintegerValue (7935),
+                   UintegerValue (0),
                    MakeUintegerAccessor (&MsduStandardAggregator::m_maxAmsduLength),
                    MakeUintegerChecker<uint32_t> ())
   ;
diff --git a/ns-3.26/src/wifi/model/nist-error-rate-model.cc b/ns-3.26/src/wifi/model/nist-error-rate-model.cc
index b16c663..bf4f5e6 100644
--- a/ns-3.26/src/wifi/model/nist-error-rate-model.cc
+++ b/ns-3.26/src/wifi/model/nist-error-rate-model.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 The Boeing Company
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Gary Pei <guangyu.pei@boeing.com>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include <cmath>
@@ -253,7 +266,8 @@ NistErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, d
   if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM
       || mode.GetModulationClass () == WIFI_MOD_CLASS_OFDM
       || mode.GetModulationClass () == WIFI_MOD_CLASS_HT
-      || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
+      || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT
+      || mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
     {
       if (mode.GetConstellationSize () == 2)
         {
diff --git a/ns-3.26/src/wifi/model/qos-blocked-destinations.cc b/ns-3.26/src/wifi/model/qos-blocked-destinations.cc
index 464fd0b..29652f2 100644
--- a/ns-3.26/src/wifi/model/qos-blocked-destinations.cc
+++ b/ns-3.26/src/wifi/model/qos-blocked-destinations.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2005, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,9 +18,22 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "qos-blocked-destinations.h"
+#include "ns3/simulator.h"
 
 namespace ns3 {
 
@@ -50,6 +64,7 @@ QosBlockedDestinations::Block (Mac48Address dest, uint8_t tid)
   if (!IsBlocked (dest, tid))
     {
       m_blockedQosPackets.push_back (std::make_pair (dest, tid));
+      Simulator::Schedule (MilliSeconds(2), &QosBlockedDestinations::Unblock, this, dest, tid);
     }
 }
 
diff --git a/ns-3.26/src/wifi/model/regular-wifi-mac.cc b/ns-3.26/src/wifi/model/regular-wifi-mac.cc
index 3e36f38..0d8c3bb 100644
--- a/ns-3.26/src/wifi/model/regular-wifi-mac.cc
+++ b/ns-3.26/src/wifi/model/regular-wifi-mac.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2008 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "regular-wifi-mac.h"
@@ -43,7 +56,8 @@ RegularWifiMac::RegularWifiMac () :
   m_htSupported (0),
   m_vhtSupported (0),
   m_erpSupported (0),
-  m_dsssSupported (0)
+  m_dsssSupported (0),
+  m_heSupported (0)
 {
   NS_LOG_FUNCTION (this);
   m_rxMiddle = new MacRxMiddle ();
@@ -53,7 +67,6 @@ RegularWifiMac::RegularWifiMac () :
 
   m_low = CreateObject<MacLow> ();
   m_low->SetRxCallback (MakeCallback (&MacRxMiddle::Receive, m_rxMiddle));
-
   m_dcfManager = new DcfManager ();
   m_dcfManager->SetupLowListener (m_low);
 
@@ -125,10 +138,10 @@ RegularWifiMac::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> stati
   m_stationManager = stationManager;
   m_stationManager->SetHtSupported (GetHtSupported ());
   m_stationManager->SetVhtSupported (GetVhtSupported ());
+  m_stationManager->SetHeSupported (GetHeSupported ());
   m_low->SetWifiRemoteStationManager (stationManager);
 
   m_dca->SetWifiRemoteStationManager (stationManager);
-
   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
     {
       i->second->SetWifiRemoteStationManager (stationManager);
@@ -359,7 +372,7 @@ RegularWifiMac::SetupEdcaQueue (enum AcIndex ac)
   edca->SetTxOkCallback (MakeCallback (&RegularWifiMac::TxOk, this));
   edca->SetTxFailedCallback (MakeCallback (&RegularWifiMac::TxFailed, this));
   edca->SetAccessCategory (ac);
-  edca->CompleteConfig ();
+ // edca->CompleteConfig ();
 
   m_edca.insert (std::make_pair (ac, edca));
 }
@@ -411,6 +424,7 @@ RegularWifiMac::SetWifiPhy (Ptr<WifiPhy> phy)
   m_phy = phy;
   m_dcfManager->SetupPhyListener (phy);
   m_low->SetPhy (phy);
+  m_phy->SetAid(0);
 }
 
 Ptr<WifiPhy>
@@ -420,6 +434,13 @@ RegularWifiMac::GetWifiPhy (void) const
   return m_phy;
 }
 
+Ptr<MacLow>
+RegularWifiMac::GetMacLow (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_low;
+}
+
 void
 RegularWifiMac::ResetWifiPhy (void)
 {
@@ -472,7 +493,7 @@ RegularWifiMac::SetHtSupported (bool enable)
     {
       SetQosSupported (true);
     }
-  if (!enable && !m_vhtSupported)
+  if (!enable && !m_vhtSupported && !m_heSupported)
     {
       DisableAggregation ();
     }
@@ -497,7 +518,7 @@ RegularWifiMac::SetVhtSupported (bool enable)
     {
       SetQosSupported (true);
     }
-  if (!enable && !m_htSupported)
+  if (!enable && !m_htSupported && !m_heSupported)
     {
       DisableAggregation ();
     }
@@ -507,6 +528,40 @@ RegularWifiMac::SetVhtSupported (bool enable)
     }
 }
 
+bool
+RegularWifiMac::GetHeSupported () const
+{
+  return m_heSupported;
+}
+
+void
+RegularWifiMac::SetHeSupported (bool enable)
+{
+  NS_LOG_FUNCTION (this << enable);
+  m_heSupported = enable;
+  if (enable)
+    {
+      SetQosSupported (true);
+    }
+  if (!enable && !m_htSupported && !m_vhtSupported)
+    {
+      // Disable aggregation when no HT/VHT/HE is enabled
+      DisableAggregation ();
+    }
+  else
+    {
+      EnableAggregation ();
+    }
+  for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
+    {
+      if (m_heSupported == true && i->second->GetTypeOfStation() == STA)
+	{
+	  i->second->SetHeSupported(true);
+	  i->second->SetAid(GetBssid(), 0);
+	}
+    }
+}
+
 bool
 RegularWifiMac::GetHtSupported () const
 {
@@ -953,6 +1008,12 @@ RegularWifiMac::GetTypeId (void)
                    MakeBooleanAccessor (&RegularWifiMac::SetVhtSupported,
                                         &RegularWifiMac::GetVhtSupported),
                    MakeBooleanChecker ())
+    .AddAttribute ("HeSupported",
+                   "This Boolean attribute is set to enable 802.11ax support at this STA.",
+                   BooleanValue (false),
+                   MakeBooleanAccessor (&RegularWifiMac::SetHeSupported,
+                                        &RegularWifiMac::GetHeSupported),
+                   MakeBooleanChecker ())
     .AddAttribute ("CtsToSelfSupported",
                    "Use CTS to Self when using a rate that is not in the basic rate set.",
                    BooleanValue (false),
@@ -1109,7 +1170,7 @@ RegularWifiMac::FinishConfigureStandard (enum WifiPhyStandard standard)
     case WIFI_PHY_STANDARD_80211ac:
       SetVhtSupported (true);
     case WIFI_PHY_STANDARD_80211n_5GHZ:
-      SetHtSupported (true);
+      SetHtSupported (false);
       cwmin = 15;
       cwmax = 1023;
       break;
@@ -1129,6 +1190,12 @@ RegularWifiMac::FinishConfigureStandard (enum WifiPhyStandard standard)
       cwmin = 31;
       cwmax = 1023;
       break;
+    case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
+    case WIFI_PHY_STANDARD_80211ax_5GHZ:
+      cwmin = 15;
+      cwmax = 1023;
+      SetHeSupported (true);
+      break;
     default:
       NS_FATAL_ERROR ("Unsupported WifiPhyStandard in RegularWifiMac::FinishConfigureStandard ()");
     }
@@ -1165,6 +1232,7 @@ RegularWifiMac::TxFailed (const WifiMacHeader &hdr)
   m_txErrCallback (hdr);
 }
 
+
 void
 RegularWifiMac::ConfigureAggregation (void)
 {
diff --git a/ns-3.26/src/wifi/model/regular-wifi-mac.h b/ns-3.26/src/wifi/model/regular-wifi-mac.h
index b259f2a..7c33368 100644
--- a/ns-3.26/src/wifi/model/regular-wifi-mac.h
+++ b/ns-3.26/src/wifi/model/regular-wifi-mac.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2008 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef REGULAR_WIFI_MAC_H
@@ -208,6 +221,10 @@ public:
    * \return the physical layer attached to this MAC.
    */
   virtual Ptr<WifiPhy> GetWifiPhy (void) const;
+  /**
+   * \return the physical layer attached to this MAC.
+   */
+  virtual Ptr<MacLow> GetMacLow (void) const;
   /**
    * removes attached WifiPhy device from this MAC.
    */
@@ -265,6 +282,14 @@ public:
   virtual Time GetCompressedBlockAckTimeout (void) const;
 
 
+  /** This type defines a mapping between an Access Category index,
+  and a pointer to the corresponding channel access function */
+  typedef std::map<AcIndex, Ptr<EdcaTxopN> > EdcaQueues;
+
+  /** This is a map from Access Category index to the corresponding
+  channel access function */
+  EdcaQueues m_edca;
+
 protected:
   virtual void DoInitialize ();
   virtual void DoDispose ();
@@ -287,14 +312,6 @@ protected:
   for transmission of frames to non-QoS peers. */
   Ptr<DcaTxop> m_dca;
 
-  /** This type defines a mapping between an Access Category index,
-  and a pointer to the corresponding channel access function */
-  typedef std::map<AcIndex, Ptr<EdcaTxopN> > EdcaQueues;
-
-  /** This is a map from Access Category index to the corresponding
-  channel access function */
-  EdcaQueues m_edca;
-
   /**
    * Accessor for the DCF object
    *
@@ -528,6 +545,20 @@ protected:
    */
   bool GetDsssSupported () const;
 
+  bool m_heSupported;
+  void SetHeSupported (bool enable);
+  bool GetHeSupported () const;
+
+  uint32_t m_voMaxAmsduSize;
+  uint32_t m_viMaxAmsduSize;
+  uint32_t m_beMaxAmsduSize;
+  uint32_t m_bkMaxAmsduSize;
+
+  uint32_t m_voMaxAmpduSize;
+  uint32_t m_viMaxAmpduSize;
+  uint32_t m_beMaxAmpduSize;
+  uint32_t m_bkMaxAmpduSize;
+
 
 private:
   RegularWifiMac (const RegularWifiMac &);
@@ -565,16 +596,6 @@ private:
   void EnableAggregation (void);
   void DisableAggregation (void);
 
-  uint32_t m_voMaxAmsduSize;
-  uint32_t m_viMaxAmsduSize;
-  uint32_t m_beMaxAmsduSize;
-  uint32_t m_bkMaxAmsduSize;
-
-  uint32_t m_voMaxAmpduSize;
-  uint32_t m_viMaxAmpduSize;
-  uint32_t m_beMaxAmpduSize;
-  uint32_t m_bkMaxAmpduSize;
-
   TracedCallback<const WifiMacHeader &> m_txOkCallback;
   TracedCallback<const WifiMacHeader &> m_txErrCallback;
   
diff --git a/ns-3.26/src/wifi/model/spectrum-wifi-phy.cc b/ns-3.26/src/wifi/model/spectrum-wifi-phy.cc
index c0df668..423c9c2 100644
--- a/ns-3.26/src/wifi/model/spectrum-wifi-phy.cc
+++ b/ns-3.26/src/wifi/model/spectrum-wifi-phy.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -21,6 +22,18 @@
  *
  * Ported from yans-wifi-phy.cc by several contributors starting
  * with Nicola Baldo and Dean Armstrong
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "spectrum-wifi-phy.h"
@@ -803,7 +816,7 @@ SpectrumWifiPhy::EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enu
         {
           /* failure. */
           NotifyRxDrop (packet);
-          m_state->SwitchFromRxEndError (packet, snrPer.snr);
+          m_state->SwitchFromRxEndError (packet, snrPer.snr, event->GetTxVector());
           rxSucceeded = false;
         }
       if (!m_rxCallback.IsNull ())
@@ -813,7 +826,7 @@ SpectrumWifiPhy::EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enu
     }
   else
     {
-      m_state->SwitchFromRxEndError (packet, snrPer.snr);
+      m_state->SwitchFromRxEndError (packet, snrPer.snr, event->GetTxVector());
       if (!m_rxCallback.IsNull ())
         {
           m_rxCallback (false);
diff --git a/ns-3.26/src/wifi/model/sta-wifi-mac.cc b/ns-3.26/src/wifi/model/sta-wifi-mac.cc
index 8ac8cd2..65b4fa5 100644
--- a/ns-3.26/src/wifi/model/sta-wifi-mac.cc
+++ b/ns-3.26/src/wifi/model/sta-wifi-mac.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "sta-wifi-mac.h"
@@ -38,6 +51,7 @@
 #include "ht-capabilities.h"
 #include "ht-operations.h"
 #include "vht-capabilities.h"
+#include "wifi-mac-queue.h"
 
 /*
  * The state machine for this STA is:
@@ -112,6 +126,46 @@ StaWifiMac::StaWifiMac ()
   //Let the lower layers know that we are acting as a non-AP STA in
   //an infrastructure BSS.
   SetTypeOfStation (STA);
+  m_low->SetOfdmaFecthCallback(MakeCallback (&StaWifiMac::FetchOfdmaPacket, this));
+  m_low->SetOfdmaFecthBsrCallback(MakeCallback (&StaWifiMac::FetchOfdmaBsrPacket, this));
+  m_highLoadingAxResourceUL = 0;
+  m_usedAxResourceUL = 0;
+}
+
+double
+StaWifiMac::GetAfterQueueDrop(uint32_t acIndex)
+{
+  double drop = 0;
+  for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i){
+    uint32_t t_ac = i->second->GetAc();
+    if (t_ac == acIndex)
+      drop =  i->second->GetEdcaQueue()->GetAfterQueueDropCount();
+  }
+  return drop;
+}
+
+double
+StaWifiMac::GetBeforeQueueDrop(uint32_t acIndex)
+{
+  double drop = 0;
+  for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i){
+    uint32_t t_ac = i->second->GetAc();
+    if (t_ac == acIndex)
+      drop = i->second->GetEdcaQueue()->GetBeforeQueueDropCount();
+  }
+  return drop;
+}
+
+double
+StaWifiMac::GetHighLoadingAxResourceUL()
+{
+  return m_highLoadingAxResourceUL;
+}
+
+double
+StaWifiMac::GetUsedAxResourceUL()
+{
+  return m_usedAxResourceUL;
 }
 
 StaWifiMac::~StaWifiMac ()
@@ -343,6 +397,7 @@ StaWifiMac::RestartBeaconWatchdog (Time delay)
 bool
 StaWifiMac::IsAssociated (void) const
 {
+//  return true; //XXX: Lets make every one associatd til we have beacons
   return m_state == ASSOCIATED;
 }
 
@@ -453,7 +508,8 @@ StaWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
           NotifyRxDrop (packet);
           return;
         }
-      if (hdr->GetAddr2 () != GetBssid ())
+      if (hdr->GetAddr2 () != GetBssid ())  //Rama_tbd
+      //if (hdr->GetAddr2 () != Mac48Address ("00:00:00:00:00:02"))
         {
           NS_LOG_LOGIC ("Received data frame not from the BSS we are associated with: ignore");
           NotifyRxDrop (packet);
@@ -667,6 +723,12 @@ StaWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
               NS_LOG_DEBUG ("assoc completed");
               CapabilityInformation capabilities = assocResp.GetCapabilities ();
               SupportedRates rates = assocResp.GetSupportedRates ();
+              uint16_t aid=assocResp.GetAid();
+              uint8_t color=assocResp.GetColor();
+              m_phy->SetAid(aid);
+              m_phy->SetColor(color);
+              m_low->SetAid(aid);
+
               bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
               if (m_erpSupported)
                 {
@@ -840,6 +902,137 @@ StaWifiMac::SetEdcaParameters (AcIndex ac, uint8_t cwMin, uint8_t cwMax, uint8_t
   edca->SetMaxCw (cwMax);
   edca->SetAifsn (aifsn);
   edca->SetTxopLimit (txopLimit);
+  edca->SetAid(GetBssid (), 0);
+  edca->CompleteConfig();
+}
+
+void
+StaWifiMac::FetchOfdmaPacket(WifiTxVector txVector, Time duration)
+{
+  double numSubCarriers = 0;
+  uint32_t t_ac, mcs;
+  NS_LOG_FUNCTION (this);
+
+  for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
+    {
+      if (i->second->NeedsAccess ())
+	{
+	  txVector.SetAid(m_low->GetAid());
+	//  txVector.SetRu(m_low->GetAid()); // XXX: TDB , this need to be derived from trigger
+          if (txVector.GetChannelWidth() == 2)
+            numSubCarriers = 26;
+          else if (txVector.GetChannelWidth() == 4)
+            numSubCarriers = 52;
+          else if (txVector.GetChannelWidth() == 8)
+            numSubCarriers = 106;
+          else if (txVector.GetChannelWidth() == 20)
+            numSubCarriers = 242;
+          else
+            numSubCarriers = 0;
+          t_ac = i->second->GetAc();
+          mcs = txVector.GetMode().GetMcsValue();
+
+          if((t_ac == AC_VI || t_ac == AC_VO) || mcs < 3){
+            if(Now()>Seconds(2.0))
+              m_highLoadingAxResourceUL = m_highLoadingAxResourceUL + 5.472*numSubCarriers;
+          }
+          if(Now()>Seconds(2.0)){
+            m_usedAxResourceUL = m_usedAxResourceUL + 5.472*numSubCarriers;
+          }
+
+	  WifiMacHeader hdr;
+	  if (!i->second->GetEdcaQueue()->IsEmpty())
+	    {
+	      Ptr<const Packet> pkt = i->second->GetEdcaQueue()->Dequeue(&hdr);
+	      hdr.SetQosTxopLimit ( i->second->GetEdcaQueueSize ());
+	      SetMultiTidBSRinHtControl (hdr);
+	      i->second->GetEdcaQueue()->PushFront(pkt, hdr);
+	    }
+	  i->second->NotifyAccessGranted (txVector, duration);
+	  break;
+	}
+    }
+}
+
+void
+StaWifiMac::SetMultiTidBSRinHtControl (WifiMacHeader &hdr)
+{
+  for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
+    {
+      AcIndex ac;
+      uint8_t qsize = i->second->GetEdcaQueueSize (ac);
+      if (qsize >= 0x3f)
+	{
+	  qsize = 0x3f;
+	}
+      switch (ac)
+        {
+	case AC_VO:
+	  hdr.SetVOSize(qsize);
+	  break;
+	case AC_VI:
+	  hdr.SetVISize(qsize);
+	  break;
+	case AC_BE:
+	  hdr.SetBESize(qsize);
+	  break;
+	case AC_BK:
+	  hdr.SetBKSize(qsize);
+	  break;
+	default:
+	  NS_ASSERT("Invalid access class");
+	  return;
+        }
+    }
+}
+
+void
+StaWifiMac::SetBSRinHtControl (WifiMacHeader &hdr)
+{
+  uint32_t maxQueueSf = 0;
+  uint32_t queueSf = 0, totalSf = 0;
+  uint8_t  aciBitmap = 0, bsrAc = 0, maxAc = 0;
+
+  for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
+  {
+      queueSf = i->second->GetQueueInfoSf (bsrAc);
+      if(queueSf != 0) {
+          aciBitmap = aciBitmap | (1 << bsrAc);
+      }
+      if(maxQueueSf < queueSf) { 
+          maxAc = bsrAc;
+          maxQueueSf = queueSf;
+      }
+      totalSf += queueSf;
+  }
+  hdr.UpdateControlHeaderBsrp(aciBitmap, maxAc, maxQueueSf, totalSf);
+}
+
+void
+StaWifiMac::FetchOfdmaBsrPacket(Time duration, WifiTxVector txVector, double rxSnr, Mac48Address to)
+{
+  NS_LOG_FUNCTION (this);
+  WifiMacHeader hdr;
+
+  hdr.SetType (WIFI_MAC_QOSDATA);
+  hdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
+  hdr.SetQosNoEosp ();
+  hdr.SetQosNoAmsdu ();
+  hdr.SetNoRetry();
+  hdr.SetQosTxopLimit (0);
+  hdr.SetQosTid (0);
+  hdr.SetOrder ();
+
+  hdr.SetAddr1 (to);
+  hdr.SetAddr2 (GetAddress ());
+  hdr.SetAddr3 (GetBssid ());
+  hdr.SetDsTo ();
+  hdr.SetDsNotFrom ();
+  NS_ASSERT (duration >= MicroSeconds (0));
+  hdr.SetDuration (duration);
+  SetBSRinHtControl (hdr);
+  m_low->SendBsrDataPkt(hdr, txVector, rxSnr);
+  return;
 }
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/sta-wifi-mac.h b/ns-3.26/src/wifi/model/sta-wifi-mac.h
index 6c51361..9f1e4d8 100644
--- a/ns-3.26/src/wifi/model/sta-wifi-mac.h
+++ b/ns-3.26/src/wifi/model/sta-wifi-mac.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,7 +19,20 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
+
 #ifndef STA_WIFI_MAC_H
 #define STA_WIFI_MAC_H
 
@@ -81,6 +95,11 @@ public:
    * Start an active association sequence immediately.
    */
   void StartActiveAssociation (void);
+  double GetAfterQueueDrop(uint32_t acIndex);
+  double GetBeforeQueueDrop(uint32_t acIndex);
+  double GetHighLoadingAxResourceUL(void);
+  double GetUsedAxResourceUL(void);
+  double GetTotalAxResourceUL(void);
 
 
 private:
@@ -181,6 +200,16 @@ private:
    * \param txopLimit the TXOP limit
    */
   void SetEdcaParameters (AcIndex ac, uint8_t cwMin, uint8_t cwMax, uint8_t aifsn, Time txopLimit);
+  /**
+   * this callback causes one of the edca-txop-n to get notified of Access for OFDMA packet transmit
+   */
+  void FetchOfdmaPacket(WifiTxVector txVector, Time duration);
+  /* For Bsr info response. */
+  void FetchOfdmaBsrPacket(Time duration, WifiTxVector txVector, double rxSnr, Mac48Address to);
+  /* Polulate BSR filed in HT control */
+  void SetBSRinHtControl (WifiMacHeader &hdr);
+  void SetMultiTidBSRinHtControl (WifiMacHeader &hdr);
+
   /**
    * Return the Capability information of the current STA.
    *
@@ -197,6 +226,8 @@ private:
   Time m_beaconWatchdogEnd;
   uint32_t m_maxMissedBeacons;
   bool m_activeProbing;
+  double m_highLoadingAxResourceUL;
+  double m_usedAxResourceUL;
 
   TracedCallback<Mac48Address> m_assocLogger;
   TracedCallback<Mac48Address> m_deAssocLogger;
diff --git a/ns-3.26/src/wifi/model/supported-rates.cc b/ns-3.26/src/wifi/model/supported-rates.cc
index 11feac3..f70fd48 100644
--- a/ns-3.26/src/wifi/model/supported-rates.cc
+++ b/ns-3.26/src/wifi/model/supported-rates.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "supported-rates.h"
@@ -28,6 +41,7 @@ NS_LOG_COMPONENT_DEFINE ("SupportedRates");
 
 #define BSS_MEMBERSHIP_SELECTOR_HT_PHY 127
 #define BSS_MEMBERSHIP_SELECTOR_VHT_PHY 126
+#define BSS_MEMBERSHIP_SELECTOR_HE_PHY 125
 
 SupportedRates::SupportedRates ()
   : extended (this),
@@ -114,7 +128,7 @@ void
 SupportedRates::AddBssMembershipSelectorRate (uint32_t bs)
 {
   NS_LOG_FUNCTION (this << bs);
-  if ((bs != BSS_MEMBERSHIP_SELECTOR_HT_PHY) && (bs != BSS_MEMBERSHIP_SELECTOR_VHT_PHY))
+  if ((bs != BSS_MEMBERSHIP_SELECTOR_HT_PHY) && (bs != BSS_MEMBERSHIP_SELECTOR_VHT_PHY) && (bs != BSS_MEMBERSHIP_SELECTOR_HE_PHY))
     {
       NS_ASSERT_MSG (false, "Value " << bs << " not a BSS Membership Selector");
     }
diff --git a/ns-3.26/src/wifi/model/wifi-mac-header.cc b/ns-3.26/src/wifi/model/wifi-mac-header.cc
index ae3080a..cf4a877 100644
--- a/ns-3.26/src/wifi/model/wifi-mac-header.cc
+++ b/ns-3.26/src/wifi/model/wifi-mac-header.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,15 +18,37 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
- * Author: Mirko Banchi <mk.banchi@gmail.com>
+ * Authors: Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/assert.h"
 #include "ns3/address-utils.h"
 #include "wifi-mac-header.h"
+#include "wifi-phy.h"
+#include "ns3/log.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <execinfo.h>
+#include <cxxabi.h>
+#include <map>
 
 namespace ns3 {
 
+NS_LOG_COMPONENT_DEFINE ("WifiMacHeader");
+
 NS_OBJECT_ENSURE_REGISTERED (WifiMacHeader);
 
 enum
@@ -43,7 +66,20 @@ enum
   SUBTYPE_CTL_BACKRESP = 9,
   SUBTYPE_CTL_RTS = 11,
   SUBTYPE_CTL_CTS = 12,
-  SUBTYPE_CTL_ACK = 13
+  SUBTYPE_CTL_ACK = 13,
+  SUBTYPE_CTL_TRIGGER = 3
+};
+
+enum
+{
+  TRIGGER_SUBTYPE_BASIC_TRIGGER = 0,
+  TRIGGER_SUBTYPE_BEAMFORMING_RP = 1,
+  TRIGGER_SUBTYPE_MU_BAR = 2,
+  TRIGGER_SUBTYPE_MU_RTS = 3,
+  TRIGGER_SUBTYPE_BSRP = 4,
+  TRIGGER_SUBTYPE_GCR_MU_BAR = 5,
+  TRIGGER_SUBTYPE_BQRP = 6
+  //Reserved: 7 - 15
 };
 
 WifiMacHeader::WifiMacHeader ()
@@ -52,6 +88,12 @@ WifiMacHeader::WifiMacHeader ()
     m_ctrlOrder (1),
     m_amsduPresent (0)
 {
+  m_htControlType = 0;
+  m_htControlId = 0;
+  m_qsize_vo = 0;
+  m_qsize_vi = 0;
+  m_qsize_be = 0;
+  m_qsize_bk = 0;
 }
 
 WifiMacHeader::~WifiMacHeader ()
@@ -317,6 +359,9 @@ WifiMacHeader::SetType (enum WifiMacType type)
       m_ctrlType = TYPE_DATA;
       m_ctrlSubtype = 15;
       break;
+    case WIFI_MAC_CTL_HE_TRIGGER:
+      m_ctrlType = TYPE_CTL;
+      m_ctrlSubtype = SUBTYPE_CTL_TRIGGER;
     }
   m_ctrlToDs = 0;
   m_ctrlFromDs = 0;
@@ -554,6 +599,9 @@ WifiMacHeader::GetType (void) const
         case SUBTYPE_CTL_ACK:
           return WIFI_MAC_CTL_ACK;
           break;
+        case SUBTYPE_CTL_TRIGGER:
+          return WIFI_MAC_CTL_HE_TRIGGER;
+          break;  
         }
       break;
     case TYPE_DATA:
@@ -631,6 +679,24 @@ WifiMacHeader::IsData (void) const
 
 }
 
+bool
+WifiMacHeader::IsSetOrder (void) const
+{
+  return (m_ctrlOrder == 1); 
+}
+
+bool
+WifiMacHeader::IsCtrlBsrHdr (void) const
+{
+  return ((m_htControlType == 3) && (m_htControlId == 3)); 
+}
+
+bool
+WifiMacHeader::IsCtrlBsrMtid (void) const
+{
+  return ((m_htControlType == 3) && (m_htControlId == 7));
+}
+
 bool
 WifiMacHeader::IsQosData (void) const
 {
@@ -676,6 +742,12 @@ WifiMacHeader::IsRts (void) const
   return (GetType () == WIFI_MAC_CTL_RTS);
 }
 
+bool
+WifiMacHeader::IsHeTrigger (void) const
+{
+  return (GetType () == WIFI_MAC_CTL_HE_TRIGGER);
+}
+
 bool
 WifiMacHeader::IsCts (void) const
 {
@@ -914,6 +986,162 @@ WifiMacHeader::GetQosControl (void) const
   return val;
 }
 
+void
+WifiMacHeader::UpdateControlHeaderBsrp(uint8_t aciBitmap, uint8_t maxAc, uint32_t maxQueueSf, uint32_t totalSf)
+{
+  m_htControlType = 3;   /* HT + HE Control header */
+  m_htControlAcibitmap = aciBitmap;
+  m_htControlId = 3;     /* For Bsr Id */
+  m_htControlDeltatid = 0;
+  m_htControlAcihigh = maxAc;
+  m_htControlSf = 0;
+  m_htControlQueueHigh = maxQueueSf;
+  m_htControlQueueAll = totalSf;
+}
+
+uint32_t
+WifiMacHeader::GetControlHeader (void) const
+{
+  uint32_t val = 0;
+
+  val |= m_htControlType;
+  val |= m_htControlId << 2;
+  if (m_htControlId == 3) //BSR bitmap status
+    {
+      /* This function is only for Buffer Status Report. */
+      val |= m_htControlAcibitmap << 6;     /* 2 + 4 */
+      val |= m_htControlDeltatid << 10;     /* 2 + 4 + 4 */
+      val |= m_htControlAcihigh << 12;      /* 2 + 4 + 4 + 2 */
+      val |= m_htControlSf << 14;           /* 2 + 4 + 4 + 2 + 2 */
+      val |= m_htControlQueueHigh << 16;    /* 2 + 4 + 4 + 2 + 2 + 2 */
+      val |= m_htControlQueueAll << 24;     /* 2 + 4 + 4 + 2 + 2 + 2 + 8 */
+    }
+  else if (m_htControlId == 7) //BSR multi tid status
+    {
+      /* This function is multi TID Buffer Status Report. */
+      val |= m_qsize_be << 6;               /* 2 + 4 */
+      val |= m_qsize_bk << 12;              /* 2 + 4 + 6 */
+      val |= m_qsize_vi << 18;              /* 2 + 4 + 6 + 6 */
+      val |= m_qsize_vo << 24;              /* 2 + 4 + 6 +6 +6 */
+    }
+  return val;
+}
+
+void
+WifiMacHeader::SetMultiQueueInfo (WifiMacHeader hdr)
+{
+  m_htControlType = 3;
+  m_htControlId = 7;
+  m_qsize_vo = hdr.GetVOSize();
+  m_qsize_vi = hdr.GetVISize();
+  m_qsize_be = hdr.GetBESize();
+  m_qsize_bk = hdr.GetBKSize();
+}
+
+void
+WifiMacHeader::SetVOSize (uint8_t qsize)
+{
+  m_htControlType = 3;
+  m_htControlId = 7;
+  m_qsize_vo = qsize;
+}
+
+void
+WifiMacHeader::SetVISize (uint8_t qsize)
+{
+  m_htControlType = 3;
+  m_htControlId = 7;
+  m_qsize_vi = qsize;
+}
+
+void
+WifiMacHeader::SetBESize (uint8_t qsize)
+{
+  m_htControlType = 3;
+  m_htControlId = 7;
+  m_qsize_be = qsize;
+}
+
+void
+WifiMacHeader::SetBKSize (uint8_t qsize)
+{
+  m_htControlType = 3;
+  m_htControlId = 7;
+  m_qsize_bk = qsize;
+}
+
+uint8_t
+WifiMacHeader::GetVOSize (void) const
+{
+  return m_qsize_vo;
+}
+
+uint8_t
+WifiMacHeader::GetVISize (void) const
+{
+  return m_qsize_vi;
+}
+
+uint8_t
+WifiMacHeader::GetBESize (void) const
+{
+  return m_qsize_be;
+}
+
+uint8_t
+WifiMacHeader::GetBKSize (void) const
+{
+  return m_qsize_bk;
+}
+
+uint16_t
+WifiMacHeader::GetAcibitmap ()
+{
+  return m_htControlAcibitmap;
+}
+
+uint16_t
+WifiMacHeader::GetAcihigh ()
+{
+  return m_htControlAcihigh;
+} 
+
+uint16_t
+WifiMacHeader::GetSfQueuehigh ()
+{
+  return m_htControlQueueHigh;
+} 
+
+uint16_t
+WifiMacHeader::GetSfQueueAll ()
+{
+  return m_htControlQueueAll;
+} 
+
+void
+WifiMacHeader::SetControlHeader (uint32_t htCtrlHeader)
+{
+  m_htControlType = htCtrlHeader & 0x00000003;
+  m_htControlId = (htCtrlHeader >> 2) & 0x0000000f;
+  if (m_htControlId == 3) //BSR bitmap status
+    {
+      m_htControlAcibitmap = (htCtrlHeader >> 6) & 0x0000000f;
+      m_htControlDeltatid = (htCtrlHeader >> 10) & 0x00000003;
+      m_htControlAcihigh = (htCtrlHeader >> 12) & 0x00000003;
+      m_htControlSf = (htCtrlHeader >> 14) & 0x00000003;
+      m_htControlQueueHigh = (htCtrlHeader >> 16) & 0x000000ff;
+      m_htControlQueueAll = (htCtrlHeader >> 24) & 0x000000ff;
+    }
+  else if (m_htControlId == 7) //BSR multi tid status
+    {
+      /* This function is multi TID Buffer Status Report. */
+      m_qsize_be = (htCtrlHeader >> 6) & 0x0000003f;
+      m_qsize_bk = (htCtrlHeader >> 12) & 0x0000003f;
+      m_qsize_vi = (htCtrlHeader >> 18) & 0x0000003f;
+      m_qsize_vo = (htCtrlHeader >> 24) & 0x0000003f;
+    }
+}
+
 void
 WifiMacHeader::SetFrameControl (uint16_t ctrl)
 {
@@ -956,6 +1184,7 @@ WifiMacHeader::GetSize (void) const
       switch (m_ctrlSubtype)
         {
         case SUBTYPE_CTL_RTS:
+        case SUBTYPE_CTL_TRIGGER:
           size = 2 + 2 + 6 + 6;
           break;
         case SUBTYPE_CTL_CTS:
@@ -980,6 +1209,9 @@ WifiMacHeader::GetSize (void) const
       if (m_ctrlSubtype & 0x08)
         {
           size += 2;
+          if(m_ctrlOrder) {
+              size += 4;
+          }
         }
       break;
     }
@@ -1072,6 +1304,7 @@ WifiMacHeader::Print (std::ostream &os) const
   switch (GetType ())
     {
     case WIFI_MAC_CTL_RTS:
+    case WIFI_MAC_CTL_HE_TRIGGER:
       os << "Duration/ID=" << m_duration << "us"
          << ", RA=" << m_addr1 << ", TA=" << m_addr2;
       break;
@@ -1190,6 +1423,10 @@ WifiMacHeader::Serialize (Buffer::Iterator i) const
         case SUBTYPE_CTL_BACKRESP:
           WriteTo (i, m_addr2);
           break;
+        case SUBTYPE_CTL_TRIGGER:
+          WriteTo (i, m_addr2);
+          break;
+        
         default:
           //NOTREACHED
           NS_ASSERT (false);
@@ -1208,6 +1445,10 @@ WifiMacHeader::Serialize (Buffer::Iterator i) const
         if (m_ctrlSubtype & 0x08)
           {
             i.WriteHtolsbU16 (GetQosControl ());
+            /* If data, if order bit set, then HT Control Header is present. */
+            if(m_ctrlOrder) {
+                i.WriteHtolsbU32 (GetControlHeader ());
+            }
           }
       } break;
     default:
@@ -1236,6 +1477,7 @@ WifiMacHeader::Deserialize (Buffer::Iterator start)
       switch (m_ctrlSubtype)
         {
         case SUBTYPE_CTL_RTS:
+        case SUBTYPE_CTL_TRIGGER: 
           ReadFrom (i, m_addr2);
           break;
         case SUBTYPE_CTL_CTS:
@@ -1258,10 +1500,843 @@ WifiMacHeader::Deserialize (Buffer::Iterator start)
       if (m_ctrlSubtype & 0x08)
         {
           SetQosControl (i.ReadLsbtohU16 ());
+          if(m_ctrlOrder) { 
+             SetControlHeader(i.ReadLsbtohU32());
+          }
         }
       break;
     }
   return i.GetDistanceFrom (start);
 }
 
+WifiHeTriggerMacHeader::WifiHeTriggerMacHeader()
+{
+}
+
+WifiHeTriggerMacHeader::~WifiHeTriggerMacHeader()
+{
+}
+
+bool
+WifiHeTriggerMacHeader::IsMuRts (void) const
+{
+  return (GetType () == WIFI_MAC_CTL_TRIGGER_HE_MU_RTS);
+}
+
+bool
+WifiHeTriggerMacHeader::IsBasicTrigger (void) const
+{
+  return (GetType () == WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER);
+}
+
+bool
+WifiHeTriggerMacHeader::IsBsrpTrigger (void) const
+{
+  return (GetType () == WIFI_MAC_CTL_TRIGGER_HE_BSRP);
+}
+
+void
+WifiHeTriggerMacHeader::SetType (enum WifiHeTriggerMacType type)
+{
+  switch (type)
+    {
+    case WIFI_MAC_CTL_TRIGGER_HE_MU_RTS:
+      m_trgSubType = TRIGGER_SUBTYPE_MU_RTS;
+      break;
+    case WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER:
+      m_trgSubType = TRIGGER_SUBTYPE_BASIC_TRIGGER;
+      break;
+    case WIFI_MAC_CTL_TRIGGER_HE_MU_BAR:
+      m_trgSubType = TRIGGER_SUBTYPE_MU_BAR;
+      break;
+    case WIFI_MAC_CTL_TRIGGER_HE_BSRP:
+      m_trgSubType = TRIGGER_SUBTYPE_BSRP;
+      break;
+    case WIFI_MAC_CTL_TRIGGER_HE_BEGIN:
+    case WIFI_MAC_CTL_TRIGGER_HE_END:
+      break;
+    }
+}
+
+TypeId
+WifiHeTriggerMacHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::WifiHeTriggerMacHeader")
+    .SetParent<Header> ()
+    .SetGroupName ("Wifi")
+    .AddConstructor<WifiHeTriggerMacHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+WifiHeTriggerMacHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+void
+WifiHeTriggerMacHeader::Print (std::ostream &os) const
+{
+  os << GetTypeString () << " ";
+  switch (GetType ())
+    {
+    case WIFI_MAC_CTL_TRIGGER_HE_MU_RTS:
+    case WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER:
+    case WIFI_MAC_CTL_TRIGGER_HE_MU_BAR:
+    case WIFI_MAC_CTL_TRIGGER_HE_BSRP:
+      os   << "length=" << m_length << ", BW="
+         << m_bw << "Num Users=" << m_numOfUsers;
+      break;
+    case WIFI_MAC_CTL_TRIGGER_HE_BEGIN:
+    case WIFI_MAC_CTL_TRIGGER_HE_END:
+      break;
+    }
+  return;
+}
+
+uint32_t
+WifiHeTriggerMacHeader::GetSize (void) const
+{
+  uint32_t size;
+  
+  size  =  8 + 1;  //Common Info + no of users
+  return size;
+}
+
+uint32_t
+WifiHeTriggerMacHeader::GetSerializedSize (void) const
+{
+  return GetSize ();
+}
+
+const char *
+WifiHeTriggerMacHeader::GetTypeString (void) const
+{
+#define FOO(x) \
+case WIFI_MAC_ ## x: \
+  return # x; \
+  break;
+
+  switch (GetType ())
+    {
+      FOO (CTL_TRIGGER_HE_MU_RTS);
+    default:
+      return "ERROR";
+    }
+#undef FOO
+  return "BIG_ERROR";
+} 
+
+void
+WifiHeTriggerMacHeader::Serialize (Buffer::Iterator i) const
+{
+  uint32_t val = 0;
+  // common info
+  i.WriteHtolsbU32 (GetCommonInfo());
+  i.WriteHtolsbU32 (val);
+ 
+  i.WriteU8(m_numOfUsers);
+  
+  return;
+}
+
+void
+WifiHeTriggerMacHeader::ConfigTriggerSubType(uint16_t triggerSubTypes)
+{
+   m_trgSubType = triggerSubTypes; 
+}
+
+uint32_t
+WifiHeTriggerMacHeader::GetCommonInfo (void) const
+{
+  uint32_t val = 0;
+
+  val |= ((m_trgSubType) & (0xf));  // Trigger Type
+//  val |= ((m_length<<4) & (0xfff<<4));  // Length Type
+//  val |= ((m_bw<<18) & (0x3<<18));  // BW 
+
+  return val;
+}
+
+enum WifiHeTriggerMacType 
+WifiHeTriggerMacHeader::GetType (void) const
+{
+   switch (m_trgSubType)
+   {
+        case TRIGGER_SUBTYPE_MU_RTS:
+          return WIFI_MAC_CTL_TRIGGER_HE_MU_RTS;
+          break;
+        case TRIGGER_SUBTYPE_BASIC_TRIGGER:
+          return WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER;
+          break;
+        case TRIGGER_SUBTYPE_MU_BAR:
+          return WIFI_MAC_CTL_TRIGGER_HE_MU_BAR;
+          break;
+        case TRIGGER_SUBTYPE_BSRP:
+          return WIFI_MAC_CTL_TRIGGER_HE_BSRP;
+          break;
+   }
+   return (enum WifiHeTriggerMacType) -1;
+}
+
+uint32_t
+WifiHeTriggerMacHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+  uint32_t common_info = i.ReadLsbtohU32 ();
+  SetCommonInfo (common_info);
+
+  common_info =  i.ReadLsbtohU32 ();
+  m_numOfUsers = i.ReadU8 ();
+
+  return i.GetDistanceFrom (start);
+}
+
+void
+WifiHeTriggerMacHeader::SetCommonInfo (uint32_t commonInfo)
+{
+  m_trgSubType = commonInfo & 0xf; 
+  m_length = (commonInfo >> 4) & 0x0f;
+  m_bw = (commonInfo >> 18) & 0xfff;
+}
+
+uint8_t 
+WifiHeTriggerMacHeader::GetNumOfUsers (void)
+{
+  return m_numOfUsers;
+}
+
+void 
+WifiHeTriggerMacHeader::SetNumOfUsers (uint8_t users)
+{
+  m_numOfUsers = users;
+}
+
+/* MU RTS Header */
+WifiHeMuRtsHeader::WifiHeMuRtsHeader()
+{
+}
+
+WifiHeMuRtsHeader::~WifiHeMuRtsHeader()
+{
+}
+
+TypeId
+WifiHeMuRtsHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::WifiHeMuRtsHeader")
+    .SetParent<Header> ()
+    .SetGroupName ("Wifi")
+    .AddConstructor<WifiHeMuRtsHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+WifiHeMuRtsHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+void
+WifiHeMuRtsHeader::Print (std::ostream &os) const
+{
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      os << "WifiHeMuRtsHeader:Print Addreess: " << j->first
+         << "aid :" << j->second.m_aid << "RU Index :"
+         << j->second.index << ", MCS=" << j->second.mcs
+         << ", coding type=" << j->second.codingType << ", DCM="
+         << j->second.dcm << ", SS Allocation=" << j->second.ssAllocation;;
+  }
+  return;
+}
+
+uint32_t
+WifiHeMuRtsHeader::GetSize (void) const
+{
+  uint32_t size = 0;
+
+  // Each User Info is 5 bytes * number of User Info.
+  size = 5 * staRuMapInfo.size();
+
+  return size;
+}
+
+uint32_t
+WifiHeMuRtsHeader::GetSerializedSize (void) const
+{
+  return GetSize ();
+}
+
+void
+WifiHeMuRtsHeader::SetStaRuMap(staRuMap staMap) 
+{
+    staRuMapInfo = staMap;
+}
+
+
+void
+WifiHeMuRtsHeader::Serialize (Buffer::Iterator i) const
+{
+  uint32_t value = 0;  
+  uint8_t  reserved = 0;
+
+  // User Info
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      value = 0;
+      // Get Aid from MacAddress - 12 bits.
+      value |= (j->second.m_aid) & (0xfff);
+      // RU Allocation - 8 bits
+
+      value |= (j->second.index << 12) & (0xff << 12);
+      // Coding Type - 1 bit
+      value |= (j->second.codingType << 20) & (0x1 << 20);
+      // MCS  - 4 bits
+      value |= (j->second.mcs << 21) & (0xf << 21);
+      // DCM - 1 bit
+      value |= (j->second.dcm << 25) & (0x1 << 25);
+      // SS Allocation - 6 bits
+      value |= (j->second.ssAllocation << 26) & (0x3f << 26);
+
+      i.WriteHtolsbU32 (value);
+      i.WriteU8(reserved);   //Reserved one byte
+
+  }
+  
+  return;
+}
+
+void 
+WifiHeMuRtsHeader::SetNumOfUsers (uint8_t users)
+{
+  m_numOfUsers = users;
+}
+
+staRuMap 
+WifiHeMuRtsHeader::GetRuMap()
+{
+   return staRuMapInfo;
+}
+
+uint32_t
+WifiHeMuRtsHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+  uint16_t j = 0;
+  RuInfo ruInfo;
+  uint32_t value = 0, valueTmp = 0;  
+  uint8_t reserved = 0;
+ 
+  staRuMapInfo.clear();
+  for(j = 0; j < m_numOfUsers; j ++) {
+      value = 0;
+      valueTmp = 0;
+      value = i.ReadLsbtohU32 ();
+
+      valueTmp = value;
+      ruInfo.m_aid = (valueTmp) & (0xfff);
+      valueTmp = value;
+      ruInfo.index = (valueTmp >> 12) & (0xff);
+      valueTmp = value;
+      ruInfo.codingType = (valueTmp >> 20) & (0x1);
+      valueTmp = value;
+      ruInfo.mcs = (valueTmp >> 21) & (0xf);
+      valueTmp = value;
+      ruInfo.dcm = (valueTmp >> 25) & (0x1);
+      valueTmp = value;
+      ruInfo.mcs = (valueTmp >> 26) & (0x3f);
+
+      staRuMapInfo.insert (std::make_pair (ruInfo.m_aid, ruInfo));
+      reserved = 0;
+      reserved = i.ReadU8 ();
+      if (reserved) {
+      }
+  }
+
+  return i.GetDistanceFrom (start);
+}
+
+/* Basic Trigger */
+
+WifiHEBasicTriggerMacHeader::WifiHEBasicTriggerMacHeader()
+{
+}
+
+WifiHEBasicTriggerMacHeader::~WifiHEBasicTriggerMacHeader()
+{
+}
+
+void
+WifiHEBasicTriggerMacHeader::SetStaRuMap(staRuMap staMap) 
+{
+    staRuMapInfo = staMap;
+}
+
+TypeId
+WifiHEBasicTriggerMacHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::WifiHEBasicTriggerMacHeader")
+    .SetParent<Header> ()
+    .SetGroupName ("Wifi")
+    .AddConstructor<WifiHEBasicTriggerMacHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+WifiHEBasicTriggerMacHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+void
+WifiHEBasicTriggerMacHeader::Print (std::ostream &os) const
+{
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      os << "WifiHeMuRtsHeader:Print Addreess: " << j->first
+         << "aid :" << j->second.m_aid << "RU Index :"
+         << j->second.index << ", MCS=" << j->second.mcs
+         << ", coding type=" << j->second.codingType << ", DCM="
+         << j->second.dcm << ", SS Allocation=" << j->second.ssAllocation
+         << ", Spacing Factor=" << j->second.mpduMuSpacingFactor
+         << ", TID Aggregation Limit=" << j->second.tidAggregationLimit
+         << ", AC Pref Level=" << j->second.acPreferenceLevel
+         << ", Preferred AC=" << j->second.preferredAc;
+  }
+  return;
+}
+
+uint32_t
+WifiHEBasicTriggerMacHeader::GetSize (void) const
+{
+  uint32_t size = 0;
+
+  // Each User Info is 6 bytes * number of User Info.
+  size = 6 * staRuMapInfo.size();
+
+  return size;
+}
+
+uint32_t
+WifiHEBasicTriggerMacHeader::GetSerializedSize (void) const
+{
+  return GetSize ();
+}
+
+staRuMap 
+WifiHEBasicTriggerMacHeader::GetRuMap()
+{
+   return staRuMapInfo;
+}
+
+void
+WifiHEBasicTriggerMacHeader::Serialize (Buffer::Iterator i) const
+{
+  uint32_t value = 0;  
+  uint8_t  reserved = 0;
+  uint8_t  triggerDependent = 0;
+
+  // User Info
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      value = 0;
+      // Get Aid from MacAddress - 12 bits.
+      value |= (j->second.m_aid) & (0xfff);
+      // RU Allocation - 8 bits
+      value |= (j->second.index << 12) & (0xff << 12);
+      // Coding Type - 1 bit
+      value |= (j->second.codingType << 20) & (0x1 << 20);
+      // MCS  - 4 bits
+      value |= (j->second.mcs << 21) & (0xf << 21);
+      // DCM - 1 bit
+      value |= (j->second.dcm << 25) & (0x1 << 25);
+      // SS Allocation - 6 bits
+      value |= (j->second.ssAllocation << 26) & (0x3f << 26);
+
+      i.WriteHtolsbU32 (value);
+      i.WriteU8(reserved);   //Reserved one byte
+
+      // MU Spacing factor;
+      triggerDependent |= (j->second.mpduMuSpacingFactor) & (0x3);
+      triggerDependent |= (j->second.tidAggregationLimit << 2) & (0x7 << 2);
+      triggerDependent |= (j->second.acPreferenceLevel << 5) & (0x1 << 5);
+      triggerDependent |= (j->second.preferredAc << 6) & (0x3 << 6);
+
+      i.WriteU8(triggerDependent);   //Reserved one byte
+  }
+  
+  return;
+}
+
+uint32_t
+WifiHEBasicTriggerMacHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+  uint16_t j = 0;
+  RuInfo ruInfo;
+  Mac48Address  macAddress;
+  uint32_t value = 0, valueTmp = 0;  
+ 
+  staRuMapInfo.clear();
+  for(j = 0; j < m_numOfUsers; j ++) {
+      value = 0;
+      valueTmp = 0;
+      value = i.ReadLsbtohU32 ();
+
+      valueTmp = value;
+      ruInfo.m_aid = (valueTmp) & (0xfff);
+      valueTmp = value;
+      ruInfo.index = (valueTmp >> 12) & (0xff);
+
+      valueTmp = value;
+      ruInfo.codingType = (valueTmp >> 20) & (0x1);
+      valueTmp = value;
+      ruInfo.mcs = (valueTmp >> 21) & (0xf);
+      valueTmp = value;
+      ruInfo.dcm = (valueTmp >> 25) & (0x1);
+      valueTmp = value;
+      ruInfo.ssAllocation = (valueTmp >> 26) & (0x3f);
+
+      value = 0;
+      value = i.ReadU8 ();
+      value = 0;
+      value = i.ReadU8 ();
+
+      valueTmp = value;
+      ruInfo.mpduMuSpacingFactor = (valueTmp) & (0x3);
+      valueTmp = value;
+      ruInfo.tidAggregationLimit = (valueTmp >> 2) & (0x7);
+      valueTmp = value;
+      ruInfo.acPreferenceLevel = (valueTmp >> 5) & (0x1);
+      valueTmp = value;
+      ruInfo.preferredAc = (valueTmp >> 6) & (0x3);
+
+      staRuMapInfo.insert (std::make_pair (ruInfo.m_aid, ruInfo));
+  }
+
+  return i.GetDistanceFrom (start);
+}
+
+void 
+WifiHEBasicTriggerMacHeader::SetNumOfUsers (uint8_t users)
+{
+  m_numOfUsers = users;
+}
+
+/* MU-BAR Trigger */
+
+WifiHEMuBarTriggerMacHeader::WifiHEMuBarTriggerMacHeader()
+{
+}
+
+WifiHEMuBarTriggerMacHeader::~WifiHEMuBarTriggerMacHeader()
+{
+}
+
+TypeId
+WifiHEMuBarTriggerMacHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::WifiHEMuBarTriggerMacHeader")
+    .SetParent<Header> ()
+    .SetGroupName ("Wifi")
+    .AddConstructor<WifiHEMuBarTriggerMacHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+WifiHEMuBarTriggerMacHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+void
+WifiHEMuBarTriggerMacHeader::Print (std::ostream &os) const
+{
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      os << "WifiHeMuRtsHeader:Print Addreess: " << j->first
+         << "aid :" << j->second.m_aid << "RU Index :"
+         << j->second.index << ", MCS=" << j->second.mcs
+         << ", coding type=" << j->second.codingType << ", DCM="
+         << j->second.dcm << ", SS Allocation=" << j->second.ssAllocation
+         << ", m_baAckPolicy " << j->second.m_baAckPolicy
+         << ", m_multiTid " << j->second.m_multiTid
+         << ", m_compressed " << j->second.m_compressed
+         << ", m_tidInfo " << j->second.m_tidInfo;
+  }
+  return;
+}
+
+uint32_t
+WifiHEMuBarTriggerMacHeader::GetSize (void) const
+{
+  uint32_t size = 0;
+
+  // Each User Info is 5 + 2 bytes * number of User Info.
+  size = 7 * staRuMapInfo.size();
+
+  return size;
+}
+
+uint32_t
+WifiHEMuBarTriggerMacHeader::GetSerializedSize (void) const
+{
+  return GetSize ();
+}
+
+void
+WifiHEMuBarTriggerMacHeader::Serialize (Buffer::Iterator i) const
+{
+  uint32_t value = 0;  
+  uint8_t  reserved = 0;
+  uint16_t  barControl = 0;
+
+  // User Info
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      value = 0;
+      // Get Aid from MacAddress - 12 bits.
+      value |= (j->second.m_aid) & (0xfff);
+      // RU Allocation - 8 bits
+      value |= (j->second.index << 12) & (0xff << 12);
+      // Coding Type - 1 bit
+      value |= (j->second.codingType << 20) & (0x1 << 20);
+      // MCS  - 4 bits
+      value |= (j->second.mcs << 21) & (0xf << 21);
+      // DCM - 1 bit
+      value |= (j->second.dcm << 25) & (0x1 << 25);
+      // SS Allocation - 6 bits
+      value |= (j->second.ssAllocation << 26) & (0x3f << 26);
+
+      i.WriteHtolsbU32 (value);
+      i.WriteU8(reserved);   //Reserved one byte
+
+      if (j->second.m_baAckPolicy)
+      {
+          barControl |= 0x1;
+      }
+      if (j->second.m_multiTid)
+      {
+          barControl |= (0x1 << 1);
+      }
+      if (j->second.m_compressed)
+      {
+          barControl |= (0x1 << 2);
+      }
+      barControl |= (j->second.m_tidInfo << 12) & (0xf << 12);
+
+      i.WriteHtolsbU16(barControl);
+  }
+  
+  return;
+}
+
+uint32_t
+WifiHEMuBarTriggerMacHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+  uint16_t j = 0;
+  RuInfo ruInfo;
+  Mac48Address  macAddress;
+  uint32_t value = 0, valueTmp = 0;  
+  uint8_t  reserved = 0;
+ 
+  staRuMapInfo.clear();
+  for(j = 0; j < m_numOfUsers; j ++) {
+      value = 0;
+      valueTmp = 0;
+      value = i.ReadLsbtohU32 ();
+
+      valueTmp = value;
+      ruInfo.m_aid = (valueTmp) & (0xfff);
+      valueTmp = value;
+      ruInfo.index = (valueTmp >> 12) & (0xff);
+      valueTmp = value;
+      ruInfo.codingType = (valueTmp >> 20) & (0x1);
+      valueTmp = value;
+      ruInfo.mcs = (valueTmp >> 21) & (0xf);
+      valueTmp = value;
+      ruInfo.dcm = (valueTmp >> 25) & (0x1);
+      valueTmp = value;
+      ruInfo.ssAllocation = (valueTmp >> 26) & (0x3f);
+      
+      reserved = 0;
+      reserved = i.ReadU8 ();
+      if (reserved) {
+      }
+
+      value = 0;
+      value = i.ReadU16 ();
+
+      valueTmp = value;
+      ruInfo.m_baAckPolicy = (valueTmp) & (0x1);
+      valueTmp = value;
+      ruInfo.m_multiTid = (valueTmp >> 1) & (0x1);
+      valueTmp = value;
+      ruInfo.m_compressed = (valueTmp >> 3) & (0x1);
+      valueTmp = value;
+      ruInfo.m_tidInfo = (valueTmp >> 12) & (0xf);
+
+      staRuMapInfo.insert (std::make_pair (ruInfo.m_aid, ruInfo));
+  }
+
+  return i.GetDistanceFrom (start);
+}
+
+void 
+WifiHEMuBarTriggerMacHeader::SetNumOfUsers (uint8_t users)
+{
+  m_numOfUsers = users;
+}
+
+/* BSRP */
+
+WifiHEBsrpMacHeader::WifiHEBsrpMacHeader()
+{
+}
+
+WifiHEBsrpMacHeader::~WifiHEBsrpMacHeader()
+{
+}
+
+void
+WifiHEBsrpMacHeader::SetStaRuMap(staRuMap staMap) 
+{
+    staRuMapInfo = staMap;
+}
+
+TypeId
+WifiHEBsrpMacHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::WifiHEBsrpMacHeader")
+    .SetParent<Header> ()
+    .SetGroupName ("Wifi")
+    .AddConstructor<WifiHEBsrpMacHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+WifiHEBsrpMacHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+void
+WifiHEBsrpMacHeader::Print (std::ostream &os) const
+{
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      os << "WifiHeBsrpMacHeader:Print Addreess: " << j->first
+         << "aid :" << j->second.m_aid << "RU Index :"
+         << j->second.index << ", MCS=" << j->second.mcs
+         << ", coding type=" << j->second.codingType << ", DCM="
+         << j->second.dcm << ", SS Allocation=" << j->second.ssAllocation;
+  }
+  return;
+}
+
+uint32_t
+WifiHEBsrpMacHeader::GetSize (void) const
+{
+  uint32_t size = 0;
+
+  // Each User Info is 5 bytes * number of User Info.
+  size = 5 * staRuMapInfo.size();
+
+  return size;
+}
+
+uint32_t
+WifiHEBsrpMacHeader::GetSerializedSize (void) const
+{
+  return GetSize ();
+}
+
+staRuMap 
+WifiHEBsrpMacHeader::GetRuMap()
+{
+   return staRuMapInfo;
+}
+
+void
+WifiHEBsrpMacHeader::Serialize (Buffer::Iterator i) const
+{
+  uint32_t value = 0;  
+  uint8_t  reserved = 0;
+
+  // User Info
+  for (staRuMap::const_iterator j = staRuMapInfo.begin (); j != staRuMapInfo.end (); j ++)
+  {
+      value = 0;
+      // Get Aid from MacAddress - 12 bits.
+      value |= (j->second.m_aid) & (0xfff);
+      // RU Allocation - 8 bits
+      value |= (j->second.index << 12) & (0xff << 12);
+      // Coding Type - 1 bit
+      value |= (j->second.codingType << 20) & (0x1 << 20);
+      // MCS  - 4 bits
+      value |= (j->second.mcs << 21) & (0xf << 21);
+      // DCM - 1 bit
+      value |= (j->second.dcm << 25) & (0x1 << 25);
+      // SS Allocation - 6 bits
+      value |= (j->second.ssAllocation << 26) & (0x3f << 26);
+
+      i.WriteHtolsbU32 (value);
+      i.WriteU8(reserved);   //Reserved one byte
+  }
+  
+  return;
+}
+
+uint32_t
+WifiHEBsrpMacHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+  uint16_t j = 0;
+  RuInfo ruInfo;
+  Mac48Address  macAddress;
+  uint32_t value = 0, valueTmp = 0;  
+ 
+  staRuMapInfo.clear();
+  for(j = 0; j < m_numOfUsers; j ++) {
+      value = 0;
+      valueTmp = 0;
+      value = i.ReadLsbtohU32 ();
+
+      valueTmp = value;
+      ruInfo.m_aid = (valueTmp) & (0xfff);
+
+      valueTmp = value;
+      ruInfo.index = (valueTmp >> 12) & (0xff);
+
+      valueTmp = value;
+      ruInfo.codingType = (valueTmp >> 20) & (0x1);
+      valueTmp = value;
+      ruInfo.mcs = (valueTmp >> 21) & (0xf);
+      valueTmp = value;
+      ruInfo.dcm = (valueTmp >> 25) & (0x1);
+      valueTmp = value;
+      ruInfo.ssAllocation = (valueTmp >> 26) & (0x3f);
+
+      i.ReadU8 ();
+
+      staRuMapInfo.insert (std::make_pair (ruInfo.m_aid, ruInfo));
+  }
+
+  return i.GetDistanceFrom (start);
+}
+
+void 
+WifiHEBsrpMacHeader::SetNumOfUsers (uint8_t users)
+{
+  m_numOfUsers = users;
+}
+
+
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/wifi-mac-header.h b/ns-3.26/src/wifi/model/wifi-mac-header.h
index 765eb98..f5c767f 100644
--- a/ns-3.26/src/wifi/model/wifi-mac-header.h
+++ b/ns-3.26/src/wifi/model/wifi-mac-header.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2006, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,16 +18,32 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
- * Author: Mirko Banchi <mk.banchi@gmail.com>
+ * Authors: Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_MAC_HEADER_H
 #define WIFI_MAC_HEADER_H
 
+#include <map>
+#include <utility>
 #include "ns3/header.h"
 #include "ns3/mac48-address.h"
 #include "ns3/nstime.h"
+#include "ns3/packet.h"
 #include <stdint.h>
+#include "ns3/wifi-phy.h"
 
 namespace ns3 {
 
@@ -71,6 +88,21 @@ enum WifiMacType
   WIFI_MAC_QOSDATA_NULL,
   WIFI_MAC_QOSDATA_NULL_CFPOLL,
   WIFI_MAC_QOSDATA_NULL_CFACK_CFPOLL,
+ 
+  WIFI_MAC_CTL_HE_TRIGGER    //For AX Client.
+};
+
+/**
+ * Combination of valid MAC Trigger He header type/subtype.
+ */
+enum WifiHeTriggerMacType 
+{
+  WIFI_MAC_CTL_TRIGGER_HE_BEGIN = 0,
+  WIFI_MAC_CTL_TRIGGER_HE_MU_RTS,
+  WIFI_MAC_CTL_TRIGGER_HE_BASIC_TRIGGER,
+  WIFI_MAC_CTL_TRIGGER_HE_MU_BAR,
+  WIFI_MAC_CTL_TRIGGER_HE_BSRP,
+  WIFI_MAC_CTL_TRIGGER_HE_END,
 };
 
 /**
@@ -213,6 +245,8 @@ public:
    *
    * \param duration the duration (Time object)
    */
+  bool IsHeTrigger (void) const;
+
   void SetDuration (Time duration);
   /**
    * Set the Duration/ID field with the given ID.
@@ -597,7 +631,24 @@ public:
    */
   typedef void (* TracedCallback)(const WifiMacHeader &header);
 
+  void UpdateControlHeaderBsrp(uint8_t aciBitmap, uint8_t maxAc, uint32_t maxQueueSf, uint32_t totalSf);
 
+  bool IsSetOrder (void) const;
+  bool IsCtrlBsrHdr (void) const;
+  bool IsCtrlBsrMtid (void) const;
+  uint16_t GetAcibitmap ();
+  uint16_t GetAcihigh();
+  uint16_t GetSfQueuehigh();
+  uint16_t GetSfQueueAll();
+  void SetVOSize (uint8_t qsize);
+  void SetVISize (uint8_t qsize);
+  void SetBESize (uint8_t qsize);
+  void SetBKSize (uint8_t qsize);
+  uint8_t GetVOSize (void) const;
+  uint8_t GetVISize (void) const;
+  uint8_t GetBESize (void) const;
+  uint8_t GetBKSize (void) const;
+  void SetMultiQueueInfo (WifiMacHeader hdr);
 private:
   /**
    * Return the raw Frame Control field.
@@ -611,6 +662,11 @@ private:
    * \return the raw QoS Control field
    */
   uint16_t GetQosControl (void) const;
+
+  /* HT Control header */
+  uint32_t GetControlHeader (void) const;
+  void SetControlHeader (uint32_t htCtrlHeader);
+
   /**
    * Set the Frame Control field with the given raw value.
    *
@@ -657,8 +713,163 @@ private:
   uint8_t m_qosAckPolicy;
   uint8_t m_amsduPresent;
   uint16_t m_qosStuff;
+  uint16_t m_htControlType;
+  uint16_t m_htControlId;
+  uint16_t m_htControlAcibitmap;
+  uint16_t m_htControlDeltatid;
+  uint16_t m_htControlAcihigh;
+  uint16_t m_htControlSf;
+  uint16_t m_htControlQueueHigh;
+  uint16_t m_htControlQueueAll;
+
+  //HT Control filed - Multi TID buffer status report
+  uint8_t  m_qsize_vo;
+  uint8_t  m_qsize_vi;
+  uint8_t  m_qsize_be;
+  uint8_t  m_qsize_bk;
 };
 
+
+/**
+ * \ingroup wifi
+ *
+ * Implements the IEEE 802.11ax HE Trigger MAC header
+ */
+class WifiHeTriggerMacHeader : public Header
+{
+public:
+  WifiHeTriggerMacHeader ();
+  ~WifiHeTriggerMacHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual void Print (std::ostream &os) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  uint32_t GetSize (void) const;
+  const char * GetTypeString (void) const;
+  enum WifiHeTriggerMacType GetType (void) const;
+  void SetCommonInfo (uint32_t control);
+  uint32_t GetCommonInfo(void) const;
+  void SetType (enum WifiHeTriggerMacType type);
+  void SetNumOfUsers (uint8_t users);
+  void ConfigTriggerSubType(uint16_t triggerSubTypes);
+  bool IsMuRts (void) const;
+  bool IsBasicTrigger (void) const;
+  bool IsBsrpTrigger (void) const;
+  uint8_t GetNumOfUsers (void);
+
+private:
+  uint16_t m_trgSubType;
+  uint8_t  m_numOfUsers;   // Count of number users.
+  uint8_t  m_length;    //
+  uint8_t  m_bw;       // 20 Hz/40Hz etc
+};
+
+/**
+ * \ingroup wifi
+ *
+ * Implements the IEEE 802.11ax MU-RTS Trigger header
+ */
+class WifiHeMuRtsHeader : public Header
+{
+public:
+  WifiHeMuRtsHeader();
+  ~WifiHeMuRtsHeader();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual void Print (std::ostream &os) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  uint32_t GetSize (void) const;
+  void SetNumOfUsers (uint8_t users);
+  void SetStaRuMap(staRuMap staMap); 
+  staRuMap GetRuMap();
+private:
+  staRuMap staRuMapInfo;
+  uint8_t  m_numOfUsers;   // Count of number users.
+};
+
+/**
+ * \ingroup wifi
+ *
+ * Implements the IEEE 802.11ax HE Trigger MAC header
+ */
+class WifiHEBasicTriggerMacHeader : public Header
+{
+public:
+  WifiHEBasicTriggerMacHeader();
+  ~WifiHEBasicTriggerMacHeader();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual void Print (std::ostream &os) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  uint32_t GetSize (void) const;
+  void SetNumOfUsers (uint8_t users);
+  void SetStaRuMap(staRuMap staMap); 
+  staRuMap GetRuMap();
+private:
+  staRuMap staRuMapInfo;
+  uint8_t  m_numOfUsers;   // Number of Users. 
+};
+
+/**
+ * \ingroup wifi
+ *
+ * Implements the IEEE 802.11ax HE MU-BAR MAC header
+ */
+class WifiHEMuBarTriggerMacHeader : public Header
+{
+public:
+  WifiHEMuBarTriggerMacHeader();
+  ~WifiHEMuBarTriggerMacHeader();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual void Print (std::ostream &os) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  uint32_t GetSize (void) const;
+  void SetNumOfUsers (uint8_t users);
+private:
+  staRuMap staRuMapInfo;
+  uint8_t  m_numOfUsers;   // Number of Users. 
+};
+
+/**
+ * \ingroup wifi
+ *
+ * Implements the IEEE 802.11ax HE Trigger MAC header
+ */
+class WifiHEBsrpMacHeader : public Header
+{
+public:
+  WifiHEBsrpMacHeader();
+  ~WifiHEBsrpMacHeader();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual void Print (std::ostream &os) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  uint32_t GetSize (void) const;
+  void SetNumOfUsers (uint8_t users);
+  void SetStaRuMap(staRuMap staMap); 
+  staRuMap GetRuMap();
+private:
+  staRuMap staRuMapInfo;
+  uint8_t  m_numOfUsers;   // Number of Users. 
+};
+
+
 } //namespace ns3
 
 #endif /* WIFI_MAC_HEADER_H */
diff --git a/ns-3.26/src/wifi/model/wifi-mac-queue.cc b/ns-3.26/src/wifi/model/wifi-mac-queue.cc
index 346cf7d..4e19716 100644
--- a/ns-3.26/src/wifi/model/wifi-mac-queue.cc
+++ b/ns-3.26/src/wifi/model/wifi-mac-queue.cc
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2005, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/simulator.h"
@@ -65,8 +78,9 @@ WifiMacQueue::GetTypeId (void)
 }
 
 WifiMacQueue::WifiMacQueue ()
-  : m_size (0)
+  : m_size (0), m_servedBytes (0), m_afterQueueDrop (0), m_beforeQueueDrop (0)
 {
+  m_startTrafficTime = Now();
 }
 
 WifiMacQueue::~WifiMacQueue ()
@@ -74,6 +88,20 @@ WifiMacQueue::~WifiMacQueue ()
   Flush ();
 }
 
+double
+WifiMacQueue::GetAfterQueueDropCount()
+{
+  Cleanup ();
+  return m_afterQueueDrop;
+}
+
+double
+WifiMacQueue::GetBeforeQueueDropCount()
+{
+  Cleanup ();
+  return m_beforeQueueDrop;
+}
+
 void
 WifiMacQueue::SetMaxSize (uint32_t maxSize)
 {
@@ -101,9 +129,18 @@ WifiMacQueue::GetMaxDelay (void) const
 void
 WifiMacQueue::Enqueue (Ptr<const Packet> packet, const WifiMacHeader &hdr)
 {
+  static int firstPackt = 0;
+  if (firstPackt == 0)
+    {
+      m_startTrafficTime = Now();
+      firstPackt++;
+    }
   Cleanup ();
   if (m_size == m_maxSize)
     {
+      if (packet->GetSize() != 508){
+        m_beforeQueueDrop++;
+      }
       if (m_dropPolicy == DROP_NEWEST)
         {
           return;
@@ -137,7 +174,12 @@ WifiMacQueue::Cleanup (void)
         }
       else
         {
+          uint32_t size = (i->packet)->GetSize();
           i = m_queue.erase (i);
+          //std::cout<<"Drop due to queue delay... Time" << i->tstamp <<  ":" << m_maxDelay << ":" << now << " and Size : " << size << std::endl;
+          if (size != 508){
+            m_afterQueueDrop++;
+          }
           n++;
         }
     }
@@ -153,6 +195,7 @@ WifiMacQueue::Dequeue (WifiMacHeader *hdr)
       Item i = m_queue.front ();
       m_queue.pop_front ();
       m_size--;
+      m_servedBytes = m_servedBytes + i.packet->GetSize();
       *hdr = i.hdr;
       return i.packet;
     }
@@ -191,6 +234,7 @@ WifiMacQueue::DequeueByTidAndAddress (WifiMacHeader *hdr, uint8_t tid,
                   packet = it->packet;
                   *hdr = it->hdr;
                   m_queue.erase (it);
+                  m_servedBytes = m_servedBytes + packet->GetSize();
                   m_size--;
                   break;
                 }
@@ -239,6 +283,26 @@ WifiMacQueue::GetSize (void)
   return m_size;
 }
 
+uint32_t
+WifiMacQueue::GetBytes (void)
+{
+  Cleanup ();
+  uint32_t bytes = 0;
+  PacketQueueI it = m_queue.begin ();
+  for (; it != m_queue.end (); it++)
+    {
+      bytes += it->packet->GetSize();
+    }
+  return bytes;
+}
+
+double
+WifiMacQueue::GetThroughput (void)
+{
+  Cleanup ();
+  return m_servedBytes*8/(Now().GetMicroSeconds() - m_startTrafficTime.GetMicroSeconds())*1e6;
+}
+
 void
 WifiMacQueue::Flush (void)
 {
@@ -267,6 +331,7 @@ WifiMacQueue::GetAddressForPacket (enum WifiMacHeader::AddressType type, PacketQ
 bool
 WifiMacQueue::Remove (Ptr<const Packet> packet)
 {
+  Cleanup();
   PacketQueueI it = m_queue.begin ();
   for (; it != m_queue.end (); it++)
     {
@@ -286,6 +351,9 @@ WifiMacQueue::PushFront (Ptr<const Packet> packet, const WifiMacHeader &hdr)
   Cleanup ();
   if (m_size == m_maxSize)
     {
+      if (packet->GetSize() != 508){
+        m_beforeQueueDrop++;
+      }
       return;
     }
   Time now = Simulator::Now ();
@@ -331,6 +399,7 @@ WifiMacQueue::DequeueFirstAvailable (WifiMacHeader *hdr, Time &timestamp,
           timestamp = it->tstamp;
           packet = it->packet;
           m_queue.erase (it);
+          m_servedBytes = m_servedBytes + packet->GetSize();
           m_size--;
           return packet;
         }
diff --git a/ns-3.26/src/wifi/model/wifi-mac-queue.h b/ns-3.26/src/wifi/model/wifi-mac-queue.h
index 6d71985..95a84a6 100644
--- a/ns-3.26/src/wifi/model/wifi-mac-queue.h
+++ b/ns-3.26/src/wifi/model/wifi-mac-queue.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (c) 2005, 2009 INRIA
  * Copyright (c) 2009 MIRKO BANCHI
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Mirko Banchi <mk.banchi@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_MAC_QUEUE_H
@@ -222,7 +235,18 @@ public:
    * \return the current queue size
    */
   uint32_t GetSize (void);
+  /**
+   * Return the current queue byte size.
+   *
+   * \return the current queue byte size
+   */
+  uint32_t GetBytes (void);
 
+  double GetThroughput(void);
+  
+  double GetAfterQueueDropCount(void);
+ 
+  double GetBeforeQueueDropCount(void);
 
 protected:
   /**
@@ -275,9 +299,13 @@ protected:
 
   PacketQueue m_queue; //!< Packet (struct Item) queue
   uint32_t m_size;     //!< Current queue size
+  double   m_servedBytes;
   uint32_t m_maxSize;  //!< Queue capacity
   Time m_maxDelay;     //!< Time to live for packets in the queue
   enum DropPolicy m_dropPolicy; //!< Drop behavior of queue
+  double m_afterQueueDrop;
+  double m_beforeQueueDrop;
+  Time   m_startTrafficTime;
 };
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/wifi-mac.cc b/ns-3.26/src/wifi/model/wifi-mac.cc
index d138ebf..e7bdc0b 100644
--- a/ns-3.26/src/wifi/model/wifi-mac.cc
+++ b/ns-3.26/src/wifi/model/wifi-mac.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2008 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "wifi-mac.h"
@@ -318,6 +331,12 @@ WifiMac::ConfigureStandard (enum WifiPhyStandard standard)
     case WIFI_PHY_STANDARD_80211ac:
       Configure80211ac ();
       break;
+    case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
+      Configure80211ax_2_4Ghz ();
+      break;
+    case WIFI_PHY_STANDARD_80211ax_5GHZ:
+      Configure80211ax_5Ghz ();
+      break;
     default:
       NS_ASSERT (false);
       break;
@@ -407,6 +426,17 @@ WifiMac::Configure80211ac (void)
   Configure80211n_5Ghz ();
 }
 
+void
+WifiMac::Configure80211ax_2_4Ghz (void)
+{
+  Configure80211n_2_4Ghz ();
+}
+void
+WifiMac::Configure80211ax_5Ghz (void)
+{
+  Configure80211ac ();
+}
+
 void
 WifiMac::ConfigureDcf (Ptr<Dcf> dcf, uint32_t cwmin, uint32_t cwmax, bool isDsss, enum AcIndex ac)
 {
diff --git a/ns-3.26/src/wifi/model/wifi-mac.h b/ns-3.26/src/wifi/model/wifi-mac.h
index 213c16e..c08a48e 100644
--- a/ns-3.26/src/wifi/model/wifi-mac.h
+++ b/ns-3.26/src/wifi/model/wifi-mac.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2008 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_MAC_H
@@ -299,6 +312,8 @@ public:
    * \sa WifiMac::Configure80211n_2_4Ghz
    * \sa WifiMac::Configure80211n_5Ghz
    * \sa WifiMac::Configure80211ac
+   * \sa WifiMac::Configure80211ax_2_4Ghz
+   * \sa WifiMac::Configure80211ax_5Ghz
    */
   void ConfigureStandard (enum WifiPhyStandard standard);
 
@@ -445,7 +460,14 @@ private:
   * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
   */
   void Configure80211ac (void);
-
+  /**
+   * This method sets 802.11ax 2.4 GHz standards-compliant defaults for following attributes:
+   */
+  void Configure80211ax_2_4Ghz (void);
+  /**
+   * This method sets 802.11n 5 GHz standards-compliant defaults for following attributes:
+   */
+  void Configure80211ax_5Ghz (void);
   /**
    * The trace source fired when packets come into the "top" of the device
    * at the L3/L2 transition, before being queued for transmission.
diff --git a/ns-3.26/src/wifi/model/wifi-mode.cc b/ns-3.26/src/wifi/model/wifi-mode.cc
index 610c947..23dfc33 100644
--- a/ns-3.26/src/wifi/model/wifi-mode.cc
+++ b/ns-3.26/src/wifi/model/wifi-mode.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "wifi-mode.h"
@@ -28,6 +41,13 @@
 
 namespace ns3 {
 
+  WifiMode::DataRateMap_t WifiMode::heDataRate;
+  WifiMode::DataRateMap_t WifiMode::m_he52DataRate;
+  WifiMode::DataRateMap_t WifiMode::m_he106DataRate;
+  WifiMode::DataRateMap_t WifiMode::m_he242DataRate;
+  WifiMode::DataRateMap_t WifiMode::m_he484DataRate;
+  WifiMode::DataRateMap_t WifiMode::m_he996DataRate;
+  WifiMode::DataRateMap_t WifiMode::m_he996x2DataRate;
 /**
  * Check if the two WifiModes are identical.
  *
@@ -219,6 +239,25 @@ WifiMode::GetDataRate (uint32_t channelWidth, bool isShortGuardInterval, uint8_t
 
       dataRate = lrint (ceil (symbolRate * usableSubCarriers * numberOfBitsPerSubcarrier * codingRate));
     }
+  else if(item->modClass == WIFI_MOD_CLASS_HE)
+    {
+      DataRateMap_t::const_iterator mapValue;
+      if (channelWidth == 2)
+        mapValue = heDataRate.find(GetMcsValue ());
+      else if (channelWidth == 4)
+        mapValue = m_he52DataRate.find(GetMcsValue ());
+      else if (channelWidth == 8)
+        mapValue = m_he106DataRate.find(GetMcsValue ());
+      else if (channelWidth == 20)
+        mapValue = m_he242DataRate.find(GetMcsValue ());
+      else if (channelWidth == 40)
+        mapValue = m_he484DataRate.find(GetMcsValue ());
+      else if (channelWidth == 80)
+        mapValue = m_he996DataRate.find(GetMcsValue ());
+      else if (channelWidth == 160)
+        mapValue = m_he996x2DataRate.find(GetMcsValue ());
+      dataRate = mapValue->second.dataRate;
+    }
   else
     {
       NS_ASSERT ("undefined datarate for the modulation class!");
@@ -227,6 +266,219 @@ WifiMode::GetDataRate (uint32_t channelWidth, bool isShortGuardInterval, uint8_t
   return dataRate;
 }
 
+void
+WifiMode::CreateHeRateTable (void)
+{
+   HeDataRate_t  rateValue;
+
+   //All are short guard intervals and DCM disable(0). 0.8 micro second.
+   rateValue.dataRate = 900000;  //0.9Mbps
+   heDataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 1800000;  //1.8Mbps
+   heDataRate.insert (std::make_pair (1, rateValue));
+   m_he52DataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 2600000;  //2.6Mbps
+   heDataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 3500000;  //3.5Mbps
+   heDataRate.insert (std::make_pair (3, rateValue));
+   m_he52DataRate.insert (std::make_pair (1, rateValue));
+
+   rateValue.dataRate = 3800000; 
+   m_he106DataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 5300000;
+   heDataRate.insert (std::make_pair (4, rateValue));
+   m_he52DataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 7100000;
+   heDataRate.insert (std::make_pair (5, rateValue));
+   m_he52DataRate.insert (std::make_pair (3, rateValue));
+
+   rateValue.dataRate = 7500000; 
+   m_he106DataRate.insert (std::make_pair (1, rateValue));
+
+   rateValue.dataRate = 7900000;
+   heDataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 8600000; 
+   m_he242DataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 8800000;
+   heDataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 10600000;
+   heDataRate.insert (std::make_pair (8, rateValue));
+   m_he52DataRate.insert (std::make_pair (4, rateValue));
+
+   rateValue.dataRate = 11300000; 
+   m_he106DataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 11800000;
+   heDataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 14100000;
+   m_he52DataRate.insert (std::make_pair (5, rateValue));
+
+   rateValue.dataRate = 15000000; 
+   m_he106DataRate.insert (std::make_pair (3, rateValue));
+
+   rateValue.dataRate = 15900000;
+   m_he52DataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 17200000; 
+   m_he242DataRate.insert (std::make_pair (1, rateValue));
+   m_he484DataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 17600000;
+   m_he52DataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 21200000;
+   m_he52DataRate.insert (std::make_pair (8, rateValue));
+
+   rateValue.dataRate = 22500000; 
+   m_he106DataRate.insert (std::make_pair (4, rateValue));
+
+   rateValue.dataRate = 23500000;
+   m_he52DataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 25800000; 
+   m_he242DataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 30000000; 
+   m_he106DataRate.insert (std::make_pair (5, rateValue));
+
+   rateValue.dataRate = 33800000; 
+   m_he106DataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 34400000; 
+   m_he242DataRate.insert (std::make_pair (3, rateValue));
+   m_he484DataRate.insert (std::make_pair (1, rateValue));
+
+   rateValue.dataRate = 36000000; 
+   m_he996DataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 37500000; 
+   m_he106DataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 45000000; 
+   m_he106DataRate.insert (std::make_pair (8, rateValue));
+
+   rateValue.dataRate = 50000000; 
+   m_he106DataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 51600000; 
+   m_he242DataRate.insert (std::make_pair (4, rateValue));
+   m_he484DataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 68800000; 
+   m_he242DataRate.insert (std::make_pair (5, rateValue));
+   m_he484DataRate.insert (std::make_pair (3, rateValue));
+
+   rateValue.dataRate = 72100000; 
+   m_he996DataRate.insert (std::make_pair (1, rateValue));
+   m_he996x2DataRate.insert (std::make_pair (0, rateValue));
+
+   rateValue.dataRate = 77400000; 
+   m_he242DataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 86000000; 
+   m_he242DataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 103200000; 
+   m_he242DataRate.insert (std::make_pair (8, rateValue));
+   m_he484DataRate.insert (std::make_pair (4, rateValue));
+
+   rateValue.dataRate = 108100000; 
+   m_he996DataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 114700000; 
+   m_he242DataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 129000000; 
+   m_he242DataRate.insert (std::make_pair (10, rateValue));
+
+   rateValue.dataRate = 137600000; 
+   m_he484DataRate.insert (std::make_pair (5, rateValue));
+
+   rateValue.dataRate = 143400000; 
+   m_he242DataRate.insert (std::make_pair (11, rateValue));
+
+   rateValue.dataRate = 144100000; 
+   m_he996DataRate.insert (std::make_pair (3, rateValue));
+   m_he996x2DataRate.insert (std::make_pair (1, rateValue));
+
+   rateValue.dataRate = 154900000; 
+   m_he484DataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 172100000; 
+   m_he484DataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 206500000; 
+   m_he484DataRate.insert (std::make_pair (8, rateValue));
+
+   rateValue.dataRate = 216200000; 
+   m_he996DataRate.insert (std::make_pair (4, rateValue));
+   m_he996x2DataRate.insert (std::make_pair (2, rateValue));
+
+   rateValue.dataRate = 229400000; 
+   m_he484DataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 258100000; 
+   m_he484DataRate.insert (std::make_pair (10, rateValue));
+
+   rateValue.dataRate = 286800000; 
+   m_he484DataRate.insert (std::make_pair (11, rateValue));
+
+   rateValue.dataRate = 288200000; 
+   m_he996DataRate.insert (std::make_pair (5, rateValue));
+   m_he996x2DataRate.insert (std::make_pair (3, rateValue));
+
+   rateValue.dataRate = 324300000; 
+   m_he996DataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 360300000; 
+   m_he996DataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 432400000; 
+   m_he996DataRate.insert (std::make_pair (8, rateValue));
+   m_he996x2DataRate.insert (std::make_pair (4, rateValue));
+
+   rateValue.dataRate = 480400000; 
+   m_he996DataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 540400000; 
+   m_he996DataRate.insert (std::make_pair (10, rateValue));
+
+   rateValue.dataRate = 576500000; 
+   m_he996x2DataRate.insert (std::make_pair (5, rateValue));
+
+   rateValue.dataRate = 600400000; 
+   m_he996DataRate.insert (std::make_pair (11, rateValue));
+
+   rateValue.dataRate = 648500000; 
+   m_he996x2DataRate.insert (std::make_pair (6, rateValue));
+
+   rateValue.dataRate = 720600000; 
+   m_he996x2DataRate.insert (std::make_pair (7, rateValue));
+
+   rateValue.dataRate = 864700000; 
+   m_he996x2DataRate.insert (std::make_pair (8, rateValue));
+
+   rateValue.dataRate = 960700000; 
+   m_he996x2DataRate.insert (std::make_pair (9, rateValue));
+
+   rateValue.dataRate = 1080900000; 
+   m_he996x2DataRate.insert (std::make_pair (10, rateValue));
+
+   rateValue.dataRate = 1201000000; 
+   m_he996x2DataRate.insert (std::make_pair (11, rateValue));
+
+   return;
+}
+
 uint64_t
 WifiMode::GetDataRate (WifiTxVector txVector) const
 {
@@ -257,7 +509,7 @@ WifiMode::GetCodeRate (void) const
           return WIFI_CODE_RATE_UNDEFINED;
         }
     }
-  else if (item->modClass == WIFI_MOD_CLASS_VHT)
+  else if (item->modClass == WIFI_MOD_CLASS_VHT || item->modClass == WIFI_MOD_CLASS_HE)
     {
       switch (item->mcsValue)
         {
@@ -332,6 +584,32 @@ WifiMode::GetConstellationSize (void) const
           return 0;
         }
     }
+  else if (item->modClass == WIFI_MOD_CLASS_HE)
+    {
+      switch (item->mcsValue)
+        {
+        case 0:
+          return 2;
+        case 1:
+        case 2:
+          return 4;
+        case 3:
+        case 4:
+          return 16;
+        case 5:
+        case 6:
+        case 7:
+          return 64;
+        case 8:
+        case 9:
+          return 256;
+        case 10:
+        case 11:
+          return 1024;
+        default:
+          return 0;
+        }
+    }
   else
     {
       return item->constellationSize;
@@ -357,7 +635,8 @@ uint8_t
 WifiMode::GetMcsValue (void) const
 {
   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
-  if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT)
+  if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT || 
+      item->modClass == WIFI_MOD_CLASS_HE)
     {
       return item->mcsValue;
     }
@@ -512,6 +791,11 @@ WifiMode::IsHigherDataRate (WifiMode mode) const
               return false;
             }
         }
+    case WIFI_MOD_CLASS_HE:
+      if (mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
+        {
+          return true;
+        }
     default:
       NS_FATAL_ERROR ("Modulation class not defined");
       return false;
@@ -521,11 +805,13 @@ WifiMode::IsHigherDataRate (WifiMode mode) const
 WifiMode::WifiMode ()
   : m_uid (0)
 {
+  CreateHeRateTable();
 }
 
 WifiMode::WifiMode (uint32_t uid)
   : m_uid (uid)
 {
+  CreateHeRateTable();
 }
 
 WifiMode::WifiMode (std::string name)
@@ -589,7 +875,7 @@ WifiModeFactory::CreateWifiMcs (std::string uniqueName,
   item->modClass = modClass;
 
   //The modulation class must be either HT or VHT
-  NS_ASSERT (modClass == WIFI_MOD_CLASS_HT || modClass == WIFI_MOD_CLASS_VHT);
+  NS_ASSERT (modClass == WIFI_MOD_CLASS_HT || modClass == WIFI_MOD_CLASS_VHT || WIFI_MOD_CLASS_HE);
 
   item->mcsValue = mcsValue;
   //fill unused items with dummy values
diff --git a/ns-3.26/src/wifi/model/wifi-mode.h b/ns-3.26/src/wifi/model/wifi-mode.h
index c9d0cbf..17166c7 100644
--- a/ns-3.26/src/wifi/model/wifi-mode.h
+++ b/ns-3.26/src/wifi/model/wifi-mode.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_MODE_H
@@ -26,6 +39,7 @@
 #include <string>
 #include <vector>
 #include <ostream>
+#include <map>
 #include "ns3/attribute-helper.h"
 #include "ns3/wifi-phy-standard.h"
 
@@ -61,7 +75,9 @@ enum WifiModulationClass
   /** HT PHY (Clause 20) */
   WIFI_MOD_CLASS_HT,
   /** VHT PHY (Clause 22) */
-  WIFI_MOD_CLASS_VHT
+  WIFI_MOD_CLASS_VHT,
+  /** VHT PHY (Clause xx) */
+  WIFI_MOD_CLASS_HE
 };
 
 /**
@@ -210,6 +226,18 @@ public:
 private:
   friend class WifiModeFactory;
   friend class WifiPhyTag; // access the UID-based constructor
+  typedef struct HeDataRate_ {
+     uint64_t  dataRate; //bps
+  } HeDataRate_t;
+  void CreateHeRateTable (void);
+  typedef std::map<uint32_t, HeDataRate_t> DataRateMap_t;
+  static DataRateMap_t heDataRate;
+  static DataRateMap_t m_he52DataRate;
+  static DataRateMap_t m_he106DataRate;
+  static DataRateMap_t m_he242DataRate;
+  static DataRateMap_t m_he484DataRate;
+  static DataRateMap_t m_he996DataRate;
+  static DataRateMap_t m_he996x2DataRate;
   /**
    * Create a WifiMode from a given unique ID.
    *
@@ -236,7 +264,6 @@ typedef std::vector<WifiMode> WifiModeList;
  * An iterator for WifiModeList vector.
  */
 typedef WifiModeList::const_iterator WifiModeListIterator;
-
 /**
  * \brief create WifiMode class instances and keep track of them.
  *
@@ -334,7 +361,6 @@ private:
    * \return WifiModeItem at the given uid
    */
   WifiModeItem* Get (uint32_t uid);
-
   /**
    * typedef for a vector of WifiModeItem.
    */
diff --git a/ns-3.26/src/wifi/model/wifi-net-device.cc b/ns-3.26/src/wifi/model/wifi-net-device.cc
index 3b4bdd0..1352c01 100644
--- a/ns-3.26/src/wifi/model/wifi-net-device.cc
+++ b/ns-3.26/src/wifi/model/wifi-net-device.cc
@@ -1,6 +1,8 @@
+
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +18,18 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "wifi-net-device.h"
@@ -120,13 +134,13 @@ WifiNetDevice::CompleteConfig (void)
     {
       return;
     }
+  m_stationManager->SetupPhy (m_phy);
+  m_stationManager->SetupMac (m_mac);
   m_mac->SetWifiRemoteStationManager (m_stationManager);
   m_mac->SetWifiPhy (m_phy);
   m_mac->SetForwardUpCallback (MakeCallback (&WifiNetDevice::ForwardUp, this));
   m_mac->SetLinkUpCallback (MakeCallback (&WifiNetDevice::LinkUp, this));
   m_mac->SetLinkDownCallback (MakeCallback (&WifiNetDevice::LinkDown, this));
-  m_stationManager->SetupPhy (m_phy);
-  m_stationManager->SetupMac (m_mac);
   m_configComplete = true;
 }
 
diff --git a/ns-3.26/src/wifi/model/wifi-phy-standard.h b/ns-3.26/src/wifi/model/wifi-phy-standard.h
index c308d1a..60987ca 100644
--- a/ns-3.26/src/wifi/model/wifi-phy-standard.h
+++ b/ns-3.26/src/wifi/model/wifi-phy-standard.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_PHY_STANDARD_H
@@ -51,6 +64,9 @@ enum WifiPhyStandard
   WIFI_PHY_STANDARD_80211n_5GHZ,
   /** VHT OFDM PHY (clause 22) */
   WIFI_PHY_STANDARD_80211ac,
+  /** VHT OFDMA PHY (clause xx) */
+  WIFI_PHY_STANDARD_80211ax_2_4GHZ,
+  WIFI_PHY_STANDARD_80211ax_5GHZ,
   /** Unspecified */
   WIFI_PHY_STANDARD_UNSPECIFIED
 };
diff --git a/ns-3.26/src/wifi/model/wifi-phy-state-helper.cc b/ns-3.26/src/wifi/model/wifi-phy-state-helper.cc
index 3dda151..63f4669 100644
--- a/ns-3.26/src/wifi/model/wifi-phy-state-helper.cc
+++ b/ns-3.26/src/wifi/model/wifi-phy-state-helper.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "wifi-phy-state-helper.h"
@@ -353,9 +366,20 @@ WifiPhyStateHelper::SwitchToTx (Time txDuration, Ptr<const Packet> packet, doubl
 void
 WifiPhyStateHelper::SwitchToRx (Time rxDuration)
 {
+  Time now = Simulator::Now ();
+  NS_LOG_FUNCTION(this);
+  if (m_rxing && m_ruState.size() != 0)
+    {
+      //This is a HE operation
+      if (m_endRx < now + rxDuration)
+	{
+	  m_endRx = now + rxDuration;
+	  NotifyRxStart (rxDuration);
+	}
+      return;
+    }
   NS_ASSERT (IsStateIdle () || IsStateCcaBusy ());
   NS_ASSERT (!m_rxing);
-  Time now = Simulator::Now ();
   switch (GetState ())
     {
     case WifiPhy::IDLE:
@@ -432,8 +456,11 @@ void
 WifiPhyStateHelper::SwitchFromRxEndOk (Ptr<Packet> packet, double snr, WifiTxVector txVector, enum WifiPreamble preamble)
 {
   m_rxOkTrace (packet, snr, txVector.GetMode (), preamble);
-  NotifyRxEndOk ();
-  DoSwitchFromRx ();
+  if (txVector.GetRu() == 0xff || IsLastRuRx())
+    {
+      NotifyRxEndOk ();
+      DoSwitchFromRx ();
+    }
   if (!m_rxOkCallback.IsNull ())
     {
       m_rxOkCallback (packet, snr, txVector, preamble);
@@ -442,11 +469,14 @@ WifiPhyStateHelper::SwitchFromRxEndOk (Ptr<Packet> packet, double snr, WifiTxVec
 }
 
 void
-WifiPhyStateHelper::SwitchFromRxEndError (Ptr<Packet> packet, double snr)
+WifiPhyStateHelper::SwitchFromRxEndError (Ptr<Packet> packet, double snr, WifiTxVector txVector)
 {
   m_rxErrorTrace (packet, snr);
-  NotifyRxEndError ();
-  DoSwitchFromRx ();
+  if (txVector.GetRu() == 0xff || IsLastRuRx())
+    {
+      NotifyRxEndError ();
+      DoSwitchFromRx ();
+    }
   if (!m_rxErrorCallback.IsNull ())
     {
       m_rxErrorCallback (packet, snr);
@@ -542,4 +572,81 @@ WifiPhyStateHelper::SwitchFromSleep (Time duration)
     }
 }
 
+bool
+WifiPhyStateHelper::IsLastRuRx (void)
+{
+  return m_ruState.size() == 1;
+}
+
+void
+WifiPhyStateHelper::SetRxingForRu (uint8_t ru, bool enable)
+{
+  if (ru == 0xff)
+    {
+      m_ruState.clear();
+      return;
+    }
+  if (enable)
+    {
+      m_ruState.push_back(ru);
+    }
+  else
+    {
+
+      RuState::iterator it = find(m_ruState.begin (), m_ruState.end (), ru);
+      if (it != m_ruState.end ())
+	{
+	  m_ruState.erase(it);
+	}
+    }
+}
+
+bool
+WifiPhyStateHelper::IsRxingOnRu(WifiTxVector txVector)
+{
+  for (uint16_t i = 0; i < m_ruState.size (); i++)
+    {
+      if (m_ruState[i] == txVector.GetRu())
+	{
+	  return true;
+	}
+    }
+  return false;
+}
+bool
+WifiPhyStateHelper::IsLastRuTx (void)
+{
+  return m_ruTxState.size() == 1;
+}
+
+void
+WifiPhyStateHelper::SetTxingForRu (WifiTxVector txVector, bool enable)
+{
+  if (enable)
+    {
+      m_ruTxState.push_back(txVector.GetRu());
+    }
+  else
+    {
+
+      RuState::iterator it = find(m_ruTxState.begin (), m_ruTxState.end (), txVector.GetRu());
+      if (it != m_ruTxState.end ())
+	{
+	  m_ruTxState.erase(it);
+	}
+    }
+}
+
+bool
+WifiPhyStateHelper::IsTxingOnRu(WifiTxVector txVector)
+{
+  for (uint16_t i = 0; i < m_ruTxState.size (); i++)
+    {
+      if (m_ruTxState[i] == txVector.GetRu())
+	{
+	  return true;
+	}
+    }
+  return false;
+}
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/wifi-phy-state-helper.h b/ns-3.26/src/wifi/model/wifi-phy-state-helper.h
index 35c3a7b..0a94202 100644
--- a/ns-3.26/src/wifi/model/wifi-phy-state-helper.h
+++ b/ns-3.26/src/wifi/model/wifi-phy-state-helper.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_PHY_STATE_HELPER_H
@@ -168,7 +181,7 @@ public:
    * \param packet the packet that we failed to received
    * \param snr the SNR of the received packet
    */
-  void SwitchFromRxEndError (Ptr<Packet> packet, double snr);
+  void SwitchFromRxEndError (Ptr<Packet> packet, double snr, WifiTxVector txVector);
   /**
    * Switch to CCA busy.
    *
@@ -232,7 +245,30 @@ public:
     (Ptr<const Packet> packet, WifiMode mode,
      WifiPreamble preamble, uint8_t power);
 
-
+  /**
+   *
+   */
+  void  SetRxingForRu (uint8_t ru, bool enable);
+  /**
+   *
+   */
+  bool IsRxingOnRu(WifiTxVector txVector);
+  /**
+   *
+   */
+  bool IsLastRuRx (void);
+  /**
+   *
+   */
+  void  SetTxingForRu (WifiTxVector txVector, bool enable);
+  /**
+   *
+   */
+  bool IsTxingOnRu(WifiTxVector txVector);
+  /**
+   *
+   */
+  bool IsLastRuTx (void);
 private:
   /**
    * typedef for a list of WifiPhyListeners
@@ -306,6 +342,9 @@ private:
   Time m_previousStateChangeTime;
 
   Listeners m_listeners;
+  typedef std::vector<uint8_t> RuState;
+  RuState                      m_ruState;
+  RuState                      m_ruTxState;
   TracedCallback<Ptr<const Packet>, double, WifiMode, enum WifiPreamble> m_rxOkTrace;
   TracedCallback<Ptr<const Packet>, double> m_rxErrorTrace;
   TracedCallback<Ptr<const Packet>,WifiMode,WifiPreamble,uint8_t> m_txTrace;
diff --git a/ns-3.26/src/wifi/model/wifi-phy.cc b/ns-3.26/src/wifi/model/wifi-phy.cc
index 1a2d317..370a351 100644
--- a/ns-3.26/src/wifi/model/wifi-phy.cc
+++ b/ns-3.26/src/wifi/model/wifi-phy.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "wifi-phy.h"
@@ -34,6 +47,7 @@
 #include "ns3/pointer.h"
 #include "ns3/trace-source-accessor.h"
 #include "ns3/fatal-error.h"
+#include "ns3/rng-seed-manager.h"
 #include <cmath>
 
 namespace ns3 {
@@ -145,6 +159,16 @@ WifiPhy::ChannelToFrequencyWidthMap WifiPhy::m_channelToFrequencyWidth =
   // 160 MHz channels
   { std::make_pair (50, WIFI_PHY_STANDARD_80211ac), std::make_pair (5250, 160) },
   { std::make_pair (114, WIFI_PHY_STANDARD_80211ac), std::make_pair (5570, 160) },
+  // 80 MHz channels
+  { std::make_pair (42, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5210, 80) },
+  { std::make_pair (58, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5290, 80) },
+  { std::make_pair (106, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5530, 80) },
+  { std::make_pair (122, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5610, 80) },
+  { std::make_pair (138, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5690, 80) },
+  { std::make_pair (155, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5775, 80) },
+  // 160 MHz channels
+  { std::make_pair (50, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5250, 160) },
+  { std::make_pair (114, WIFI_PHY_STANDARD_80211ax_5GHZ), std::make_pair (5570, 160) },
 
   // 802.11p (10 MHz channels at the 5.855-5.925 band 
   { std::make_pair (172, WIFI_PHY_STANDARD_80211_10MHZ), std::make_pair (5860, 10) },
@@ -187,6 +211,13 @@ WifiPhy::GetTypeId (void)
                    MakeDoubleAccessor (&WifiPhy::SetEdThreshold,
                                        &WifiPhy::GetEdThreshold),
                    MakeDoubleChecker<double> ())
+    .AddAttribute ("ObssEnergyDetectionThreshold",
+                   "The energy of a received signal should be higher than "
+                   "this threshold (dbm) to signal the PHY layer to drop the packet.",
+                   DoubleValue (-66.0),
+                   MakeDoubleAccessor (&WifiPhy::SetObssCcaThreshold,
+                                       &WifiPhy::GetObssCcaThreshold),
+                   MakeDoubleChecker<double> ())
     .AddAttribute ("CcaMode1Threshold",
                    "The energy of a received signal should be higher than "
                    "this threshold (dbm) to allow the PHY layer to declare CCA BUSY state.",
@@ -359,7 +390,10 @@ WifiPhy::WifiPhy ()
 {
   NS_LOG_FUNCTION (this);
   m_random = CreateObject<UniformRandomVariable> ();
+  static uint64_t i = 0;
+  SeedManager::SetRun(i++);
   m_state = CreateObject<WifiPhyStateHelper> ();
+  m_color = 0;
 }
 
 WifiPhy::~WifiPhy ()
@@ -426,6 +460,13 @@ WifiPhy::SetEdThreshold (double threshold)
   m_edThresholdW = DbmToW (threshold);
 }
 
+void
+WifiPhy::SetObssCcaThreshold (double threshold)
+{
+  NS_LOG_FUNCTION (this << threshold);
+  m_obssCcaThresholdW = DbmToW (threshold);
+}
+
 double
 WifiPhy::GetEdThresholdW (void) const
 {
@@ -438,6 +479,18 @@ WifiPhy::GetEdThreshold (void) const
   return WToDbm (m_edThresholdW);
 }
 
+double
+WifiPhy::GetObssCcaThresholdW (void) const
+{
+  return m_obssCcaThresholdW;
+}
+
+double
+WifiPhy::GetObssCcaThreshold (void) const
+{
+  return WToDbm (m_obssCcaThresholdW);
+}
+
 void
 WifiPhy::SetCcaMode1Threshold (double threshold)
 {
@@ -727,6 +780,19 @@ WifiPhy::ConfigureDefaultsForStandard (enum WifiPhyStandard standard)
       // Channel number should be aligned by SetFrequency () to 42
       NS_ASSERT (GetChannelNumber () == 42);
       break;
+    case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
+      SetChannelWidth (20);
+      SetFrequency (2412);
+      // Channel number should be aligned by SetFrequency () to 1
+      NS_ASSERT (GetChannelNumber () == 1);
+      break;
+    case WIFI_PHY_STANDARD_80211ax_5GHZ:
+      SetChannelWidth (80);
+      SetFrequency (5210);
+      // Channel number should be aligned by SetFrequency () to 42
+      NS_ASSERT (GetChannelNumber () == 42);
+      break;
+
     case WIFI_PHY_STANDARD_UNSPECIFIED:
       NS_LOG_WARN ("Configuring unspecified standard; performing no action");
       break;
@@ -926,6 +992,39 @@ WifiPhy::Configure80211ac (void)
   m_bssMembershipSelectorSet.push_back (VHT_PHY);
 }
 
+void
+WifiPhy::Configure80211ax (void)
+{
+  NS_LOG_FUNCTION (this);
+  if (GetFrequency () >= 2400 && GetFrequency () <= 2500) //at 2.4 GHz
+    {
+      Configure80211b ();
+      Configure80211g ();
+      Configure80211n ();
+    }
+  if (GetFrequency () >= 5000 && GetFrequency () <= 6000) //at 5 GHz
+    {
+      Configure80211a ();
+      Configure80211n ();
+      Configure80211ac ();
+    }
+
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs0 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs1 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs2 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs3 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs4 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs5 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs6 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs7 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs8 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs9 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs10 ());
+  m_deviceMcsSet.push_back (WifiPhy::GetHeMcs11 ());
+
+  m_bssMembershipSelectorSet.push_back (HE_PHY);
+}
+
 bool 
 WifiPhy::DefineChannelNumber (uint16_t channelNumber, enum WifiPhyStandard standard, uint32_t frequency, uint32_t channelWidth)
 {
@@ -1070,6 +1169,12 @@ WifiPhy::ConfigureStandard (enum WifiPhyStandard standard)
     case WIFI_PHY_STANDARD_80211ac:
       Configure80211ac ();
       break;
+    case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
+      Configure80211ax ();
+      break;
+    case WIFI_PHY_STANDARD_80211ax_5GHZ:
+      Configure80211ax ();
+      break;
     default:
       NS_ASSERT (false);
       break;
@@ -1337,6 +1442,36 @@ WifiPhy::DoChannelSwitch (uint16_t nch)
   return true;
 }
 
+void
+WifiPhy::SetAid (uint16_t aid)
+{
+   m_aid = aid;
+}
+
+uint16_t
+WifiPhy::GetAid () const
+{
+  return m_aid;
+}
+
+void
+WifiPhy::SetColor (uint8_t color)
+{
+   m_color = color;
+}
+
+uint8_t
+WifiPhy::GetColor () const
+{
+  return m_color;
+}
+
+void
+WifiPhy::SetRu (uint8_t ru)
+{
+  m_state->SetRxingForRu(ru, true);
+}
+
 bool
 WifiPhy::DoFrequencySwitch (uint32_t frequency)
 {
@@ -1466,6 +1601,7 @@ WifiPhy::GetPlcpHeaderMode (WifiMode payloadMode, WifiPreamble preamble, WifiTxV
     case WIFI_MOD_CLASS_OFDM:
     case WIFI_MOD_CLASS_HT:
     case WIFI_MOD_CLASS_VHT:
+    case WIFI_MOD_CLASS_HE:
       switch (txVector.GetChannelWidth ())
         {
         case 5:
@@ -1547,6 +1683,7 @@ WifiPhy::GetPlcpHeaderDuration (WifiTxVector txVector, WifiPreamble preamble)
           }
       }
     case WIFI_MOD_CLASS_VHT:
+    case WIFI_MOD_CLASS_HE:
     case WIFI_MOD_CLASS_ERP_OFDM:
       return MicroSeconds (4);
     case WIFI_MOD_CLASS_DSSS:
@@ -1597,6 +1734,7 @@ WifiPhy::GetPlcpPreambleDuration (WifiTxVector txVector, WifiPreamble preamble)
       }
     case WIFI_MOD_CLASS_VHT:
     case WIFI_MOD_CLASS_HT:
+    case WIFI_MOD_CLASS_HE:
       //IEEE 802.11n Figure 20.1 the training symbols before L_SIG or HT_SIG
       return MicroSeconds (16);
     case WIFI_MOD_CLASS_ERP_OFDM:
@@ -1911,12 +2049,25 @@ WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, WifiPreamble
                              << " mode=" << payloadMode
                              << " rate=" << payloadMode.GetDataRate (22, 0, 1));
       return MicroSeconds (lrint (ceil ((size * 8.0) / (payloadMode.GetDataRate (22, 0, 1) / 1.0e6))));
+    case WIFI_MOD_CLASS_HE:
+      {
+        txVector.SetNss(1);
+	double dataRate = payloadMode.GetDataRate (txVector)/ 1.0e9;
+        return NanoSeconds((size * 8 ) / dataRate);
+      }
     default:
       NS_FATAL_ERROR ("unsupported modulation class");
       return MicroSeconds (0);
     }
 }
 
+Time
+WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency, enum mpduType mpdutype, uint8_t incFlag)
+{
+  return CalculatePlcpPreambleAndHeaderDuration (txVector, preamble)
+      + GetPayloadDuration (size, txVector, preamble, frequency, mpdutype, incFlag);
+}
+
 Time
 WifiPhy::CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector, WifiPreamble preamble)
 {
@@ -1930,14 +2081,6 @@ WifiPhy::CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector, WifiPrea
   return duration;
 }
 
-Time
-WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency, enum mpduType mpdutype, uint8_t incFlag)
-{
-  Time duration = CalculatePlcpPreambleAndHeaderDuration (txVector, preamble)
-    + GetPayloadDuration (size, txVector, preamble, frequency, mpdutype, incFlag);
-  return duration;
-}
-
 Time
 WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency)
 {
@@ -2784,6 +2927,139 @@ WifiPhy::GetVhtMcs9 ()
   return mcs;
 }
 
+// Clause XX
+WifiMode
+WifiPhy::GetHeMcs(uint32_t mcs)
+{
+    switch(mcs) {
+        case 0:
+            return GetHeMcs0();
+        case 1:
+            return GetHeMcs1();
+        case 2:
+            return GetHeMcs2();
+        case 3:
+            return GetHeMcs3();
+        case 4:
+            return GetHeMcs4();
+        case 5:
+            return GetHeMcs5();
+        case 6:
+            return GetHeMcs6();
+        case 7:
+            return GetHeMcs7();
+        case 8:
+            return GetHeMcs8();
+        case 9:
+            return GetHeMcs9();
+        case 10:
+            return GetHeMcs10();
+        case 11:
+            return GetHeMcs11();
+
+        default:
+            return GetHeMcs0();
+    }
+    return GetHeMcs0();
+}
+
+
+WifiMode
+WifiPhy::GetHeMcs0 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs0", 0, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs1 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs1", 1, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs2 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs2", 2, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs3 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs3", 3, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs4 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs4", 4, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs5 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs5", 5, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs6 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs6", 6, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs7 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs7", 7, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs8 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs8", 8, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs9 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs9", 9, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs10 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs10", 10, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
+WifiMode
+WifiPhy::GetHeMcs11 ()
+{
+  static WifiMode mcs =
+    WifiModeFactory::CreateWifiMcs ("HeMcs11", 11, WIFI_MOD_CLASS_HE);
+  return mcs;
+}
+
 bool
 WifiPhy::IsValidTxVector (WifiTxVector txVector)
 {
@@ -3073,6 +3349,18 @@ public:
     ns3::WifiPhy::GetVhtMcs7 ();
     ns3::WifiPhy::GetVhtMcs8 ();
     ns3::WifiPhy::GetVhtMcs9 ();
+    ns3::WifiPhy::GetHeMcs0 ();
+    ns3::WifiPhy::GetHeMcs1 ();
+    ns3::WifiPhy::GetHeMcs2 ();
+    ns3::WifiPhy::GetHeMcs3 ();
+    ns3::WifiPhy::GetHeMcs4 ();
+    ns3::WifiPhy::GetHeMcs5 ();
+    ns3::WifiPhy::GetHeMcs6 ();
+    ns3::WifiPhy::GetHeMcs7 ();
+    ns3::WifiPhy::GetHeMcs8 ();
+    ns3::WifiPhy::GetHeMcs9 ();
+    ns3::WifiPhy::GetHeMcs10 ();
+    ns3::WifiPhy::GetHeMcs11 ();
   }
 } g_constructor;
 
diff --git a/ns-3.26/src/wifi/model/wifi-phy.h b/ns-3.26/src/wifi/model/wifi-phy.h
index 3166806..b99dfa5 100644
--- a/ns-3.26/src/wifi/model/wifi-phy.h
+++ b/ns-3.26/src/wifi/model/wifi-phy.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_PHY_H
@@ -45,6 +58,7 @@
 
 namespace ns3 {
 
+#define HE_PHY 125
 #define VHT_PHY 126
 #define HT_PHY 127
 
@@ -75,6 +89,27 @@ struct mpduInfo
   uint32_t mpduRefNumber;
 };
 
+
+typedef struct RUInfo_ {
+   uint16_t type;
+   uint16_t index;
+   uint32_t m_aid;
+   uint16_t codingType;
+   uint16_t mcs;
+   uint16_t dcm;
+   uint16_t ssAllocation;
+   uint8_t  mpduMuSpacingFactor;
+   uint8_t  tidAggregationLimit;
+   uint8_t  acPreferenceLevel;
+   uint8_t  preferredAc;
+   bool m_baAckPolicy;
+   bool m_multiTid;
+   bool m_compressed;
+   uint16_t m_tidInfo;
+} RuInfo;
+
+typedef std::map<uint16_t, RuInfo> staRuMap;
+
 /**
  * \brief receive notifications about phy events.
  */
@@ -239,7 +274,6 @@ public:
    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
    */
   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble, enum mpduType mpdutype) = 0;
-
   /**
    * \param listener the new listener
    *
@@ -339,7 +373,6 @@ public:
    * \return the total amount of time this PHY will stay busy for the transmission of the PLCP preamble and PLCP header.
    */
   Time CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector, enum WifiPreamble preamble);
-
   /**
    * \param preamble the type of preamble
    * \param txVector the transmission parameters used for this packet
@@ -1093,6 +1126,22 @@ public:
    * \return MCS 9 from VHT MCS values
    */
   static WifiMode GetVhtMcs9 ();
+  /**
+   * For AX, MCS 0 to 11
+   */
+  WifiMode GetHeMcs(uint32_t mcs);
+  static WifiMode GetHeMcs0 ();
+  static WifiMode GetHeMcs1 ();
+  static WifiMode GetHeMcs2 ();
+  static WifiMode GetHeMcs3 ();
+  static WifiMode GetHeMcs4 ();
+  static WifiMode GetHeMcs5 ();
+  static WifiMode GetHeMcs6 ();
+  static WifiMode GetHeMcs7 ();
+  static WifiMode GetHeMcs8 ();
+  static WifiMode GetHeMcs9 ();
+  static WifiMode GetHeMcs10 ();
+  static WifiMode GetHeMcs11 ();
   /**
    * The standard disallows certain combinations of WifiMode, number of
    * spatial streams, and channel widths.  This method can be used to
@@ -1267,6 +1316,26 @@ public:
    * \return the energy detection threshold.
    */
   double GetEdThresholdW (void) const;
+  /**
+   * Sets the energy detection threshold (dBm) for obss AP to drop the packet.
+   * The energy of a received signal should be higher than
+   * this threshold (dbm) to allow the PHY layer to drop the packet.
+   *
+   * \param threshold the energy detction threshold in dBm
+   */
+  void SetObssCcaThreshold (double threshold);
+  /**
+   * Return the energy detection threshold (dBm).
+   *
+   * \return the energy detection threshold in dBm
+   */
+  double GetObssCcaThreshold (void) const;
+  /**
+   * Return the energy detection threshold.
+   *
+   * \return the energy detection threshold.
+   */
+  double GetObssCcaThresholdW (void) const;
   /**
    * Sets the CCA threshold (dBm). The energy of a received signal
    * should be higher than this threshold to allow the PHY
@@ -1543,7 +1612,36 @@ public:
    * \return dB
    */
   double RatioToDb (double ratio) const;
-
+  /**
+   * Set AID of this station
+   *
+   * \param aid
+   */
+  void SetAid (uint16_t aid);
+  /**
+   * Get Aid of this station
+   *
+   * \return aid
+   */
+  uint16_t GetAid (void) const;
+  /**
+   * Set Color of this BSS
+   *
+   * \param color
+   */
+  void SetColor (uint8_t color);
+  /**
+   * Get Color of this BSS
+   *
+   * \return color
+   */
+  uint8_t GetColor (void) const;
+  /**
+   * Set Resource Unit to be used in PHY
+   *
+   * \param ru
+   */
+  void SetRu (uint8_t ru);
 protected:
   // Inherited
   virtual void DoInitialize (void);
@@ -1640,6 +1738,11 @@ private:
    * supported rates for 802.11ac standard.
    */
   void Configure80211ac (void);
+  /**
+   * Configure WifiPhy with appropriate channel frequency and
+   * supported rates for 802.11ax standard.
+   */
+  void Configure80211ax (void);
   /**
    * Configure the device Mcs set with the appropriate HtMcs modes for
    * the number of available transmit spatial streams
@@ -1804,6 +1907,7 @@ private:
   uint32_t m_channelWidth;             //!< Channel width
 
   double m_edThresholdW;          //!< Energy detection threshold in watts
+  double   m_obssCcaThresholdW;      //!< Energy detection threshold in watts for BSS of different color
   double   m_ccaMode1ThresholdW;  //!< Clear channel assessment (CCA) threshold in watts
   double   m_txGainDb;            //!< Transmission gain (dB)
   double   m_rxGainDb;            //!< Reception gain (dB)
@@ -1833,6 +1937,8 @@ private:
   
   Ptr<NetDevice>     m_device;   //!< Pointer to the device
   Ptr<MobilityModel> m_mobility; //!< Pointer to the mobility model
+  uint16_t           m_aid;      //!< AID of this station
+  uint8_t            m_color;    //!< Color of this BSS
 };
 
 /**
diff --git a/ns-3.26/src/wifi/model/wifi-preamble.h b/ns-3.26/src/wifi/model/wifi-preamble.h
index f7b0baa..20191b1 100644
--- a/ns-3.26/src/wifi/model/wifi-preamble.h
+++ b/ns-3.26/src/wifi/model/wifi-preamble.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_PREAMBLE_H
@@ -34,7 +47,8 @@ enum WifiPreamble
   WIFI_PREAMBLE_HT_MF,
   WIFI_PREAMBLE_HT_GF,
   WIFI_PREAMBLE_VHT,
-  WIFI_PREAMBLE_NONE
+  WIFI_PREAMBLE_NONE,
+  WIFI_PREAMBLE_HE
 };
 
 } //namespace ns3
diff --git a/ns-3.26/src/wifi/model/wifi-remote-station-manager.cc b/ns-3.26/src/wifi/model/wifi-remote-station-manager.cc
index 0d90657..96153a1 100644
--- a/ns-3.26/src/wifi/model/wifi-remote-station-manager.cc
+++ b/ns-3.26/src/wifi/model/wifi-remote-station-manager.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include <iostream>
@@ -360,6 +373,7 @@ WifiRemoteStationManager::GetTypeId (void)
 WifiRemoteStationManager::WifiRemoteStationManager ()
   : m_htSupported (false),
     m_vhtSupported (false),
+    m_heSupported (false),
     m_useNonErpProtection (false),
     m_shortPreambleEnabled (false),
     m_shortSlotTimeEnabled (false)
@@ -395,13 +409,24 @@ WifiRemoteStationManager::SetupPhy (Ptr<WifiPhy> phy)
   //acknowledgements.
   m_wifiPhy = phy;
   m_defaultTxMode = phy->GetMode (0);
-  if (HasHtSupported () || HasVhtSupported ())
+  if (HasHtSupported () || HasVhtSupported () || HasHeSupported ())
     {
       m_defaultTxMcs = phy->GetMcs (0);
     }
   Reset ();
 }
 
+void
+WifiRemoteStationManager::SetupDcfManager (DcfManager *manager)
+{
+
+}
+void
+WifiRemoteStationManager::SetupAidQueue (uint16_t aid, Mac48Address mac, MacLowTransmissionListener *lt, enum AcIndex ac)
+{
+
+}
+
 void
 WifiRemoteStationManager::SetupMac (Ptr<WifiMac> mac)
 {
@@ -495,6 +520,18 @@ WifiRemoteStationManager::HasVhtSupported (void) const
   return m_vhtSupported;
 }
 
+void
+WifiRemoteStationManager::SetHeSupported (bool enable)
+{
+  m_heSupported = enable;
+}
+
+bool
+WifiRemoteStationManager::HasHeSupported (void) const
+{
+  return m_heSupported;
+}
+
 uint32_t
 WifiRemoteStationManager::GetMaxSsrc (void) const
 {
@@ -794,6 +831,12 @@ WifiRemoteStationManager::GetRtsTxVector (Mac48Address address, const WifiMacHea
   return DoGetRtsTxVector (Lookup (address, header));
 }
 
+WifiTxVector
+WifiRemoteStationManager::GetMuRtsTxVector (void)
+{
+  return WifiTxVector (GetNonUnicastMode(), GetDefaultTxPowerLevel (), 0, false, 1, 0, m_wifiPhy->GetChannelWidth (), false, false);
+}
+
 void
 WifiRemoteStationManager::ReportRtsFailed (Mac48Address address, const WifiMacHeader *header)
 {
@@ -832,9 +875,26 @@ void
 WifiRemoteStationManager::ReportDataOk (Mac48Address address, const WifiMacHeader *header,
                                         double ackSnr, WifiMode ackMode, double dataSnr)
 {
+  WifiRemoteStation *station;
   NS_LOG_FUNCTION (this << address << *header << ackSnr << ackMode << dataSnr);
   NS_ASSERT (!address.IsGroup ());
-  WifiRemoteStation *station = Lookup (address, header);
+  if (HasHeSupported())
+    {
+      uint32_t tid;
+      if (header->IsQosData ())
+      {
+         tid = header->GetQosTid ();
+      }
+      else
+      {
+         tid = 0;
+      }
+      station = Lookup (address, tid);
+    }
+  else
+    {
+      station = Lookup (address, header);
+    }
   station->m_state->m_info.NotifyTxSuccess (station->m_slrc);
   station->m_slrc = 0;
   DoReportDataOk (station, ackSnr, ackMode, dataSnr);
@@ -868,12 +928,63 @@ void
 WifiRemoteStationManager::ReportRxOk (Mac48Address address, const WifiMacHeader *header,
                                       double rxSnr, WifiMode txMode)
 {
+  WifiRemoteStation *station = NULL;
   NS_LOG_FUNCTION (this << address << *header << rxSnr << txMode);
   if (address.IsGroup ())
     {
       return;
     }
-  WifiRemoteStation *station = Lookup (address, header);
+  if (HasHeSupported())
+    {
+      uint32_t tid;
+      if (header->IsQosData ())
+      {
+         tid = header->GetQosTid ();
+      }
+      else
+      {
+         tid = 0;
+      }
+      station = Lookup (address, tid);
+    }
+  else
+    {
+      station = Lookup (address, header);
+    }
+
+    station->m_state->m_isTxopLimitValid = false;
+    if (header->IsQosData () && !header->GetAddr3().IsGroup())
+      {
+        station->m_state->m_txopLimit = header->GetQosTxopLimit ();
+        station->m_state->m_isTxopLimitValid = true;
+        if (header->IsCtrlBsrMtid ())
+          {
+            for (uint ac  = 0; ac < AC_BE_NQOS; ac++)
+              {
+        	station = Lookup (address, ac*2);
+        	switch (ac)
+        	  {
+        	  case AC_VO:
+            	    station->m_state->m_Qsize[AC_VO] = header->GetVOSize();
+        	    break;
+        	  case AC_VI:
+            	    station->m_state->m_Qsize[AC_VI] = header->GetVISize();
+        	    break;
+        	  case AC_BE:
+            	    station->m_state->m_Qsize[AC_BE] = header->GetBESize();
+        	    break;
+        	  case AC_BK:
+            	    station->m_state->m_Qsize[AC_BK] = header->GetBKSize();
+        	    break;
+        	  default:
+        	    NS_ASSERT("Invalid access class");
+        	    return;
+        	  }
+        	station->m_state->m_isTxopLimitValid = true;
+              }
+
+          }
+      }
   DoReportRxOk (station, rxSnr, txMode);
 }
 
@@ -893,6 +1004,10 @@ WifiRemoteStationManager::NeedRts (Mac48Address address, const WifiMacHeader *he
 {
   WifiMode mode = txVector.GetMode ();
   NS_LOG_FUNCTION (this << address << *header << packet << mode);
+  if (m_heSupported)
+    {
+      return false;
+    }
   if (m_protectionMode == RTS_CTS
       && ((mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
       || (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
@@ -1128,6 +1243,7 @@ WifiRemoteStationManager::IsAllowedControlAnswerModulationClass (enum WifiModula
       return (modClassAnswer == WIFI_MOD_CLASS_OFDM);
     case WIFI_MOD_CLASS_HT:
     case WIFI_MOD_CLASS_VHT:
+    case WIFI_MOD_CLASS_HE:
       return true;
     default:
       NS_FATAL_ERROR ("Modulation class not defined");
@@ -1169,7 +1285,7 @@ WifiRemoteStationManager::GetControlAnswerMode (Mac48Address address, WifiMode r
           found = true;
         }
     }
-  if (HasHtSupported () || HasVhtSupported ())
+  if (HasHtSupported () || HasVhtSupported () || HasHeSupported())
     {
       if (!found)
         {
@@ -1469,6 +1585,10 @@ WifiRemoteStationManager::LookupState (Mac48Address address) const
   state->m_stbc = false;
   state->m_htSupported = false;
   state->m_vhtSupported = false;
+  state->m_heSupported = true; ///XXX: chage it later to wifi.setStandard()
+  state->m_txopLimit = 0;
+  state->m_isTxopLimitValid = false;
+
   const_cast<WifiRemoteStationManager *> (this)->m_states.push_back (state);
   NS_LOG_DEBUG ("WifiRemoteStationManager::LookupState returning new state");
   return state;
@@ -1862,6 +1982,12 @@ WifiRemoteStationManager::GetVhtSupported (const WifiRemoteStation *station) con
   return station->m_state->m_vhtSupported;
 }
 
+bool
+WifiRemoteStationManager::GetHeSupported (const WifiRemoteStation *station) const
+{
+  return station->m_state->m_heSupported;
+}
+
 uint32_t
 WifiRemoteStationManager::GetNMcsSupported (const WifiRemoteStation *station) const
 {
diff --git a/ns-3.26/src/wifi/model/wifi-remote-station-manager.h b/ns-3.26/src/wifi/model/wifi-remote-station-manager.h
index e7ec7d8..0af2437 100644
--- a/ns-3.26/src/wifi/model/wifi-remote-station-manager.h
+++ b/ns-3.26/src/wifi/model/wifi-remote-station-manager.h
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006,2007 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +16,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_REMOTE_STATION_MANAGER_H
@@ -32,6 +45,7 @@
 #include "wifi-tx-vector.h"
 #include "ht-capabilities.h"
 #include "vht-capabilities.h"
+#include "qos-utils.h"
 
 namespace ns3 {
 
@@ -40,6 +54,9 @@ struct WifiRemoteStationState;
 class WifiPhy;
 class WifiMac;
 class WifiMacHeader;
+class WifiMacQueue;
+class DcfManager;
+class MacLowTransmissionListener;
 
 /**
  * \brief Tid independent remote station statistics
@@ -113,7 +130,14 @@ public:
    * \param phy the PHY of this device
    */
   virtual void SetupMac (Ptr<WifiMac> mac);
-
+  /**
+   * Setup DCF manager for those stations that support 802.11AX
+   */
+  virtual void SetupDcfManager (DcfManager *manager);
+  /**
+   * Register a station queue with RRM Manager
+   */
+  virtual void SetupAidQueue (uint16_t aid, Mac48Address mac, MacLowTransmissionListener *lt, enum AcIndex ac);
   /**
    * Return the maximum STA short retry count (SSRC).
    *
@@ -206,6 +230,18 @@ public:
    * \return true if VHT capability support is enabled, false otherwise
    */
   bool HasVhtSupported (void) const;
+  /**
+   * Enable or disable HE capability support.
+   *
+   * \param enable enable or disable HE capability support
+   */
+  virtual void SetHeSupported (bool enable);
+  /**
+   * Return whether the device has HE capability support enabled.
+   *
+   * \return true if HE capability support is enabled, false otherwise
+   */
+  bool HasHeSupported (void) const;
   /**
    * Sets the protection mode.
    *
@@ -488,7 +524,7 @@ public:
    * is set to false, in which case, the tx parameters of the packet are calculated and stored in
    * the packet as a tag. These tx parameters are later retrieved from GetDadaMode and GetRtsMode.
    */
-  void PrepareForQueue (Mac48Address address, const WifiMacHeader *header,
+  virtual void PrepareForQueue (Mac48Address address, const WifiMacHeader *header,
                         Ptr<const Packet> packet);
 
   /**
@@ -510,6 +546,13 @@ public:
    */
   WifiTxVector GetRtsTxVector (Mac48Address address, const WifiMacHeader *header,
                                Ptr<const Packet> packet);
+  /**
+   * \return the TXVECTOR to use to send the MU RTS prior to the
+   *         transmission of the data packet itself.
+   */
+  virtual WifiTxVector GetMuRtsTxVector (void);
+  WifiTxVector GetBasicTrgTxVector(void);
+
   /**
    * \param header MAC header
    * \param packet the packet to send
@@ -789,6 +832,15 @@ protected:
    *         false otherwise
    */
   bool GetVhtSupported (const WifiRemoteStation *station) const;
+  /**
+   * Return whether the given station is HE capable.
+   *
+   * \param station the station being queried
+   *
+   * \return true if the station has HE capabilities,
+   *         false otherwise
+   */
+  bool GetHeSupported (const WifiRemoteStation *station) const;
   /**
    * Return the WifiMode supported by the specified station at the specified index.
    *
@@ -915,7 +967,15 @@ protected:
    */
   Ptr<WifiMac> GetMac (void) const;
 
-
+  /**
+   * Return the station associated with the given address and TID.
+   *
+   * \param address the address of the station
+   * \param tid the TID
+   *
+   * \return WifiRemoteStation corresponding to the address
+   */
+  WifiRemoteStation* Lookup (Mac48Address address, uint8_t tid) const;
 private:
   /**
    * \param station the station that we need to communicate
@@ -1119,15 +1179,7 @@ private:
    * \return WifiRemoteStationState corresponding to the address
    */
   WifiRemoteStationState* LookupState (Mac48Address address) const;
-  /**
-   * Return the station associated with the given address and TID.
-   *
-   * \param address the address of the station
-   * \param tid the TID
-   *
-   * \return WifiRemoteStation corresponding to the address
-   */
-  WifiRemoteStation* Lookup (Mac48Address address, uint8_t tid) const;
+
   /// Find a remote station by its remote address and TID taken from MAC header
   /**
    * Return the station associated with the given address and MAC header.
@@ -1223,6 +1275,7 @@ private:
 
   bool m_htSupported;  //!< Flag if HT capability is supported
   bool m_vhtSupported; //!< Flag if VHT capability is supported
+  bool m_heSupported;  //!< Flag if HE capability is supported
   uint32_t m_maxSsrc;  //!< Maximum STA short retry count (SSRC)
   uint32_t m_maxSlrc;  //!< Maximum STA long retry count (SLRC)
   uint32_t m_rtsCtsThreshold;  //!< Threshold for RTS/CTS
@@ -1296,6 +1349,10 @@ struct WifiRemoteStationState
   bool m_shortSlotTime;       //!< Flag if short ERP slot time is supported by the remote station
   bool m_htSupported;         //!< Flag if HT is supported by the station
   bool m_vhtSupported;        //!< Flag if VHT is supported by the station
+  bool m_heSupported;         //!< Flag is HE is supported by the station
+  uint8_t m_txopLimit;
+  uint8_t m_Qsize[AC_BE_NQOS];
+  bool m_isTxopLimitValid;
 };
 
 /**
diff --git a/ns-3.26/src/wifi/model/wifi-tx-vector.cc b/ns-3.26/src/wifi/model/wifi-tx-vector.cc
index e72bbb4..3986e38 100644
--- a/ns-3.26/src/wifi/model/wifi-tx-vector.cc
+++ b/ns-3.26/src/wifi/model/wifi-tx-vector.cc
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 CTTC
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Ghada Badawy <gbadawy@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "ns3/wifi-tx-vector.h"
@@ -32,6 +45,8 @@ WifiTxVector::WifiTxVector ()
     m_ness (0),
     m_aggregation (false),
     m_stbc (false),
+    m_ru (0xff),
+    m_color(0),
     m_modeInitialized (false),
     m_txPowerLevelInitialized (false)
 {
@@ -49,6 +64,8 @@ WifiTxVector::WifiTxVector (WifiMode mode, uint8_t powerLevel, uint8_t retries,
     m_ness (ness),
     m_aggregation (aggregation),
     m_stbc (stbc),
+    m_ru (0xff),
+    m_color(0),
     m_modeInitialized (true),
     m_txPowerLevelInitialized (true)
 {
@@ -172,6 +189,42 @@ WifiTxVector::SetStbc (bool stbc)
   m_stbc = stbc;
 }
 
+void
+WifiTxVector::SetRu (uint8_t ru)
+{
+  m_ru = ru;
+}
+
+uint8_t
+WifiTxVector::GetRu ()
+{
+  return m_ru;
+}
+
+void
+WifiTxVector::SetAid (uint16_t aid)
+{
+  m_aid = aid;
+}
+
+uint16_t
+WifiTxVector::GetAid ()
+{
+  return m_aid;
+}
+
+void
+WifiTxVector::SetColor (uint8_t color)
+{
+  m_color = color;
+}
+
+uint8_t
+WifiTxVector::GetColor ()
+{
+  return m_color;
+}
+
 std::ostream & operator << ( std::ostream &os, const WifiTxVector &v)
 {
   os << "mode: " << v.GetMode () <<
diff --git a/ns-3.26/src/wifi/model/wifi-tx-vector.h b/ns-3.26/src/wifi/model/wifi-tx-vector.h
index 3075220..1913514 100644
--- a/ns-3.26/src/wifi/model/wifi-tx-vector.h
+++ b/ns-3.26/src/wifi/model/wifi-tx-vector.h
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 CTTC
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Ghada Badawy <gbadawy@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #ifndef WIFI_TX_VECTOR_H
@@ -179,7 +192,40 @@ public:
    * \param stbc enable or disable STBC
    */
   void SetStbc (bool stbc);
-
+  /**
+  * Sets the selected RU for transmission
+  *
+  * \param ru
+  */
+  void SetRu (uint8_t ru);
+ /**
+  * Gets the selected RU used for transmission
+  *
+  *
+  */
+  uint8_t GetRu ();
+  /**
+  * Sets the selected RU for transmission
+  *
+  * \param aid
+  */
+  void SetAid (uint16_t aid);
+  /**
+  * Gets the selected RU used for transmission
+  *
+  */
+  uint16_t GetAid ();
+  /**
+  * Sets the selected color for transmission
+  *
+  * \param color
+  */
+  void SetColor (uint8_t color);
+  /**
+  * Gets the selected RU used for transmission
+  *
+  */
+  uint8_t GetColor ();
 
 private:
   WifiMode m_mode;               /**< The DATARATE parameter in Table 15-4.
@@ -196,6 +242,9 @@ private:
   uint8_t  m_ness;               /**< number of streams in beamforming */
   bool     m_aggregation;        /** Flag whether the PSDU contains A-MPDU. */
   bool     m_stbc;               /**< STBC used or not */
+  uint8_t  m_ru;                 /**< Rosource Unit(RU) used for Transmission */
+  uint16_t m_aid;                /**< AID to which TX happens */
+  uint8_t  m_color;              /**< Color information for this BSS */
 
   bool     m_modeInitialized;         //*< Internal initialization flag */
   bool     m_txPowerLevelInitialized; //*< Internal initialization flag */
diff --git a/ns-3.26/src/wifi/model/yans-error-rate-model.cc b/ns-3.26/src/wifi/model/yans-error-rate-model.cc
index dcf705e..7151e11 100644
--- a/ns-3.26/src/wifi/model/yans-error-rate-model.cc
+++ b/ns-3.26/src/wifi/model/yans-error-rate-model.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,18 @@
  *
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include <cmath>
@@ -191,7 +204,8 @@ YansErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, d
   if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM
       || mode.GetModulationClass () == WIFI_MOD_CLASS_OFDM
       || mode.GetModulationClass () == WIFI_MOD_CLASS_HT
-      || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
+      || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT
+      || mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
     {
       if (mode.GetConstellationSize () == 2)
         {
@@ -328,6 +342,33 @@ YansErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, d
                                    );
             }
         }
+      else if (mode.GetConstellationSize () == 1024)
+        {
+          if (mode.GetCodeRate () == WIFI_CODE_RATE_5_6)
+            {
+              return GetFecQamBer (snr,
+                                   nbits,
+                                   txVector.GetChannelWidth () * 1000000, // signal spread
+                                   mode.GetPhyRate (txVector), //phy rate
+                                   1024, // m
+                                   4,  // dFree
+                                   14,  // adFree
+                                   69  // adFreePlusOne
+                                   );
+            }
+          else
+            {
+              return GetFecQamBer (snr,
+                                   nbits,
+                                   txVector.GetChannelWidth () * 1000000, // signal spread
+                                   mode.GetPhyRate (txVector), //phy rate
+                                   1024, // m
+                                   5,  // dFree
+                                   8,  // adFree
+                                   31  // adFreePlusOne
+                                   );
+            }
+        }
     }
   else if (mode.GetModulationClass () == WIFI_MOD_CLASS_DSSS || mode.GetModulationClass () == WIFI_MOD_CLASS_HR_DSSS)
     {
diff --git a/ns-3.26/src/wifi/model/yans-wifi-phy.cc b/ns-3.26/src/wifi/model/yans-wifi-phy.cc
index 2ddac60..001a44d 100644
--- a/ns-3.26/src/wifi/model/yans-wifi-phy.cc
+++ b/ns-3.26/src/wifi/model/yans-wifi-phy.cc
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2005,2006 INRIA
+ * Copyright (c) 2017 Cisco and/or its affiliates
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,18 @@
  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
  *          Ghada Badawy <gbadawy@gmail.com>
  *          Sébastien Deronne <sebastien.deronne@gmail.com>
+ * 
+ * Modified in 2017 by                  
+ *          Balamurugan Ramachandran,
+ *          Ramachandra Murthy,
+ *          Bibek Sahu,
+ *          Mukesh Taneja
+ *
+ */
+
+/* 
+ * This file is modified for OFDMA/802.11ax type of systems. It is not
+ * fully compliant to IEEE 802.11ax standards.
  */
 
 #include "yans-wifi-phy.h"
@@ -565,12 +578,12 @@ YansWifiPhy::EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enum mp
         {
           /* failure. */
           NotifyRxDrop (packet);
-          m_state->SwitchFromRxEndError (packet, snrPer.snr);
+          m_state->SwitchFromRxEndError (packet, snrPer.snr, event->GetTxVector());
         }
     }
   else
     {
-      m_state->SwitchFromRxEndError (packet, snrPer.snr);
+      m_state->SwitchFromRxEndError (packet, snrPer.snr, event->GetTxVector());
     }
 
   if (preamble == WIFI_PREAMBLE_NONE && mpdutype == LAST_MPDU_IN_AGGREGATE)
diff --git a/ns-3.26/src/wifi/wscript b/ns-3.26/src/wifi/wscript
index 0ba3c19..31a8f16 100644
--- a/ns-3.26/src/wifi/wscript
+++ b/ns-3.26/src/wifi/wscript
@@ -18,6 +18,8 @@ def build(bld):
         'model/yans-wifi-phy.cc',
         'model/yans-wifi-channel.cc',
         'model/spectrum-wifi-phy.cc',
+        'model/HE-wifi-phy.cc',
+        'model/HE-wifi-channel.cc',
         'model/wifi-phy-tag.cc',
         'model/wifi-spectrum-phy-interface.cc',
         'model/wifi-spectrum-signal-parameters.cc',
@@ -34,6 +36,7 @@ def build(bld):
         'model/mgt-headers.cc',
         'model/random-stream.cc',
         'model/dcf-manager.cc',
+        'model/rrm-wifi-manager.cc',
         'model/wifi-mac.cc',
         'model/regular-wifi-mac.cc',
         'model/wifi-remote-station-manager.cc',
@@ -65,6 +68,7 @@ def build(bld):
         'model/block-ack-manager.cc',
         'model/block-ack-cache.cc',
         'model/snr-tag.cc',
+        'model/per-tag.cc',
         'model/ht-capabilities.cc',
         'model/wifi-tx-vector.cc',
         'model/parf-wifi-manager.cc',
@@ -80,12 +84,14 @@ def build(bld):
         'model/ht-operations.cc',
         'model/dsss-parameter-set.cc',
         'model/edca-parameter-set.cc',
+	'model/tlv_impl.cc',
         'helper/wifi-radio-energy-model-helper.cc',
         'helper/vht-wifi-mac-helper.cc',
         'helper/ht-wifi-mac-helper.cc',
         'helper/athstats-helper.cc',
         'helper/wifi-helper.cc',
         'helper/yans-wifi-helper.cc',
+        'helper/HE-wifi-helper.cc',
         'helper/spectrum-wifi-helper.cc',
         'helper/nqos-wifi-mac-helper.cc',
         'helper/qos-wifi-mac-helper.cc',
@@ -125,6 +131,7 @@ def build(bld):
         'model/interference-helper.h',
         'model/wifi-remote-station-manager.h',
         'model/ap-wifi-mac.h',
+        'model/rrm-wifi-manager.h',
         'model/sta-wifi-mac.h',
         'model/adhoc-wifi-mac.h',
         'model/arf-wifi-manager.h',
@@ -169,6 +176,7 @@ def build(bld):
         'model/block-ack-manager.h',
         'model/block-ack-cache.h',
         'model/snr-tag.h',
+        'model/per-tag.h',
         'model/ht-capabilities.h',
         'model/parf-wifi-manager.h',
         'model/aparf-wifi-manager.h',
@@ -184,12 +192,16 @@ def build(bld):
         'model/ht-operations.h',
         'model/dsss-parameter-set.h',
         'model/edca-parameter-set.h',
+        'model/HE-wifi-phy.h',
+        'model/HE-wifi-channel.h',
+	'model/tlv.h',
         'helper/wifi-radio-energy-model-helper.h',
         'helper/vht-wifi-mac-helper.h',
         'helper/ht-wifi-mac-helper.h',
         'helper/athstats-helper.h',
         'helper/wifi-helper.h',
         'helper/yans-wifi-helper.h',
+        'helper/HE-wifi-helper.h',
         'helper/spectrum-wifi-helper.h',
         'helper/nqos-wifi-mac-helper.h',
         'helper/qos-wifi-mac-helper.h',
